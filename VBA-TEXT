Option Explicit

Private Const TAM_BLOQUE As Long = 120    ' 100-160 suele ir bien en OCR
Private Const SEP_MOD As String = "[[MOD:"
Private Const SEP_NL As String = "~NL~"   ' separador de "saltos de línea" (OCR-friendly)
Private Const SEP_ENDMOD As String = "]]"

Public Sub ExportarVBA_A_FOTO()
    Dim vbc As Object
    Dim codLimpio As String, lin As String
    Dim i As Long, n As Long, r As Long
    Dim ws As Worksheet
    Dim totalBloques As Long, bloquesPorCol As Long
    Dim colBase As Long
    
    ' 1) Construir texto minificado
    codLimpio = ""
    For Each vbc In ThisWorkbook.VBProject.VBComponents
        ' Si quieres solo módulos estándar:
        ' If vbc.Type <> 1 Then GoTo NextComp
        
        codLimpio = codLimpio & SEP_MOD & vbc.Name & SEP_ENDMOD
        
        On Error Resume Next
        With vbc.CodeModule
            If .CountOfLines > 0 Then
                For i = 1 To .CountOfLines
                    lin = Trim$(.Lines(i, 1))
                    If lin <> "" And Left$(lin, 1) <> "'" Then
                        Do While InStr(lin, "  ") > 0
                            lin = Replace(lin, "  ", " ")
                        Loop
                        codLimpio = codLimpio & lin & SEP_NL
                    End If
                Next i
            End If
        End With
        On Error GoTo 0
        
'NextComp:
    Next vbc
    
    If Len(codLimpio) = 0 Then
        MsgBox "No se ha extraído código (¿Trust access VBProject?).", vbCritical
        Exit Sub
    End If
    
    ' 2) Crear hoja destino limpia
    Application.DisplayAlerts = False
    On Error Resume Next
    Sheets("FOTO_VBA").Delete
    On Error GoTo 0
    Application.DisplayAlerts = True
    
    Set ws = Sheets.Add
    ws.Name = "FOTO_VBA"
    
    ' 3) Calcular bloques y repartir en 2 columnas anchas: A-B y D-E
    totalBloques = Application.WorksheetFunction.RoundUp(Len(codLimpio) / TAM_BLOQUE, 0)
    bloquesPorCol = Application.WorksheetFunction.RoundUp(totalBloques / 2, 0)
    
    n = 1
    For i = 1 To Len(codLimpio) Step TAM_BLOQUE
        colBase = IIf(n <= bloquesPorCol, 0, 3) ' 0->A/B, 3->D/E
        r = ((n - 1) Mod bloquesPorCol) + 2
        
        ws.Cells(r, colBase + 1).Value = n
        ws.Cells(r, colBase + 2).Value = "'" & Mid$(codLimpio, i, TAM_BLOQUE)
        
        n = n + 1
    Next i
    
    ' 4) Formato para foto/OCR
    With ws
        .Cells.Font.Name = "Consolas"
        .Cells.Font.Size = 11
        .Cells.VerticalAlignment = xlTop
        .Columns("A").ColumnWidth = 6
        .Columns("B").ColumnWidth = 90
        .Columns("C").ColumnWidth = 3
        .Columns("D").ColumnWidth = 6
        .Columns("E").ColumnWidth = 90
        
        .Rows(1).Font.Bold = True
        .Cells(1, 1).Value = "ID"
        .Cells(1, 2).Value = "DATA"
        .Cells(1, 4).Value = "ID"
        .Cells(1, 5).Value = "DATA"
        
        ActiveWindow.DisplayGridlines = False
        ActiveWindow.Zoom = 100
        .Range("A2").Select
        ActiveWindow.FreezePanes = True
    End With
    
    MsgBox "Listo. Bloques totales: " & (n - 1) & vbCrLf & _
           "Haz fotos que cubran ambas columnas (A-B y D-E).", vbInformation
End Sub


-----------------------------
Option Explicit

Private Const SEP_MOD As String = "[[MOD:"
Private Const SEP_ENDMOD As String = "]]"
Private Const SEP_NL As String = "~NL~"

Public Sub Reconstruir_VBA_Completo_Desde_FOTO()
    Dim ws As Worksheet
    Dim dict As Object
    Dim lastRow As Long, r As Long
    Dim id As Long, data As String
    Dim maxId As Long
    Dim missing As String
    Dim txt As String
    Dim wbNew As Workbook
    Dim pos As Long, nextPos As Long
    Dim modName As String, body As String
    Dim vbComp As Object
    
    Set ws = Sheets("FOTO_VBA")
    Set dict = CreateObject("Scripting.Dictionary")
    
    ' --------------------------------------------
    ' 1) LEER BLOQUES A/B
    ' --------------------------------------------
    lastRow = ws.Cells(ws.Rows.Count, "B").End(xlUp).Row
    If ws.Cells(ws.Rows.Count, "E").End(xlUp).Row > lastRow Then
        lastRow = ws.Cells(ws.Rows.Count, "E").End(xlUp).Row
    End If
    
    For r = 2 To lastRow
        If IsNumeric(ws.Cells(r, "A").Value) Then
            id = CLng(ws.Cells(r, "A").Value)
            data = CStr(ws.Cells(r, "B").Value)
            If Left$(data, 1) = "'" Then data = Mid$(data, 2)
            If data <> "" Then dict(id) = data
            If id > maxId Then maxId = id
        End If
    Next r
    
    ' --------------------------------------------
    ' 2) LEER BLOQUES D/E
    ' --------------------------------------------
    For r = 2 To lastRow
        If IsNumeric(ws.Cells(r, "D").Value) Then
            id = CLng(ws.Cells(r, "D").Value)
            data = CStr(ws.Cells(r, "E").Value)
            If Left$(data, 1) = "'" Then data = Mid$(data, 2)
            If data <> "" Then dict(id) = data
            If id > maxId Then maxId = id
        End If
    Next r
    
    If maxId = 0 Then
        MsgBox "No se han encontrado bloques válidos.", vbCritical
        Exit Sub
    End If
    
    ' --------------------------------------------
    ' 3) VALIDAR CONTINUIDAD Y RECONSTRUIR TEXTO
    ' --------------------------------------------
    txt = ""
    missing = ""
    
    For id = 1 To maxId
        If Not dict.Exists(id) Then
            missing = missing & id & ","
        Else
            txt = txt & dict(id)
        End If
    Next id
    
    If missing <> "" Then
        MsgBox "FALTAN BLOQUES: " & Left$(missing, Len(missing) - 1) & _
               vbCrLf & "Reconstrucción abortada.", vbCritical
        Exit Sub
    End If
    
    ' --------------------------------------------
    ' 4) CREAR LIBRO NUEVO
    ' --------------------------------------------
    Set wbNew = Workbooks.Add
    
    ' --------------------------------------------
    ' 5) CREAR MÓDULOS VBA
    ' --------------------------------------------
    pos = 1
    Do
        pos = InStr(pos, txt, SEP_MOD, vbTextCompare)
        If pos = 0 Then Exit Do
        
        pos = pos + Len(SEP_MOD)
        nextPos = InStr(pos, txt, SEP_ENDMOD, vbTextCompare)
        If nextPos = 0 Then Exit Do
        
        modName = Mid$(txt, pos, nextPos - pos)
        pos = nextPos + Len(SEP_ENDMOD)
        
        nextPos = InStr(pos, txt, SEP_MOD, vbTextCompare)
        If nextPos = 0 Then
            body = Mid$(txt, pos)
        Else
            body = Mid$(txt, pos, nextPos - pos)
        End If
        
        body = Replace(body, SEP_NL, vbCrLf)
        
        Set vbComp = wbNew.VBProject.VBComponents.Add(1) ' módulo estándar
        On Error Resume Next
        vbComp.Name = modName
        On Error GoTo 0
        vbComp.CodeModule.AddFromString body
        
        If nextPos = 0 Then Exit Do
        pos = nextPos
    Loop
    
    MsgBox "VBA reconstruido COMPLETAMENTE en un libro nuevo." & vbCrLf & _
           "Módulos creados: " & wbNew.VBProject.VBComponents.Count, vbInformation
End Sub
