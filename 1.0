1# ==========================================================
# Buscar literales en Blueprints (modo escaneo o listado con memoria + mejora carpetas)
# ==========================================================
$ErrorActionPreference = "Stop"
$memFile = "$env:USERPROFILE\.blueprint_lastpath.txt"

# ---------- Funciones ----------
function Remove-Diacritics([string]$s){
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray() | Where-Object {
        [Globalization.CharUnicodeInfo]::GetUnicodeCategory($_) -ne [Globalization.UnicodeCategory]::NonSpacingMark
    }) -join ''
}
function Normalize([string]$s){ (Remove-Diacritics $s).ToLowerInvariant().Trim() }
function ColumnLetter([int]$n) {
    $s = ""
    while ($n -gt 0) { $n--; $s = ([char]([int][char]'A' + ($n % 26))) + $s; $n = [math]::Floor($n / 26) }
    return $s
}
function Select-Mode {
    Write-Host "`nüü¶ MODO DE B√öSQUEDA" -ForegroundColor Cyan
    Write-Host "1Ô∏è‚É£  Escanear autom√°ticamente todas las carpetas"
    Write-Host "2Ô∏è‚É£  Usar fichero con rutas de carpetas o de Excel"
    $resp = Read-Host "Elige modo (1 o 2)"
    if ($resp -eq "2") { return 2 } else { return 1 }
}

# ---------- Entrada ----------
Write-Host "üîç B√∫squeda de literales en Blueprints ‚Üí hoja 'An√°lisis conceptos'" -ForegroundColor Cyan

$mode = Select-Mode
$rutaListado = $null
$blueprints = @()

if ($mode -eq 1) {
    $basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. R:\Proyectos)"
    if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }
}
else {
    # recordar √∫ltima ruta
    if (Test-Path $memFile) {
        $lastPath = Get-Content $memFile -Raw
        if (-not [string]::IsNullOrWhiteSpace($lastPath) -and (Test-Path $lastPath)) {
            Write-Host "`nüíæ √öltimo fichero de rutas usado:" -ForegroundColor Yellow
            Write-Host "   $lastPath"
            $useLast = Read-Host "¬øUsar el mismo? (S/N)"
            if ($useLast -match '^[sS]$') { $rutaListado = $lastPath }
        }
    }
    if (-not $rutaListado) {
        $rutaListado = Read-Host "üìÑ Introduce la ruta del fichero con rutas de carpetas o de Excel"
        if (-not (Test-Path $rutaListado)) { Write-Host "‚ùå Fichero no encontrado."; exit }
        Set-Content -Path $memFile -Value $rutaListado
        Write-Host "üíæ Ruta guardada para pr√≥ximas ejecuciones." -ForegroundColor Green
    }
}

Write-Host "`n‚úèÔ∏è  Introduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++){
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "‚ùå Sin literales. Saliendo."; exit }

$pattern = ($literals | ForEach-Object { [regex]::Escape((Normalize $_)) }) -join "|"
$reDoc = '(?i)(documentaci[o√≥]n\s+implantaci[o√≥]n)'
$reAna = '(?i)(an[a√°]lisis)'

# ---------- Obtener lista de Blueprints ----------
if ($mode -eq 1) {
    Write-Host "`nüìÅ Escaneando carpetas autom√°ticamente..." -ForegroundColor DarkCyan
    Get-ChildItem -Path $basePath -Directory |
      Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
      Sort-Object LastWriteTime -Descending |
      ForEach-Object {
        $dir1 = $_
        Write-Host ("‚Üí Revisando carpeta principal: {0}" -f $dir1.Name) -ForegroundColor Yellow

        Get-ChildItem -Path $dir1.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
            $dir2 = $_
            $docDirs = Get-ChildItem -Path $dir2.FullName -Directory -ErrorAction SilentlyContinue |
                       Where-Object { $_.Name -match $reDoc }

            foreach ($doc in $docDirs) {
                $anaDirs = Get-ChildItem -Path $doc.FullName -Directory -ErrorAction SilentlyContinue |
                           Where-Object { $_.Name -match $reAna }

                foreach ($ana in $anaDirs) {
                    Write-Host ("   üìÇ Revisando subcarpeta: {0}" -f $ana.FullName) -ForegroundColor Cyan
                    $found = Get-ChildItem -Path $ana.FullName -Recurse -File -ErrorAction SilentlyContinue |
                             Where-Object { $_.Name -notlike '~$*' -and $_.Name -match '(?i)Blueprint.*\.(xlsx|xlsm)$' }
                    foreach ($f in $found) {
                        Write-Host ("      ‚úÖ Encontrado Blueprint: {0}" -f $f.FullName) -ForegroundColor Green
                        $blueprints += $f.FullName
                    }
                }
            }
        }
    }
}
else {
    Write-Host "`nüìÑ Cargando rutas desde listado: $rutaListado" -ForegroundColor DarkCyan
    $rutas = Get-Content $rutaListado | Where-Object { -not [string]::IsNullOrWhiteSpace($_) -and (Test-Path $_) }
    foreach ($ruta in $rutas) {
        if ((Get-Item $ruta).PSIsContainer) {
            # Es carpeta: buscar dentro
            $found = Get-ChildItem -Path $ruta -Recurse -File -ErrorAction SilentlyContinue |
                     Where-Object { $_.Name -match '(?i)Blueprint.*\.(xlsx|xlsm)$' }
            foreach ($f in $found) { $blueprints += $f.FullName }
        } else {
            # Es archivo Excel directamente
            $blueprints += $ruta
        }
    }
    if ($blueprints.Count -eq 0) { Write-Host "‚ö†Ô∏è No se encontraron Blueprints v√°lidos."; exit }
}

Write-Host ("   ‚Üí {0} ficheros detectados." -f $blueprints.Count) -ForegroundColor Green

# ---------- An√°lisis Excel ----------
# Guardar Excel existentes antes del script
$prevExcel = Get-Process excel -ErrorAction SilentlyContinue

$excel = New-Object -ComObject Excel.Application
$excel.Visible = $false
$excel.DisplayAlerts = $false
$excel.AutomationSecurity = 3
$excel.EnableEvents = $false

$totalEncontrados = 0
$totalBlueprintsOK = 0
$detalles = @()
$inicio = Get-Date

foreach ($path in $blueprints) {
    $nombre = Split-Path $path -Leaf
    Write-Host ("`nüîπ Analizando: {0}" -f $path) -ForegroundColor DarkCyan
    try {
        $wb = $excel.Workbooks.Open($path, 0, $true)
        $target = $null
        foreach ($sh in $wb.Worksheets) {
            $n = Normalize $sh.Name
            if ($n -match 'analisis' -and $n -match 'concept') { $target = $sh; break }
        }
        if (-not $target) {
            Write-Host ("‚ö†Ô∏è Sin hoja 'An√°lisis conceptos'") -ForegroundColor DarkYellow
            $wb.Close($false) | Out-Null
            continue
        }

        $vals = $target.UsedRange.Value2
        if (-not $vals) { Write-Host "‚ö™ Hoja vac√≠a."; $wb.Close($false); continue }

        $rows = $vals.GetLength(0)
        $cols = $vals.GetLength(1)
        $totalCells = $rows * $cols
        $processed = 0
        $hitsLocal = @()

        for ($r=1; $r -le $rows; $r++) {
            for ($c=1; $c -le $cols; $c++) {
                $processed++
                if ($processed % 500 -eq 0) {
                    $pct = [math]::Round(($processed / $totalCells) * 100, 1)
                    Write-Progress -Activity "Analizando $nombre" -Status "$pct% completado" -PercentComplete $pct
                }
                $txt = [string]$vals[$r,$c]
                if ([string]::IsNullOrWhiteSpace($txt)) { continue }
                $v = Normalize $txt
                if ($v -match $pattern) {
                    $celda = "$(ColumnLetter $c)$r"
                    Write-Host ("‚úÖ '{0}' ‚Üí {1} {2}" -f $txt, $path, $celda) -ForegroundColor Green
                    $hitsLocal += [PSCustomObject]@{
                        Fichero = $path
                        Literal = ($literals | Where-Object { $v -like ("*" + (Normalize $_) + "*") }) -join ", "
                        Celda   = $celda
                        Valor   = $txt
                    }
                }
            }
        }
        Write-Progress -Activity "Analizando $nombre" -Completed

        if ($hitsLocal.Count -gt 0) {
            $totalBlueprintsOK++
            $totalEncontrados += $hitsLocal.Count
            $detalles += $hitsLocal
            Write-Host ("   ‚úîÔ∏è {0} coincidencias encontradas." -f $hitsLocal.Count) -ForegroundColor Green
        } else {
            Write-Host ("   ‚ö™ Sin coincidencias en {0}" -f $nombre) -ForegroundColor Gray
        }

        $wb.Close($false) | Out-Null

    } catch {
        Write-Progress -Activity "Analizando $nombre" -Completed
        Write-Host ("‚ö†Ô∏è Error en {0}: {1}" -f $nombre, $_.Exception.Message) -ForegroundColor DarkYellow
    }
}

# ---------- Resumen ----------
$fin = Get-Date
$dur = New-TimeSpan -Start $inicio -End $fin
Write-Host "`n==============================================" -ForegroundColor DarkCyan
Write-Host ("üìä RESUMEN FINAL") -ForegroundColor Cyan
Write-Host ("   Blueprints analizados : {0}" -f $blueprints.Count)
Write-Host ("   Con hallazgos : {0}" -f $totalBlueprintsOK)
Write-Host ("   Coincidencias totales : {0}" -f $totalEncontrados)
Write-Host ("   Tiempo total : {0} min {1:D2} s" -f $dur.Minutes, $dur.Seconds)
Write-Host "==============================================" -ForegroundColor DarkCyan

if ($detalles.Count -gt 0) {
    Write-Host "`nüîç Detalle de coincidencias:" -ForegroundColor Yellow
    $agrupado = $detalles | Group-Object Fichero
    foreach ($g in $agrupado) {
        Write-Host "`nüìÅ $($g.Name)" -ForegroundColor Cyan
        foreach ($d in $g.Group) {
            Write-Host ("   ‚Üí {0} | {1} | {2}" -f $d.Literal, $d.Celda, $d.Valor)
        }
    }
} else {
    Write-Host "`n‚ö™ No se encontraron coincidencias." -ForegroundColor Gray
}

# ---------- Limpieza ----------
$excel.Quit()
[System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null

# Solo cerrar instancias creadas por este script
$afterExcel = Get-Process excel -ErrorAction SilentlyContinue
$openedByScript = Compare-Object $prevExcel $afterExcel -PassThru | Where-Object { $_.SideIndicator -eq '=>' }
foreach ($e in $openedByScript) {
    try { $e.Kill() } catch {}
}

Write-Host "`n‚úîÔ∏è Proceso completado correctamente (sin cerrar tu Excel abierto)." -ForegroundColor Green