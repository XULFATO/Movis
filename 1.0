# ==========================================================
# Buscar-Blueprints.ps1  ‚Äî versi√≥n estable (con prompts)
# ==========================================================
# - Pide ruta base y literales (hasta 10)
# - Recorre carpetas: '_' en 4¬™ pos. ‚Üí (2¬∫ nivel) ‚Üí Doc. Implantaci√≥n ‚Üí An√°lisis
# - Orden descendente por fecha
# - Abre Excel en solo lectura (COM), hoja que contenga 'analisis' y 'concept'
# - Busca literales (insensible a may√∫sculas/acentos) con Value2 y fallback .Text
# - Opci√≥n de parar al primer hallazgo
# - Exporta resultados a Escritorio (xlsx)
# - Compatible con PowerShell ISE: limpia instancias de Excel al inicio/fin
# ==========================================================

$ErrorActionPreference = 'Stop'

# ---------- LIMPIEZA INICIAL ISE ----------
Write-Host "üßπ Cerrando sesiones previas de Excel..." -ForegroundColor DarkGray
Get-Process excel -ErrorAction SilentlyContinue | ForEach-Object {
    try {
        $_.CloseMainWindow() | Out-Null
        Start-Sleep -Milliseconds 400
        if (-not $_.HasExited) { $_.Kill() }
    } catch {}
}
Start-Sleep -Milliseconds 600

# ---------- Utilidades ----------
function Remove-Diacritics([string]$s){
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray() | Where-Object {
        [Globalization.CharUnicodeInfo]::GetUnicodeCategory($_) -ne [Globalization.UnicodeCategory]::NonSpacingMark
    }) -join ''
}
function Normalize([string]$s){ (Remove-Diacritics $s).ToLowerInvariant() }

function Ask-YesNo($prompt) {
    while ($true) {
        $r = Read-Host "$prompt (S/N)"
        if ($r -match '^[sS]$') { return $true }
        if ($r -match '^[nN]$') { return $false }
        Write-Host "   Responde S o N, por favor." -ForegroundColor DarkYellow
    }
}

# ---------- Prompts ----------
Write-Host "üîç B√∫squeda de literales en Blueprints ‚Üí hoja 'An√°lisis conceptos' (Excel-COM, solo lectura)" -ForegroundColor Cyan

$basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`n‚úèÔ∏è  Introduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++){
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "‚ùå Sin literales. Saliendo."; exit }

$stopAtFirst = Ask-YesNo "¬øParar al encontrar la primera coincidencia?"

# Patrones de carpeta (flexibles: con/sin prefijos y tildes)
$reDoc = '(?i)(^\s*\d{0,3}\s*[-_. ]*\s*documentaci[o√≥]n\s+implantaci[o√≥]n\b)|(\bdocumentaci[o√≥]n\s+implantaci[o√≥]n\b)'
$reAna = '(?i)(^\s*\d{0,3}\s*[-_. ]*\s*an[a√°]lisis\b)|(\ban[a√°]lisis\b)'

# ---------- Recorrido de carpetas ----------
Write-Host "`nüìÅ Recorriendo estructura (con '_' en 4¬™ posici√≥n, orden fecha desc.)..." -ForegroundColor DarkCyan

$blueprints = @()

Get-ChildItem -Path $basePath -Directory |
  Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
  Sort-Object LastWriteTime -Descending |
  ForEach-Object {

    $dir1 = $_
    Write-Host ("‚Üí Revisando carpeta principal: {0}" -f $dir1.Name) -ForegroundColor Yellow

    # SEGUNDO NIVEL
    Get-ChildItem -Path $dir1.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $dir2 = $_

        # 01 Documentaci√≥n Implantaci√≥n
        $docDirs = Get-ChildItem -Path $dir2.FullName -Directory -ErrorAction SilentlyContinue |
                   Where-Object { $_.Name -match $reDoc }

        foreach ($doc in $docDirs) {
            # 03 An√°lisis
            $anaDirs = Get-ChildItem -Path $doc.FullName -Directory -ErrorAction SilentlyContinue |
                       Where-Object { $_.Name -match $reAna }

            foreach ($ana in $anaDirs) {
                Write-Host ("   üìÇ Revisando subcarpeta: {0}" -f $ana.FullName) -ForegroundColor Cyan

                $found = Get-ChildItem -Path $ana.FullName -File -ErrorAction SilentlyContinue |
                         Where-Object { $_.Name -notlike '~$*' -and $_.Name -match '(?i)Blueprint.*\.(xlsx|xlsm)$' }

                foreach ($f in $found) {
                    Write-Host ("      ‚úÖ Encontrado Blueprint: {0}" -f $f.Name) -ForegroundColor Green
                    $blueprints += $f.FullName
                }
            }
        }
    }
}

if ($blueprints.Count -eq 0) {
    Write-Host "‚ö†Ô∏è No se encontraron ficheros 'Blueprint' en la estructura esperada." -ForegroundColor DarkYellow
    exit 0
}

Write-Host ("   ‚Üí {0} ficheros 'Blueprint' detectados." -f $blueprints.Count) -ForegroundColor Green

# ---------- B√∫squeda en Excel (COM) ----------
$excel = $null
$results = New-Object System.Collections.Generic.List[object]

try {
    $excel = New-Object -ComObject Excel.Application
    $excel.Visible = $false
    $excel.DisplayAlerts = $false
    $excel.AutomationSecurity = 3  # Disable macros
    $excel.EnableEvents = $false

    foreach ($path in $blueprints) {
        $wb = $null
        try {
            Write-Host ("      ‚è≥ Abriendo (solo lectura): {0}" -f $path) -ForegroundColor DarkGray
            $wb = $excel.Workbooks.Open($path, 0, $true)  # ReadOnly=true

            # localizar hoja: contiene 'analisis' y 'concept'
            $target = $null
            foreach ($sh in $wb.Worksheets) {
                $n = Normalize $sh.Name
                if ($n -match 'analisis' -and $n -match 'concept') { $target = $sh; break }
            }

            if (-not $target) {
                Write-Host ("      ‚ö†Ô∏è Sin hoja tipo 'An√°lisis conceptos' en {0}" -f (Split-Path $path -Leaf)) -ForegroundColor DarkYellow
                continue
            }

            Write-Host ("      üîç Analizando hoja '{0}'..." -f $target.Name) -ForegroundColor DarkGray

            $used = $target.UsedRange
            $rows = $used.Rows.Count
            $cols = $used.Columns.Count

            # 1) Intento r√°pido: matriz Value2
            $foundHere = $false
            $data = $null
            try { $data = $used.Value2 } catch {}

            if ($data -and $data.GetType().IsArray) {
                for ($r=1; $r -le $rows; $r++){
                    for ($c=1; $c -le $cols; $c++){
                        $val = $data[$r,$c]
                        if ($null -ne $val) {
                            $v = Normalize ($val.ToString())
                            foreach ($lit in $literals) {
                                if ($v -like ("*" + (Normalize $lit) + "*")) {
                                    $results.Add([PSCustomObject]@{
                                        Fichero = $path
                                        Hoja    = $target.Name
                                        Literal = $lit
                                        Celda   = "$r,$c"
                                        Valor   = $val.ToString()
                                    })
                                    Write-Host ("‚úÖ '{0}' en {1} ‚Üí {2},{3} ('{4}')" -f $lit, (Split-Path $path -Leaf), $r, $c, $val) -ForegroundColor Green
                                    $foundHere = $true
                                    if ($stopAtFirst) { throw "STOP_GLOBAL" }
                                }
                            }
                        }
                    }
                }
            }

            # 2) Fallback robusto: celda a celda con .Text
            if (-not $foundHere) {
                for ($r=1; $r -le $rows; $r++){
                    for ($c=1; $c -le $cols; $c++){
                        $txt = ""
                        try { $txt = [string]$used.Cells.Item($r,$c).Text } catch { continue }
                        if ([string]::IsNullOrWhiteSpace($txt)) { continue }
                        $v = Normalize $txt
                        foreach ($lit in $literals) {
                            if ($v -like ("*" + (Normalize $lit) + "*")) {
                                $results.Add([PSCustomObject]@{
                                    Fichero = $path
                                    Hoja    = $target.Name
                                    Literal = $lit
                                    Celda   = "$r,$c"
                                    Valor   = $txt
                                })
                                Write-Host ("‚úÖ '{0}' en {1} ‚Üí {2},{3} ('{4}')" -f $lit, (Split-Path $path -Leaf), $r, $c, $txt) -ForegroundColor Green
                                if ($stopAtFirst) { throw "STOP_GLOBAL" }
                            }
                        }
                    }
                }
            }

            if (-not $foundHere) {
                Write-Host ("      ‚ö™ Sin coincidencias en '{0}'" -f (Split-Path $path -Leaf)) -ForegroundColor Gray
            }

        } catch {
            if ($_.Exception.Message -eq "STOP_GLOBAL") { throw }
            Write-Host ("‚ö†Ô∏è Error con {0}: {1}" -f (Split-Path $path -Leaf), $_.Exception.Message) -ForegroundColor DarkYellow
        } finally {
            if ($wb) { $wb.Close($false) | Out-Null }
        }
    }

    # ---------- Exportar resultados ----------
    $outPath = Join-Path $env:USERPROFILE "Desktop\Resultados_Blueprint.xlsx"
    if ($results.Count -gt 0){
        $wbOut = $excel.Workbooks.Add()
        $ws = $wbOut.Sheets.Item(1)
        $ws.Name = "Resultados"
        $headers = "Fichero","Hoja","Literal","Celda","Valor"
        for ($i=0; $i -lt $headers.Count; $i++){ $ws.Cells.Item(1,$i+1) = $headers[$i] }
        $r=2
        foreach($it in $results){
            $ws.Cells.Item($r,1)=$it.Fichero
            $ws.Cells.Item($r,2)=$it.Hoja
            $ws.Cells.Item($r,3)=$it.Literal
            $ws.Cells.Item($r,4)=$it.Celda
            $ws.Cells.Item($r,5)=$it.Valor
            $r++
        }
        $ws.Range("A1:E$($r-1)").EntireColumn.AutoFit() | Out-Null
        $wbOut.SaveAs($outPath)
        $wbOut.Close($false)
        Write-Host "`n‚úÖ Terminado. Resultados guardados en: $outPath" -ForegroundColor Green
    } else {
        Write-Host "`n‚ö™ No se encontraron coincidencias." -ForegroundColor Gray
    }

} finally {
    # ---------- LIMPIEZA FINAL ISE ----------
    Write-Host "üßπ Cerrando Excel y liberando COM..." -ForegroundColor DarkGray
    try {
        if ($excel) { $excel.Quit(); [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null }
    } catch {}
    Start-Sleep -Milliseconds 300
    try {
        Get-Process excel -ErrorAction SilentlyContinue | ForEach-Object {
            $_.CloseMainWindow() | Out-Null
            Start-Sleep -Milliseconds 300
            if (-not $_.HasExited) { $_.Kill() }
        }
    } catch {}
    [GC]::Collect()
    [GC]::WaitForPendingFinalizers()
}