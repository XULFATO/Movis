Option Explicit

' =============================================================================
' VBA Excel Workbook Obfuscator / Deobfuscator - VERSIÓN CORREGIDA
'
' CORRIGE:
'   - Strings que no se ofuscaban
'   - Duplicación de dDecode
'   - Manejo correcto de comillas anidadas
' =============================================================================

Private Const TAG_KEY As String = "'__OFUKEY__="
Private Const TAG_NOISE As String = "'__OFUNOISE__"
Private Const TAG_COMMENT As String = "'__OFUCOMMENT__:"
Private Const RUNTIME_MODULE_NAME As String = "z_ofu_runtime"
Private Const NOISE_RATE As Long = 5

' =============================================================================
' PUNTOS DE ENTRADA
' =============================================================================

Public Sub OFUSCAR_COPIA()
    ProcessWorkbook True
End Sub

Public Sub DESOFUSCAR_COPIA()
    ProcessWorkbook False
End Sub

' =============================================================================
' FLUJO PRINCIPAL
' =============================================================================

Private Sub ProcessWorkbook(ByVal doObfuscate As Boolean)
    Dim srcPath As String, dstPath As String
    Dim wbSrc As Workbook, wbDst As Workbook
    Dim startTime As Double

    srcPath = PickXlsmFile()
    If Len(srcPath) = 0 Then Exit Sub

    If doObfuscate Then
        dstPath = AddSuffixToPath(srcPath, "_OFUSCADO")
    Else
        dstPath = AddSuffixToPath(srcPath, "_DESOFUSCADO")
    End If

    startTime = Timer
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    On Error GoTo ErrorHandler

    Set wbSrc = Workbooks.Open(srcPath, ReadOnly:=True)
    wbSrc.SaveCopyAs dstPath
    wbSrc.Close False

    Set wbDst = Workbooks.Open(dstPath, ReadOnly:=False)

    If doObfuscate Then
        EnsureRuntimeModule wbDst
        ObfuscateProject wbDst
    Else
        DeobfuscateProject wbDst
        RemoveRuntimeModule wbDst
    End If

    wbDst.Save
    wbDst.Close

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox IIf(doObfuscate, "OFUSCADO OK en ", "DESOFUSCADO OK en ") & _
           Format$(Timer - startTime, "0.0") & "s" & vbCrLf & dstPath, vbInformation
    Exit Sub

ErrorHandler:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "Error: " & Err.Description, vbCritical
End Sub

' =============================================================================
' SELECCIÓN DE ARCHIVO
' =============================================================================

Private Function PickXlsmFile() As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = "Selecciona el archivo .XLSM"
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled (*.xlsm)", "*.xlsm"
        If .Show <> -1 Then
            PickXlsmFile = ""
        Else
            PickXlsmFile = .SelectedItems(1)
        End If
    End With
End Function

Private Function AddSuffixToPath(ByVal fullPath As String, ByVal suffix As String) As String
    Dim p As Long
    p = InStrRev(fullPath, ".")
    If p > 0 Then
        AddSuffixToPath = Left$(fullPath, p - 1) & suffix & Mid$(fullPath, p)
    Else
        AddSuffixToPath = fullPath & suffix
    End If
End Function

' =============================================================================
' GESTIÓN DEL MÓDULO RUNTIME
' =============================================================================

Private Sub EnsureRuntimeModule(ByVal wb As Workbook)
    Dim c As Object
    On Error Resume Next
    Set c = wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0

    If c Is Nothing Then
        Set c = wb.VBProject.VBComponents.Add(1)
        c.Name = RUNTIME_MODULE_NAME
    End If

    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        .AddFromString RuntimeCode()
    End With
End Sub

Private Sub RemoveRuntimeModule(ByVal wb As Workbook)
    On Error Resume Next
    wb.VBProject.VBComponents.Remove wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0
End Sub

Private Function RuntimeCode() As String
    RuntimeCode = _
        "Option Explicit" & vbCrLf & _
        vbCrLf & _
        "Public Function dDecode(ByVal hex4 As String, ByVal k As Long) As String" & vbCrLf & _
        "    Dim i As Long, v As Long, r As String" & vbCrLf & _
        "    For i = 1 To Len(hex4) Step 4" & vbCrLf & _
        "        v = CLng(""&H"" & Mid$(hex4, i, 4))" & vbCrLf & _
        "        r = r & ChrW$(v Xor k)" & vbCrLf & _
        "    Next i" & vbCrLf & _
        "    dDecode = r" & vbCrLf & _
        "End Function"
End Function

' =============================================================================
' PROCESAMIENTO DEL PROYECTO
' =============================================================================

Private Sub ObfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        If c.Name <> RUNTIME_MODULE_NAME Then
            code = GetCode(c)
            If Len(code) > 0 Then
                key = MakeKey()
                code = InjectDummyDeclarationOnce(code)
                code = ObfuscateCodeFast(code, key)
                SetCode c, TAG_KEY & key & vbCrLf & code
            End If
        End If
    Next
End Sub

Private Sub DeobfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        code = GetCode(c)
        key = ExtractKey(code)
        If key > 0 Then
            code = DeobfuscateCodeFast(code, key)
            SetCode c, code
        End If
    Next
End Sub

' =============================================================================
' LECTURA Y ESCRITURA
' =============================================================================

Private Function GetCode(ByVal c As Object) As String
    With c.CodeModule
        If .CountOfLines = 0 Then
            GetCode = ""
        Else
            GetCode = .Lines(1, .CountOfLines)
        End If
    End With
End Function

Private Sub SetCode(ByVal c As Object, ByVal txt As String)
    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        If Len(txt) > 0 Then .AddFromString txt
    End With
End Sub

' =============================================================================
' INYECCIÓN DE VARIABLE DUMMY
' =============================================================================

Private Function InjectDummyDeclarationOnce(ByVal code As String) As String
    Dim lines() As String, i As Long
    Dim result() As String
    Dim injected As Boolean, count As Long
    
    lines = Split(code, vbCrLf)
    ReDim result(UBound(lines) + 1)
    
    injected = False
    count = 0

    For i = LBound(lines) To UBound(lines)
        result(count) = lines(i)
        count = count + 1
        
        If Not injected Then
            Dim trimLine As String
            trimLine = LCase$(Trim$(lines(i)))
            
            If trimLine Like "sub *" Or trimLine Like "public sub *" Or _
               trimLine Like "private sub *" Or trimLine Like "function *" Or _
               trimLine Like "public function *" Or trimLine Like "private function *" Then
                result(count) = "    Dim ofuDummy As Long"
                count = count + 1
                injected = True
            End If
        End If
    Next i
    
    ReDim Preserve result(count - 1)
    InjectDummyDeclarationOnce = Join(result, vbCrLf)
End Function

' =============================================================================
' OFUSCACIÓN RÁPIDA
' =============================================================================

Private Function ObfuscateCodeFast(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String
    Dim count As Long
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines) * 2)
    
    count = 0

    For i = LBound(lines) To UBound(lines)
        result(count) = ObfuscateLineRobust(lines(i), key)
        count = count + 1
        
        If NOISE_RATE > 0 And i Mod NOISE_RATE = 0 And i > LBound(lines) Then
            result(count) = TAG_NOISE: count = count + 1
            result(count) = "If False Then": count = count + 1
            result(count) = "    ofuDummy = 0": count = count + 1
            result(count) = "End If": count = count + 1
        End If
    Next

    ReDim Preserve result(count - 1)
    ObfuscateCodeFast = Join(result, vbCrLf)
End Function

' =============================================================================
' OFUSCACIÓN DE LÍNEA ROBUSTA (CORREGIDA)
' =============================================================================

Private Function ObfuscateLineRobust(ByVal ln As String, ByVal key As Long) As String
    Dim i As Long, ch As String
    Dim result As String, buffer As String
    Dim inString As Boolean, commentStart As Long
    
    ' 1. Buscar comentario primero (fuera de strings)
    inString = False
    commentStart = 0
    
    For i = 1 To Len(ln)
        ch = Mid$(ln, i, 1)
        If ch = """" Then
            inString = Not inString
        ElseIf ch = "'" And Not inString Then
            commentStart = i
            Exit For
        End If
    Next
    
    ' 2. Separar código y comentario
    Dim codePart As String, commentPart As String
    
    If commentStart > 0 Then
        codePart = Left$(ln, commentStart - 1)
        commentPart = Mid$(ln, commentStart + 1)
    Else
        codePart = ln
        commentPart = ""
    End If
    
    ' 3. Ofuscar strings en la parte de código
    result = ObfuscateStringsInCode(codePart, key)
    
    ' 4. Agregar comentario ofuscado si existe
    If Len(commentPart) > 0 Then
        result = result & TAG_COMMENT & ToHex4(commentPart, key)
    End If
    
    ObfuscateLineRobust = result
End Function

' Ofusca SOLO los strings literales en código
Private Function ObfuscateStringsInCode(ByVal code As String, ByVal key As Long) As String
    Dim result As String, i As Long
    Dim ch As String, inString As Boolean
    Dim currentString As String, beforeString As String
    
    result = ""
    inString = False
    currentString = ""
    beforeString = ""
    
    For i = 1 To Len(code)
        ch = Mid$(code, i, 1)
        
        If ch = """" Then
            If inString Then
                ' Fin del string - ofuscar y agregar
                result = result & beforeString
                If Len(currentString) > 0 Then
                    result = result & "dDecode(""" & ToHex4(currentString, key) & """," & key & ")"
                Else
                    result = result & """"""
                End If
                beforeString = ""
                currentString = ""
                inString = False
            Else
                ' Inicio del string
                result = result & beforeString
                beforeString = ""
                inString = True
            End If
        Else
            If inString Then
                currentString = currentString & ch
            Else
                beforeString = beforeString & ch
            End If
        End If
    Next
    
    ' Agregar lo que quedó
    result = result & beforeString
    
    ObfuscateStringsInCode = result
End Function

' =============================================================================
' DESOFUSCACIÓN RÁPIDA
' =============================================================================

Private Function DeobfuscateCodeFast(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String
    Dim count As Long, skipNext As Long
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines))
    
    count = 0
    skipNext = 0

    For i = LBound(lines) To UBound(lines)
        If skipNext > 0 Then
            skipNext = skipNext - 1
            GoTo NextLine
        End If
        
        Dim trimLine As String
        trimLine = Trim$(lines(i))
        
        If Left$(lines(i), Len(TAG_KEY)) = TAG_KEY Then GoTo NextLine
        If Left$(lines(i), Len(TAG_NOISE)) = TAG_NOISE Then
            skipNext = 2
            GoTo NextLine
        End If
        If trimLine = "If False Then" Or trimLine = "End If" Then GoTo NextLine
        If InStr(trimLine, "Dim ofuDummy") > 0 Then GoTo NextLine
        
        result(count) = RestoreLineRobust(lines(i), key)
        count = count + 1
        
NextLine:
    Next

    ReDim Preserve result(count - 1)
    DeobfuscateCodeFast = Join(result, vbCrLf)
End Function

' =============================================================================
' RESTAURACIÓN ROBUSTA
' =============================================================================

Private Function RestoreLineRobust(ByVal ln As String, ByVal key As Long) As String
    Dim p As Long, result As String
    
    result = ln
    
    ' 1. Restaurar comentario
    p = InStr(result, TAG_COMMENT)
    If p > 0 Then
        Dim hexStr As String
        hexStr = Mid$(result, p + Len(TAG_COMMENT))
        result = Left$(result, p - 1) & "'" & FromHex4Fast(hexStr, key)
        RestoreLineRobust = result
        Exit Function
    End If
    
    ' 2. Restaurar strings (loop seguro)
    Dim maxIterations As Long
    maxIterations = 0
    
    Do While InStr(result, "dDecode(""") > 0 And maxIterations < 100
        maxIterations = maxIterations + 1
        
        p = InStr(result, "dDecode(""")
        Dim p2 As Long, pEnd As Long
        
        p2 = InStr(p + 10, result, """")
        If p2 = 0 Then Exit Do
        
        pEnd = InStr(p2 + 1, result, ")")
        If pEnd = 0 Then Exit Do
        
        hexStr = Mid$(result, p + 9, p2 - p - 9)
        Dim decoded As String
        decoded = FromHex4Fast(hexStr, key)
        
        result = Left$(result, p - 1) & """" & decoded & """" & Mid$(result, pEnd + 1)
    Loop
    
    RestoreLineRobust = result
End Function

' =============================================================================
' CODIFICACIÓN / DECODIFICACIÓN HEX4
' =============================================================================

Private Function ToHex4(ByVal s As String, ByVal k As Long) As String
    Dim i As Long, charCode As Long
    Dim result As String
    Dim hexChunk As String
    
    result = Space$(Len(s) * 4)
    
    For i = 1 To Len(s)
        charCode = AscW(Mid$(s, i, 1)) Xor k
        hexChunk = Right$("0000" & Hex$(charCode), 4)
        Mid$(result, (i - 1) * 4 + 1, 4) = hexChunk
    Next
    
    ToHex4 = result
End Function

Private Function FromHex4Fast(ByVal hex4 As String, ByVal k As Long) As String
    Dim i As Long, v As Long
    Dim length As Long
    Dim result As String
    
    length = Len(hex4)
    If length Mod 4 <> 0 Then
        FromHex4Fast = ""
        Exit Function
    End If
    
    result = Space$(length \ 4)
    
    On Error Resume Next
    For i = 1 To length Step 4
        v = CLng("&H" & Mid$(hex4, i, 4))
        If Err.Number = 0 Then
            Mid$(result, (i \ 4) + 1, 1) = ChrW$(v Xor k)
        End If
    Next
    On Error GoTo 0
    
    FromHex4Fast = result
End Function

' =============================================================================
' UTILIDADES
' =============================================================================

Private Function MakeKey() As Long
    Randomize
    MakeKey = CLng(Rnd * 65534) + 1
End Function

Private Function ExtractKey(ByVal src As String) As Long
    Dim p As Long, e As Long, s As String
    
    p = InStr(src, TAG_KEY)
    If p = 0 Then Exit Function
    
    e = InStr(p, src, vbCrLf)
    If e = 0 Then e = Len(src) + 1
    
    s = Trim$(Mid$(src, p + Len(TAG_KEY), e - p - Len(TAG_KEY)))
    
    If IsNumeric(s) Then ExtractKey = CLng(s)
End Function
