# ==========================================================
# OPCI√ìN 1 ‚Äî B√∫squeda de literales en Blueprints (Excel COM)
# ==========================================================
$ErrorActionPreference = "Stop"

# ---------- Entrada ----------
Write-Host "üîç B√∫squeda de literales dentro de ficheros Blueprint (Excel COM)" -ForegroundColor Cyan
$basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`n‚úèÔ∏è Introduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++) {
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "‚ùå Sin literales. Saliendo."; exit }
$stopAtFirst = (Read-Host "¬øParar al encontrar la primera coincidencia? (S/N)") -match '^[sS]$'

function Normalize([string]$s) {
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d=$s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray() | Where-Object { [Globalization.CharUnicodeInfo]::GetUnicodeCategory($_) -ne [Globalization.UnicodeCategory]::NonSpacingMark }) -join '' | ForEach-Object {$_}|Out-String|%{$_.Trim().ToLower()}
}

# ---------- B√∫squeda de Blueprints ----------
$reDoc='(?i)(documentaci[o√≥]n\s+implantaci[o√≥]n)'
$reAna='(?i)(an[a√°]lisis)'
Write-Host "`nüìÅ Recorriendo estructura..." -ForegroundColor DarkCyan
$blueprints=@()

Get-ChildItem -Path $basePath -Directory |
 Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
 Sort-Object LastWriteTime -Descending |
 ForEach-Object {
    $dir1=$_
    Write-Host "‚Üí Revisando carpeta principal: $($dir1.Name)" -ForegroundColor Yellow
    Get-ChildItem -Path $dir1.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $dir2=$_
        $docDirs=Get-ChildItem -Path $dir2.FullName -Directory -ErrorAction SilentlyContinue|Where-Object{$_.Name -match $reDoc}
        foreach($doc in $docDirs){
            $anaDirs=Get-ChildItem -Path $doc.FullName -Directory -ErrorAction SilentlyContinue|Where-Object{$_.Name -match $reAna}
            foreach($ana in $anaDirs){
                Write-Host "   üìÇ Revisando subcarpeta: $($ana.FullName)" -ForegroundColor Cyan
                $found=Get-ChildItem -Path $ana.FullName -File -ErrorAction SilentlyContinue|Where-Object{$_.Name -match '(?i)Blueprint.*\.(xlsx|xlsm)$' -and $_.Name -notlike '~$*'}
                foreach($f in $found){
                    Write-Host "      ‚úÖ Encontrado Blueprint: $($f.Name)" -ForegroundColor Green
                    $blueprints+=$f.FullName
                }
            }
        }
    }
 }
if ($blueprints.Count -eq 0) { Write-Host "‚ö†Ô∏è No se encontraron Blueprints."; exit }

# ---------- An√°lisis de Blueprints ----------
$excel=$null
$results=@()
try {
    $excel=New-Object -ComObject Excel.Application
    $excel.Visible=$false
    $excel.DisplayAlerts=$false

    foreach($path in $blueprints){
        try {
            Write-Host "      ‚è≥ Abriendo (solo lectura): $path" -ForegroundColor DarkGray
            Write-Host "      üß© Intentando abrir Excel..." -ForegroundColor DarkCyan
            $wb=$excel.Workbooks.Open($path,0,$true)
            Write-Host "      ‚úÖ Excel abierto correctamente." -ForegroundColor Green

            $sheet=$null
            foreach($sh in $wb.Worksheets){
                $n=Normalize $sh.Name
                if($n -match 'analisis' -and $n -match 'concept'){$sheet=$sh;break}
            }
            if(-not $sheet){
                Write-Host "‚ö†Ô∏è No hay hoja 'An√°lisis conceptos' en $(Split-Path $path -Leaf)" -ForegroundColor Yellow
                $wb.Close($false)|Out-Null; continue
            }

            Write-Host "üîç Analizando hoja: $($sheet.Name)" -ForegroundColor Gray
            $used=$sheet.UsedRange; $rows=$used.Rows.Count; $cols=$used.Columns.Count
            for($r=1;$r-le$rows;$r++){
                for($c=1;$c-le$cols;$c++){
                    $txt=""; try{$txt=[string]$used.Cells.Item($r,$c).Text}catch{continue}
                    if([string]::IsNullOrWhiteSpace($txt)){continue}
                    $v=Normalize $txt
                    foreach($lit in $literals){
                        if($v -like ("*"+(Normalize $lit)+"*")){
                            Write-Host "‚úÖ '$lit' en $(Split-Path $path -Leaf) ‚Üí R$r,C$c ('$txt')" -ForegroundColor Green
                            $results += [PSCustomObject]@{
                                Fichero = Split-Path $path -Leaf
                                Hoja    = $sheet.Name
                                Literal = $lit
                                Celda   = "R$rC$c"
                                Valor   = $txt
                            }
                            if($stopAtFirst){throw "STOP_GLOBAL"}
                        }
                    }
                }
            }
            $wb.Close($false)|Out-Null
        } catch {
            if($_.Exception.Message -eq "STOP_GLOBAL"){throw}
            Write-Host "‚ö†Ô∏è Error con $(Split-Path $path -Leaf): $($_.Exception.Message)" -ForegroundColor Yellow
        }
    }
} finally {
    if($excel){$excel.Quit();[System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel)|Out-Null}
    Get-Process excel -ErrorAction SilentlyContinue|%{try{$_.Kill()}catch{}}
}

# ---------- Exportar resultados ----------
if($results.Count -gt 0){
    $outFile=Join-Path $env:TEMP "Resultados_Blueprint.xlsx"
    $excelOut=New-Object -ComObject Excel.Application
    $wbOut=$excelOut.Workbooks.Add()
    $ws=$wbOut.Worksheets.Item(1)
    $ws.Cells.Item(1,1)="Fichero"
    $ws.Cells.Item(1,2)="Hoja"
    $ws.Cells.Item(1,3)="Literal"
    $ws.Cells.Item(1,4)="Celda"
    $ws.Cells.Item(1,5)="Valor"
    $row=2
    foreach($r in $results){
        $ws.Cells.Item($row,1)=$r.Fichero
        $ws.Cells.Item($row,2)=$r.Hoja
        $ws.Cells.Item($row,3)=$r.Literal
        $ws.Cells.Item($row,4)=$r.Celda
        $ws.Cells.Item($row,5)=$r.Valor
        $row++
    }
    $ws.Range("A1:E1").Font.Bold=$true
    $ws.Columns.AutoFit()|Out-Null
    $wbOut.SaveAs($outFile)
    $wbOut.Close($false)
    $excelOut.Quit()
    [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excelOut)|Out-Null
    Write-Host "`n‚úÖ Resultados guardados en: $outFile" -ForegroundColor Green
}else{
    Write-Host "‚ö†Ô∏è No se encontraron coincidencias." -ForegroundColor Yellow
}
Write-Host "`n‚úîÔ∏è Proceso completado (Excel COM)." -ForegroundColor Green
















# ==========================================================
# üîç OPCI√ìN 2 ‚Äî B√∫squeda de literales en Blueprints (Open XML)
# ==========================================================
Add-Type -AssemblyName System.IO.Compression.FileSystem
$ErrorActionPreference = "Stop"

Write-Host "üîç B√∫squeda de literales dentro de ficheros Blueprint (Open XML)" -ForegroundColor Cyan
$basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`n‚úèÔ∏è Introduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals=@()
for($i=1;$i-le10;$i++){
    $lit=Read-Host("Literal #{0}" -f $i)
    if([string]::IsNullOrWhiteSpace($lit)){break}
    $literals+=$lit
}
if($literals.Count-eq0){Write-Host"‚ùå Sin literales.";exit}
$stopAtFirst=(Read-Host"¬øParar al encontrar la primera coincidencia?(S/N)")-match'^[sS]$'

function Normalize([string]$s){
    if([string]::IsNullOrWhiteSpace($s)){return""}
    $d=$s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray()|Where-Object{[Globalization.CharUnicodeInfo]::GetUnicodeCategory($_)-ne[Globalization.UnicodeCategory]::NonSpacingMark})-join''|ForEach-Object{$_}|Out-String|%{$_.Trim().ToLower()}
}

$reDoc='(?i)(documentaci[o√≥]n\s+implantaci[o√≥]n)'
$reAna='(?i)(an[a√°]lisis)'
Write-Host"`nüìÅ Recorriendo estructura..."-ForegroundColorDarkCyan
$blueprints=@()

Get-ChildItem-Path$basePath-Directory|
Where-Object{$_.Name.Length-ge4 -and $_.Name[3]-eq'_'}|
Sort-ObjectLastWriteTime-Descending|
ForEach-Object{
    $dir1=$_
    Write-Host"‚Üí Revisando carpeta principal:$($dir1.Name)"-ForegroundColorYellow
    Get-ChildItem-Path$dir1.FullName-Directory-ErrorActionSilentlyContinue|ForEach-Object{
        $dir2=$_
        $docDirs=Get-ChildItem-Path$dir2.FullName-Directory-ErrorActionSilentlyContinue|Where-Object{$_.Name -match $reDoc}
        foreach($doc in $docDirs){
            $anaDirs=Get-ChildItem-Path$doc.FullName-Directory-ErrorActionSilentlyContinue|Where-Object{$_.Name -match $reAna}
            foreach($ana in $anaDirs){
                $found=Get-ChildItem-Path$ana.FullName-File-ErrorActionSilentlyContinue|Where-Object{$_.Name -match'(?i)Blueprint.*\.xlsx$'-and$_.Name -notlike'~$*'}
                foreach($f in $found){
                    Write-Host"      ‚úÖ Encontrado Blueprint:$($f.Name)"-ForegroundColorGreen
                    $blueprints+=$f.FullName
                }
            }
        }
    }
}
if($blueprints.Count-eq0){Write-Host"‚ö†Ô∏è No se encontraron Blueprints.";exit}

# ---------- Procesamiento sin Excel ----------
$results=@()
foreach($path in $blueprints){
    try{
        Write-Host"      ‚è≥ Analizando(OpenXML):$path"-ForegroundColorDarkGray
        $tmp=[System.IO.Path]::Combine([System.IO.Path]::GetTempPath(),[System.IO.Path]::GetRandomFileName())
        [System.IO.Compression.ZipFile]::ExtractToDirectory($path,$tmp)
        $sheetFiles=Get-ChildItem(Join-Path$tmp"xl\worksheets")-Filter"*.xml"
        foreach($sheet in $sheetFiles){
            $xml=Get-Content$sheet.FullName-Raw
            $norm=(Normalize$xml)
            foreach($lit in $literals){
                if($norm -like("*"+(Normalize$lit)+"*")){
                    Write-Host"‚úÖ '$lit' encontrado en hoja $($sheet.BaseName) de $(Split-Path $path -Leaf)"-ForegroundColorGreen
                    $results+=[PSCustomObject]@{
                        Fichero=Split-Path$path -Leaf
                        Hoja=$sheet.BaseName
                        Literal=$lit
                        Celda=""
                        Valor=""
                    }
                    if($stopAtFirst){throw"STOP_GLOBAL"}
                }
            }
        }
        Remove-Item-Path$tmp-Recurse-Force-ErrorActionSilentlyContinue
    }catch{
        if($_.Exception.Message -eq"STOP_GLOBAL"){throw}
        Write-Host"‚ö†Ô∏è Error con $path:$($_.Exception.Message)"-ForegroundColorYellow
    }
}

# ---------- Exportaci√≥n ----------
if($results.Count-gt0){
    $outFile=Join-Path$env:TEMP"Resultados_Blueprint_OpenXML.xlsx"
    $excelOut=New-Object-ComObjectExcel.Application
    $wbOut=$excelOut.Workbooks.Add()
    $ws=$wbOut.Worksheets.Item(1)
    $ws.Cells.Item(1,1)="Fichero";$ws.Cells.Item(1,2)="Hoja";$ws.Cells.Item(1,3)="Literal";$ws.Cells.Item(1,4)="Celda";$ws.Cells.Item(1,5)="Valor"
    $row=2
    foreach($r in $results){
        $ws.Cells.Item($row,1)=$r.Fichero
        $ws.Cells.Item($row,2)=$r.Hoja
        $ws.Cells.Item($row,3)=$r.Literal
        $ws.Cells.Item($row,4)=$r.Celda
        $ws.Cells.Item($row,5)=$r.Valor
        $row++
    }
    $ws.Range("A1:E1").Font.Bold=$true
    $ws.Columns.AutoFit()|Out-Null
    $wbOut.SaveAs($outFile)
    $wbOut.Close($false)
    $excelOut.Quit()
    [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excelOut)|Out-Null
    Write-Host"`n‚úÖ Resultados guardados en:$outFile"-ForegroundColorGreen
}else{
    Write-Host"‚ö†Ô∏è No se encontraron coincidencias."-ForegroundColorYellow
}
Write-Host"`n‚úîÔ∏è Proceso completado(OpenXML)."-ForegroundColorGreen