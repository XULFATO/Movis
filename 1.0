# ==========================================================
# Buscar-Blueprints.ps1  (versi√≥n definitiva: lectura en memoria)
# ==========================================================
# - Recorre la estructura de carpetas seg√∫n tus reglas (_ en 4¬™ pos., etc.)
# - Busca hoja tipo "Analisis conceptos" en ficheros Blueprint .xlsx/.xlsm
# - Lee el contenido directamente en memoria (sin copiar ni abrir Excel)
# - Busca los literales indicados y exporta resultados al escritorio
# ==========================================================

$ErrorActionPreference = 'Stop'

# --- utilidades de texto ---
function Remove-Diacritics([string]$s){
    if ([string]::IsNullOrEmpty($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    $sb = New-Object System.Text.StringBuilder
    foreach ($ch in $d.ToCharArray()){
        if ([Globalization.CharUnicodeInfo]::GetUnicodeCategory($ch) -ne [Globalization.UnicodeCategory]::NonSpacingMark){
            [void]$sb.Append($ch)
        }
    }
    $sb.ToString()
}
function Normalize([string]$s){ (Remove-Diacritics $s).ToLowerInvariant() }

# --- shared strings ---
function Get-SharedTextFromSiNode {
    param($siNode)
    $ns = New-Object System.Xml.XmlNamespaceManager($siNode.OwnerDocument.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $tNodes = $siNode.SelectNodes('.//d:t',$ns)
    if ($tNodes -and $tNodes.Count -gt 0){
        ($tNodes | ForEach-Object { $_.'#text' }) -join ''
    } else {
        [string]$siNode.InnerText
    }
}
function Read-SharedStrings {
    param($zip)
    $entry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/sharedStrings.xml" }
    if (-not $entry){ return @() }
    $sr = New-Object IO.StreamReader($entry.Open())
    $xml = [xml]$sr.ReadToEnd()
    $sr.Dispose()
    $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $sis = $xml.SelectNodes('//d:si',$ns)
    $list = New-Object System.Collections.Generic.List[string]
    foreach($n in $sis){ $list.Add( (Get-SharedTextFromSiNode $n) ) }
    return ,$list
}

# --- localizar hoja "analisis conceptos" ---
function Get-SheetEntryPath {
    param($zip)
    $wbEntry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/workbook.xml" }
    if (-not $wbEntry){ return $null }
    $sr = New-Object IO.StreamReader($wbEntry.Open())
    $wbXml = [xml]$sr.ReadToEnd(); $sr.Dispose()

    $ns = New-Object System.Xml.XmlNamespaceManager($wbXml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $ns.AddNamespace('r','http://schemas.openxmlformats.org/officeDocument/2006/relationships')

    $targetSheetId = $null
    $targetSheetName = $null
    foreach($s in $wbXml.SelectNodes('//d:sheets/d:sheet',$ns)){
        $name = [string]$s.name
        $n = Normalize $name
        if ($n -match 'analisis' -and $n -match 'concept'){
            $targetSheetId = $s.'r:id'
            $targetSheetName = $name
            break
        }
    }
    if (-not $targetSheetId){ return $null }

    $relsEntry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/_rels/workbook.xml.rels" }
    if (-not $relsEntry){ return $null }
    $sr2 = New-Object IO.StreamReader($relsEntry.Open())
    $relsXml = [xml]$sr2.ReadToEnd(); $sr2.Dispose()

    $relNode = $relsXml.SelectSingleNode("//Relationship[@Id='$targetSheetId']")
    if (-not $relNode){ return $null }
    $target = [string]$relNode.Target
    if (-not $target.StartsWith("worksheets/")){ $target = "worksheets/$target" }
    return @{ Path = "xl/$target"; SheetName = $targetSheetName }
}

# --- leer celdas ---
function Read-SheetCells {
    param($zip, $sheetPath, $shared)
    $entry = $zip.Entries | Where-Object { $_.FullName -ieq $sheetPath }
    if (-not $entry){ return @() }
    $sr = New-Object IO.StreamReader($entry.Open())
    $xml = [xml]$sr.ReadToEnd(); $sr.Dispose()
    $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $cells = $xml.SelectNodes('//d:worksheet/d:sheetData/d:row/d:c',$ns)
    $out = New-Object System.Collections.Generic.List[object]
    foreach($c in $cells){
        $addr = [string]$c.r
        $t    = [string]$c.t
        $valNode = $c.SelectSingleNode('d:v',$ns)
        $text = $null
        if ($t -eq 's'){
            if ($valNode){
                $idx = [int]$valNode.InnerText
                if ($idx -lt $shared.Count){ $text = [string]$shared[$idx] }
            }
        } elseif ($t -eq 'inlineStr') {
            $tNodes = $c.SelectNodes('.//d:t',$ns)
            if ($tNodes){ $text = ($tNodes | ForEach-Object { $_.'#text' }) -join '' }
        } else {
            if ($valNode){ $text = [string]$valNode.InnerText }
        }
        if ($text -ne $null -and $text -ne ''){
            $out.Add([PSCustomObject]@{ Address = $addr; Text = $text })
        }
    }
    return ,$out
}

function Ask-YesNo($prompt) {
    while ($true) {
        $r = Read-Host "$prompt (S/N)"
        if ($r -match '^[sS]$') { return $true }
        if ($r -match '^[nN]$') { return $false }
    }
}

Write-Host "üîç B√∫squeda de literales en hoja 'An√°lisis Conceptos' (lectura en memoria)" -ForegroundColor Cyan

# --- entrada ---
$basePath = Read-Host "üìÇ Introduce la ruta base (por ejemplo O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)){ Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`nIntroduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++){
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0){ Write-Host "‚ùå Sin literales."; exit }
$stopAtFirst = Ask-YesNo "¬øParar al encontrar la primera coincidencia?"

# --- recorrido de carpetas ---
$regexDocImpl = '(?i)(^\s*\d{0,3}\s*[-_. ]*\s*documentaci[o√≥]n\s+implantaci[o√≥]n\b)|(\bdocumentaci[o√≥]n\s+implantaci[o√≥]n\b)'
$regexAnalisis = '(?i)(^\s*\d{0,3}\s*[-_. ]*\s*an[a√°]lisis\b)|(\ban[a√°]lisis\b)'

Write-Host "`nüìÅ Recorriendo estructura (con '_' en 4¬™ posici√≥n, Doc. Implantaci√≥n/An√°lisis, orden desc.)..." -ForegroundColor DarkCyan
$files = @()

Get-ChildItem -Path $basePath -Directory |
  Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
  Sort-Object LastWriteTime -Descending |
  ForEach-Object {
    $nivel1 = $_.FullName
    Write-Host ("‚Üí Revisando carpeta principal: {0}" -f $_.Name) -ForegroundColor Yellow
    Get-ChildItem -Path $nivel1 -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $nivel2 = $_.FullName
        $docImplDirs = Get-ChildItem -Path $nivel2 -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $regexDocImpl }
        foreach ($docDir in $docImplDirs) {
            $analisisDirs = Get-ChildItem -Path $docDir.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $regexAnalisis }
            foreach ($anaDir in $analisisDirs) {
                Write-Host ("   üìÇ Revisando subcarpeta: {0}" -f $anaDir.FullName) -ForegroundColor Cyan
                $found = Get-ChildItem -Path $anaDir.FullName -File -ErrorAction SilentlyContinue |
                         Where-Object { $_.Name -notlike '~$*' -and $_.Name -match '(?i)Blueprint.*\.(xlsx|xlsm|xls)$' }
                if ($found) {
                    foreach ($f in $found) {
                        Write-Host ("      ‚úÖ Encontrado Blueprint: {0}" -f $f.Name) -ForegroundColor Green
                    }
                    $files += $found
                }
            }
        }
    }
}

if ($files.Count -eq 0){ Write-Host "‚ö†Ô∏è No se encontraron ficheros 'Blueprint'."; exit 0 }
Write-Host ("   ‚Üí {0} ficheros 'Blueprint' detectados." -f $files.Count) -ForegroundColor Green

# --- lectura y b√∫squeda en memoria ---
$results = New-Object System.Collections.Generic.List[object]

foreach ($file in $files){
    if ($file.Extension -notmatch '^\.(xlsx|xlsm)$') {
        Write-Host ("      ‚ö†Ô∏è {0} es .xls (binario). Se omite." -f $file.Name) -ForegroundColor DarkYellow
        continue
    }

    try {
        Write-Host ("      ‚è≥ Leyendo en memoria: {0}" -f $file.FullName) -ForegroundColor DarkGray
        $bytes = [System.IO.File]::ReadAllBytes($file.FullName)
        $ms = New-Object System.IO.MemoryStream(,$bytes)
        $zip = New-Object System.IO.Compression.ZipArchive($ms, [System.IO.Compression.ZipArchiveMode]::Read, $false)

        $sheetInfo = Get-SheetEntryPath -zip $zip
        if (-not $sheetInfo){
            Write-Host ("      ‚ö†Ô∏è No se localiz√≥ hoja tipo 'An√°lisis Conceptos' en {0}" -f $file.Name) -ForegroundColor DarkYellow
            $zip.Dispose(); $ms.Dispose(); continue
        }

        $shared = Read-SharedStrings -zip $zip
        $cells  = Read-SheetCells -zip $zip -sheetPath $sheetInfo.Path -shared $shared

        $zip.Dispose(); $ms.Dispose()

        if ($cells.Count -eq 0){
            Write-Host ("      ‚ö™ Hoja '{0}' sin celdas legibles" -f $sheetInfo.SheetName) -ForegroundColor Gray
            continue
        }

        foreach($lit in $literals){
            $llow = Normalize $lit
            foreach($cell in $cells){
                $vnorm = Normalize $cell.Text
                if ($vnorm -like "*$llow*"){
                    $results.Add([PSCustomObject]@{
                        Fichero = $file.FullName
                        Hoja    = $sheetInfo.SheetName
                        Literal = $lit
                        Celda   = $cell.Address
                        Valor   = $cell.Text
                    })
                    Write-Host ("‚úÖ '{0}' en {1} ‚Üí {2} (valor: {3})" -f $lit, $file.Name, $cell.Address, $cell.Text) -ForegroundColor Green
                    if ($stopAtFirst){ throw "STOP_GLOBAL" }
                }
            }
        }

    } catch {
        if ($_.Exception.Message -eq "STOP_GLOBAL"){ throw }
        Write-Host ("‚ö†Ô∏è Error leyendo {0}: {1}" -f $file.FullName, $_.Exception.Message) -ForegroundColor DarkYellow
        continue
    }
}

# --- exportar resultados ---
$outPath = Join-Path $env:USERPROFILE "Desktop\Resultados_Blueprint.xlsx"
$csvPath = Join-Path $env:TEMP "Resultados_Blueprint.csv"

if ($results.Count -gt 0){
    $results | Export-Csv -NoTypeInformation -Encoding UTF8 $csvPath
    try {
        $excel = New-Object -ComObject Excel.Application
        $excel.Visible = $false; $excel.DisplayAlerts = $false
        $wb = $excel.Workbooks.Open($csvPath)
        $wb.SaveAs($outPath, 51)
        $wb.Close($false)
        $excel.Quit()
        [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
        Remove-Item $csvPath -ErrorAction SilentlyContinue
        Write-Host "`n‚úÖ Terminado. Resultados guardados en: $outPath" -ForegroundColor Green
    } catch {
        Write-Host "`n‚úÖ Terminado. Dejo CSV en: $csvPath" -ForegroundColor Green
    }
} else {
    Write-Host "`n‚ö™ No se encontraron coincidencias." -ForegroundColor Gray
}