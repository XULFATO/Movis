'==========================================================================================
' modVBACodeObfuscator
'
' REQUIERE (VBE -> Tools -> References):
'  - Microsoft Visual Basic for Applications Extensibility 5.3
'  - Microsoft VBScript Regular Expressions 5.5
'
' REQUIERE (Excel):
'  - Archivo -> Opciones -> Centro de confianza -> Configuración -> Configuración de macros ->
'    marcar: "Confiar en el acceso al modelo de objetos de proyectos de VBA"
'
' OBJETIVO:
'  - Pide fichero ORIGEN y DESTINO por pantalla
'  - Crea DESTINO como .XLSM (copia del origen)
'  - Ofusca SOLO identificadores internos (Dim/Private + argumentos + Private Subs/Functions)
'  - NO cambia nombres de Public Sub / Public Function (para no romper botones/asignaciones)
'
' NOTAS IMPORTANTES:
'  - No usa formularios ni ActiveX.
'  - No usa VBComponents.Remove/Add (toca el código "in place": borra y reescribe líneas).
'==========================================================================================

Option Explicit

'-----------------------------
' Configuración de ofuscación
'-----------------------------
Private Const OBSFUCATED_PREFIX As String = "Obsf_"
Private Const OBSFUCATED_LEN As Long = 40

'-----------------------------
' Mapa de reemplazos
'-----------------------------
Private Type TMapItem
    k As String
    v As String
End Type

Private mMap() As TMapItem
Private mMapCount As Long

'==========================================================================================
' ENTRADA PRINCIPAL
'==========================================================================================
Public Sub ObfuscateWorkbook_Interactive()
    Dim srcPath As Variant, dstPath As Variant
    Dim srcWb As Workbook, dstWb As Workbook

    If Not HasVBAProjectAccess() Then
        MsgBox "No hay acceso al modelo VBProject." & vbCrLf & vbCrLf & _
               "Activa: Centro de confianza -> 'Confiar en el acceso al modelo de objetos de proyectos de VBA'", _
               vbCritical, "VBA Obfuscator"
        Exit Sub
    End If

    srcPath = Application.GetOpenFilename( _
                FileFilter:="Excel macro-enabled (*.xlsm;*.xlam;*.xlsb;*.xls;*.xlsx),*.xlsm;*.xlam;*.xlsb;*.xls;*.xlsx", _
                Title:="Selecciona el EXCEL ORIGEN")
    If srcPath = False Then Exit Sub

    dstPath = Application.GetSaveAsFilename( _
                InitialFileName:=BuildDefaultDestPath(CStr(srcPath)), _
                FileFilter:="Excel Macro-Enabled Workbook (*.xlsm), *.xlsm", _
                Title:="Guardar DESTINO (XLSM)")
    If dstPath = False Then Exit Sub
    If LCase$(Right$(CStr(dstPath), 5)) <> ".xlsm" Then dstPath = CStr(dstPath) & ".xlsm"

    Application.ScreenUpdating = False
    Application.DisplayAlerts = False

    Set srcWb = Workbooks.Open(Filename:=CStr(srcPath), ReadOnly:=True)

    ' Crear destino como copia (mantiene macros)
    srcWb.SaveCopyAs CStr(dstPath)

    ' Abrir destino en modo editable
    Set dstWb = Workbooks.Open(Filename:=CStr(dstPath), ReadOnly:=False)

    ' Construir mapa (FASE 1)
    MapInit
    CollectIdentifiers dstWb

    ' Aplicar reemplazos (FASE 2)
    ApplyObfuscation dstWb

    dstWb.Save
    dstWb.Close SaveChanges:=True
    srcWb.Close SaveChanges:=False

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox "OK. Ofuscación terminada:" & vbCrLf & CStr(dstPath), vbInformation, "VBA Obfuscator"
End Sub

'==========================================================================================
' FASE 1: RECOGER IDENTIFICADORES
'==========================================================================================
Private Sub CollectIdentifiers(ByVal wb As Workbook)
    Dim vbProj As VBIDE.VBProject
    Dim comp As VBIDE.VBComponent
    Dim cm As VBIDE.CodeModule
    Dim codeText As String

    Set vbProj = wb.VBProject

    For Each comp In vbProj.VBComponents
        Set cm = comp.CodeModule
        If cm.CountOfLines <= 0 Then GoTo NextComp

        codeText = cm.Lines(1, cm.CountOfLines)

        ' 1) Variables (Dim/Private/Public)
        CollectVariablesFromText codeText

        ' 2) Procedimientos (Private Sub/Function) -> se pueden ofuscar (pero protegemos eventos)
        CollectPrivateProceduresFromText codeText, comp.Type

        ' 3) Argumentos de Sub/Function (Private/Public) -> ofuscamos argumentos si NO son eventos protegidos
        CollectArgumentsFromText codeText, comp.Type

NextComp:
    Next comp
End Sub

Private Sub CollectVariablesFromText(ByVal codeText As String)
    Dim lines() As String, i As Long, s As String
    Dim decl As String, declType As String

    lines = Split(codeText, vbCrLf)

    For i = LBound(lines) To UBound(lines)
        s = Trim$(lines(i))

        If s = "" Then GoTo NextLine
        If Left$(s, 1) = "'" Then GoTo NextLine
        If LCase$(Left$(s, 10)) = "attribute " Then GoTo NextLine
        If IsProcHeaderLine(s) Then GoTo NextLine
        If InStr(1, s, "Enum", vbTextCompare) = 1 Then GoTo NextLine
        If InStr(1, s, "Type", vbTextCompare) = 1 Then GoTo NextLine
        If InStr(1, s, "Const", vbTextCompare) = 1 Then GoTo NextLine

        If StartsWithWord(s, "Dim") Or StartsWithWord(s, "Private") Or StartsWithWord(s, "Public") Then
            declType = FirstWord(s) ' Dim/Private/Public
            decl = Trim$(Mid$(s, Len(declType) + 1))

            ' Dim a As Long, b As String
            CollectNamesFromDeclarationList decl, True  ' True = variables
        End If

NextLine:
    Next i
End Sub

Private Sub CollectPrivateProceduresFromText(ByVal codeText As String, ByVal compType As VBIDE.vbext_ComponentType)
    Dim re As RegExp, m As MatchCollection, x As Match
    Dim procName As String

    Set re = New RegExp
    re.Global = True
    re.IgnoreCase = False
    re.Pattern = "^\s*Private\s+(Sub|Function)\s+([A-Za-z_][A-Za-z0-9_]*)\b"
    Set m = re.Execute(codeText)

    For Each x In m
        procName = CStr(x.SubMatches(1))
        If Not IsProtectedProcName(procName, compType) Then
            MapAdd procName, MakeObfuscated(procName)
        End If
    Next x
End Sub

Private Sub CollectArgumentsFromText(ByVal codeText As String, ByVal compType As VBIDE.vbext_ComponentType)
    Dim re As RegExp, m As MatchCollection, x As Match
    Dim header As String, procName As String, argsBlock As String

    Set re = New RegExp
    re.Global = True
    re.IgnoreCase = False
    ' Captura: [Public|Private] Sub/Function ProcName( ... )
    re.Pattern = "^\s*(Public|Private)?\s*(Sub|Function)\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^)]*)\)"
    Set m = re.Execute(codeText)

    For Each x In m
        header = CStr(x.Value)
        procName = CStr(x.SubMatches(2))
        argsBlock = CStr(x.SubMatches(3))

        If InStr(1, header, "IRibbon", vbTextCompare) > 0 Then GoTo NextHeader
        If IsProtectedProcName(procName, compType) Then GoTo NextHeader

        CollectNamesFromArgumentList argsBlock

NextHeader:
    Next x
End Sub

'==========================================================================================
' FASE 2: APLICAR OFUSCACIÓN
'==========================================================================================
Private Sub ApplyObfuscation(ByVal wb As Workbook)
    Dim vbProj As VBIDE.VBProject
    Dim comp As VBIDE.VBComponent
    Dim cm As VBIDE.CodeModule
    Dim originalText As String, newText As String

    Set vbProj = wb.VBProject

    For Each comp In vbProj.VBComponents
        Set cm = comp.CodeModule
        If cm.CountOfLines <= 0 Then GoTo NextComp

        originalText = cm.Lines(1, cm.CountOfLines)
        newText = ReplaceWithMap(originalText, comp.Type)

        If newText <> originalText Then
            cm.DeleteLines 1, cm.CountOfLines
            cm.InsertLines 1, newText
        End If

NextComp:
    Next comp
End Sub

'==========================================================================================
' REEMPLAZO (respeta strings, ignora comentarios de línea completa)
'==========================================================================================
Private Function ReplaceWithMap(ByVal codeText As String, ByVal compType As VBIDE.vbext_ComponentType) As String
    Dim lines() As String, i As Long, s As String
    Dim outLines() As String

    lines = Split(codeText, vbCrLf)
    ReDim outLines(LBound(lines) To UBound(lines))

    For i = LBound(lines) To UBound(lines)
        s = lines(i)

        If Trim$(s) = "" Then
            outLines(i) = s
        ElseIf Left$(Trim$(s), 1) = "'" Then
            outLines(i) = s
        ElseIf LCase$(Left$(Trim$(s), 10)) = "attribute " Then
            outLines(i) = s
        Else
            outLines(i) = ReplaceOutsideQuotes(s, compType)
        End If
    Next i

    ReplaceWithMap = Join(outLines, vbCrLf)
End Function

Private Function ReplaceOutsideQuotes(ByVal lineText As String, ByVal compType As VBIDE.vbext_ComponentType) As String
    Dim parts() As String, i As Long
    Dim result As String

    ' Divide por comillas: pares (0,2,4...) fuera; impares dentro de string
    parts = Split(lineText, """")

    For i = LBound(parts) To UBound(parts)
        If (i Mod 2) = 0 Then
            parts(i) = ReplaceTokens(parts(i), compType)
        End If
    Next i

    result = Join(parts, """")
    ReplaceOutsideQuotes = result
End Function

Private Function ReplaceTokens(ByVal textPart As String, ByVal compType As VBIDE.vbext_ComponentType) As String
    Dim i As Long
    Dim re As RegExp

    ' Aplica reemplazos por word boundary
    ' (no tocamos Public Subs/Functions porque NO están en el mapa si son Public)
    For i = 0 To mMapCount - 1
        If mMap(i).k <> "" Then
            Set re = New RegExp
            re.Global = True
            re.IgnoreCase = False
            re.Pattern = "\b" & RegexEscape(mMap(i).k) & "\b"
            textPart = re.Replace(textPart, mMap(i).v)
        End If
    Next i

    ReplaceTokens = textPart
End Function

'==========================================================================================
' MAPA
'==========================================================================================
Private Sub MapInit()
    ReDim mMap(0 To 0)
    mMapCount = 0
End Sub

Private Sub MapAdd(ByVal originalName As String, ByVal obfuscatedName As String)
    originalName = Trim$(originalName)
    If originalName = "" Then Exit Sub
    If Not IsValidIdentifier(originalName) Then Exit Sub
    If IsReservedWord(originalName) Then Exit Sub

    ' ya existe?
    If MapGet(originalName) <> "" Then Exit Sub

    ReDim Preserve mMap(0 To mMapCount)
    mMap(mMapCount).k = originalName
    mMap(mMapCount).v = obfuscatedName
    mMapCount = mMapCount + 1
End Sub

Private Function MapGet(ByVal originalName As String) As String
    Dim i As Long
    For i = 0 To mMapCount - 1
        If StrComp(mMap(i).k, originalName, vbBinaryCompare) = 0 Then
            MapGet = mMap(i).v
            Exit Function
        End If
    Next i
    MapGet = ""
End Function

Private Function MakeObfuscated(ByVal seed As String) As String
    Dim s As String, i As Long, n As Long, c As Long

    Randomize
    s = OBSFUCATED_PREFIX

    For i = 1 To OBSFUCATED_LEN
        n = Int((35 * Rnd) + 1)
        If n <= 9 Then
            c = n + 48
        Else
            c = n + 55
        End If
        s = s & Chr$(c)
    Next i

    MakeObfuscated = s
End Function

'==========================================================================================
' PARSERS
'==========================================================================================
Private Sub CollectNamesFromDeclarationList(ByVal decl As String, ByVal areVariables As Boolean)
    Dim parts() As String, i As Long, one As String, name As String

    ' Divide por comas (manejo simple; suficiente para Dim a As Long, b As String)
    parts = Split(decl, ",")

    For i = LBound(parts) To UBound(parts)
        one = Trim$(parts(i))
        If one = "" Then GoTo NextOne

        ' Quitar ByVal/ByRef si colara (no debería en Dim, pero por si acaso)
        one = StripTokens(one, Array("ByVal", "ByRef", "Optional", "ParamArray"))

        name = ExtractIdentifierLeft(one)
        If name <> "" Then
            ' Variables: ofuscar siempre (Dim/Private/Public) salvo que sea Public macro? (no aplica)
            MapAdd name, MakeObfuscated(name)
        End If

NextOne:
    Next i
End Sub

Private Sub CollectNamesFromArgumentList(ByVal argsBlock As String)
    Dim parts() As String, i As Long, one As String, name As String

    argsBlock = Trim$(argsBlock)
    If argsBlock = "" Then Exit Sub

    parts = Split(argsBlock, ",")

    For i = LBound(parts) To UBound(parts)
        one = Trim$(parts(i))
        If one = "" Then GoTo NextArg

        one = StripTokens(one, Array("ByVal", "ByRef", "Optional", "ParamArray"))

        name = ExtractIdentifierLeft(one)
        If name <> "" Then
            MapAdd name, MakeObfuscated(name)
        End If

NextArg:
    Next i
End Sub

Private Function ExtractIdentifierLeft(ByVal fragment As String) As String
    ' Devuelve el primer identificador de un fragmento:
    '  "x As Long" -> x
    '  "arr() As Variant" -> arr
    '  "x=5" -> x
    fragment = Trim$(fragment)
    If fragment = "" Then Exit Function

    ' cortar antes de "As", "=", "("
    fragment = CutBeforeToken(fragment, " As ")
    fragment = CutBeforeChar(fragment, "=")
    fragment = CutBeforeChar(fragment, "(")

    fragment = Trim$(fragment)

    ' quitar trailing símbolos raros
    fragment = Replace(fragment, "()", vbNullString)

    If IsValidIdentifier(fragment) Then
        ExtractIdentifierLeft = fragment
    Else
        ExtractIdentifierLeft = ""
    End If
End Function

Private Function CutBeforeToken(ByVal s As String, ByVal token As String) As String
    Dim p As Long
    p = InStr(1, s, token, vbTextCompare)
    If p > 0 Then
        CutBeforeToken = Left$(s, p - 1)
    Else
        CutBeforeToken = s
    End If
End Function

Private Function CutBeforeChar(ByVal s As String, ByVal ch As String) As String
    Dim p As Long
    p = InStr(1, s, ch, vbBinaryCompare)
    If p > 0 Then
        CutBeforeChar = Left$(s, p - 1)
    Else
        CutBeforeChar = s
    End If
End Function

Private Function StripTokens(ByVal s As String, ByVal tokens As Variant) As String
    Dim i As Long
    For i = LBound(tokens) To UBound(tokens)
        s = Replace(s, CStr(tokens(i)) & " ", "", 1, -1, vbTextCompare)
    Next i
    StripTokens = Trim$(s)
End Function

Private Function IsProcHeaderLine(ByVal s As String) As Boolean
    Dim t As String
    t = LCase$(Trim$(s))
    IsProcHeaderLine = (Left$(t, 4) = "sub ") Or (Left$(t, 9) = "public sub") Or _
                       (Left$(t, 11) = "private sub") Or (Left$(t, 9) = "function ") Or _
                       (Left$(t, 14) = "public function") Or (Left$(t, 16) = "private function")
End Function

Private Function IsProtectedProcName(ByVal procName As String, ByVal compType As VBIDE.vbext_ComponentType) As Boolean
    ' Protegemos eventos típicos + Auto macros
    If StartsWith(procName, "Workbook_") Then IsProtectedProcName = True: Exit Function
    If StartsWith(procName, "Worksheet_") Then IsProtectedProcName = True: Exit Function
    If StartsWith(procName, "Auto_") Then IsProtectedProcName = True: Exit Function
    If StrComp(procName, "AutoOpen", vbTextCompare) = 0 Then IsProtectedProcName = True: Exit Function
    If StrComp(procName, "AutoClose", vbTextCompare) = 0 Then IsProtectedProcName = True: Exit Function

    ' En módulos documento, si suena a evento, protegerlo
    If compType = vbext_ct_Document Then
        If InStr(1, procName, "_", vbBinaryCompare) > 0 Then
            ' Conservador para no romper handlers (Worksheet_Change, etc.)
            IsProtectedProcName = True
            Exit Function
        End If
    End If

    IsProtectedProcName = False
End Function

'==========================================================================================
' UTILIDADES / VALIDACIONES
'==========================================================================================
Private Function HasVBAProjectAccess() As Boolean
    On Error GoTo Nope
    Dim t As VBIDE.VBProject
    Set t = ThisWorkbook.VBProject
    HasVBAProjectAccess = True
    Exit Function
Nope:
    HasVBAProjectAccess = False
End Function

Private Function BuildDefaultDestPath(ByVal srcPath As String) As String
    Dim p As Long, base As String
    p = InStrRev(srcPath, ".")
    If p > 0 Then
        base = Left$(srcPath, p - 1)
    Else
        base = srcPath
    End If
    BuildDefaultDestPath = base & "_BLACKBOX.xlsm"
End Function

Private Function RegexEscape(ByVal s As String) As String
    Dim specials As Variant, i As Long
    specials = Array("\", "^", "$", ".", "|", "?", "*", "+", "(", ")", "[", "]", "{", "}")
    For i = LBound(specials) To UBound(specials)
        s = Replace(s, CStr(specials(i)), "\" & CStr(specials(i)))
    Next i
    RegexEscape = s
End Function

Private Function IsValidIdentifier(ByVal s As String) As Boolean
    Dim re As RegExp
    Set re = New RegExp
    re.Global = False
    re.IgnoreCase = False
    re.Pattern = "^[A-Za-z_][A-Za-z0-9_]*$"
    IsValidIdentifier = re.Test(s)
End Function

Private Function IsReservedWord(ByVal s As String) As Boolean
    ' Lista corta de palabras que NO conviene tocar
    Dim w As String
    w = LCase$(s)

    Select Case w
        Case "sub", "function", "end", "if", "then", "else", "elseif", "for", "next", "do", "loop", _
             "while", "wend", "select", "case", "with", "goto", "return", "exit", "dim", "private", _
             "public", "as", "set", "new", "not", "and", "or", "xor", "byval", "byref", "optional", _
             "paramarray", "true", "false", "nothing", "me", "thisworkbook"
            IsReservedWord = True
        Case Else
            IsReservedWord = False
    End Select
End Function

Private Function StartsWithWord(ByVal s As String, ByVal w As String) As Boolean
    Dim t As String
    t = Trim$(s)
    StartsWithWord = (StrComp(Left$(t, Len(w)), w, vbTextCompare) = 0) And _
                     (Len(t) = Len(w) Or Mid$(t, Len(w) + 1, 1) = " ")
End Function

Private Function FirstWord(ByVal s As String) As String
    Dim p As Long, t As String
    t = Trim$(s)
    p = InStr(1, t, " ", vbBinaryCompare)
    If p > 0 Then
        FirstWord = Left$(t, p - 1)
    Else
        FirstWord = t
    End If
End Function

Private Function StartsWith(ByVal s As String, ByVal prefix As String) As Boolean
    StartsWith = (StrComp(Left$(s, Len(prefix)), prefix, vbTextCompare) = 0)
End Function








Sub ColorearCeldasAleatorio()
    Dim celda As Range
    ' Aplica color a cada celda en la selección actual
    For Each celda In Selection
        ' Genera un color RGB aleatorio (0-255 para R, G, B)
        celda.Interior.Color = RGB(Int(Rnd() * 256), Int(Rnd() * 256), Int(Rnd() * 256))
    Next celda
End Sub








