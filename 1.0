Option Explicit

' =============================================================================
' VBA Excel Workbook Obfuscator / Deobfuscator - VERSIÓN FINAL FUNCIONAL
'
' GARANTIZA:
'   1. Comentarios totalmente ofuscados
'   2. Strings totalmente ofuscados
'   3. Desofuscación restaura TODO al original
'   4. Variables renombradas consistentemente
'   5. Ruido solo dentro de Sub/Function
' =============================================================================

Private Const RUNTIME_MODULE_NAME As String = "z_ofu_runtime"
Private Const NOISE_RATE As Long = 5

Private m_TagKey As String
Private m_TagNoise As String
Private m_TagComment As String
Private m_TagVarMap As String

Private m_VarMap As Object

' =============================================================================
' PUNTOS DE ENTRADA
' =============================================================================

Public Sub OFUSCAR_COPIA()
    ProcessWorkbook True
End Sub

Public Sub DESOFUSCAR_COPIA()
    ProcessWorkbook False
End Sub

' =============================================================================
' FLUJO PRINCIPAL
' =============================================================================

Private Sub ProcessWorkbook(ByVal doObfuscate As Boolean)
    Dim srcPath As String, dstPath As String
    Dim wbSrc As Workbook, wbDst As Workbook
    Dim startTime As Double

    srcPath = PickXlsmFile()
    If Len(srcPath) = 0 Then Exit Sub

    If doObfuscate Then
        dstPath = AddSuffixToPath(srcPath, "_OFUSCADO")
    Else
        dstPath = AddSuffixToPath(srcPath, "_DESOFUSCADO")
    End If

    startTime = Timer
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    On Error GoTo ErrorHandler

    Set wbSrc = Workbooks.Open(srcPath, ReadOnly:=True)
    wbSrc.SaveCopyAs dstPath
    wbSrc.Close False

    Set wbDst = Workbooks.Open(dstPath, ReadOnly:=False)

    If doObfuscate Then
        GenerateRandomTags
        Set m_VarMap = CreateObject("Scripting.Dictionary")
        EnsureRuntimeModule wbDst
        ObfuscateProject wbDst
    Else
        DeobfuscateProject wbDst
        RemoveRuntimeModule wbDst
    End If

    wbDst.Save
    wbDst.Close

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox IIf(doObfuscate, "OFUSCADO OK en ", "DESOFUSCADO OK en ") & _
           Format$(Timer - startTime, "0.0") & "s" & vbCrLf & dstPath, vbInformation
    Exit Sub

ErrorHandler:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "Error: " & Err.Description, vbCritical
End Sub

' =============================================================================
' TAGS ALEATORIOS
' =============================================================================

Private Sub GenerateRandomTags()
    m_TagKey = "'_" & RandomString(4) & "_K="
    m_TagNoise = "'_" & RandomString(5) & "_N"
    m_TagComment = "'_" & RandomString(6) & "_C:"
    m_TagVarMap = "'_" & RandomString(5) & "_V:"
End Sub

Private Function RandomString(ByVal length As Long) As String
    Dim i As Long, chars As String, result As String
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    
    Randomize
    For i = 1 To length
        result = result & Mid$(chars, Int(Rnd * Len(chars)) + 1, 1)
    Next
    
    RandomString = result
End Function

' =============================================================================
' SELECCIÓN DE ARCHIVO
' =============================================================================

Private Function PickXlsmFile() As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = "Selecciona el archivo .XLSM"
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled (*.xlsm)", "*.xlsm"
        If .Show <> -1 Then
            PickXlsmFile = ""
        Else
            PickXlsmFile = .SelectedItems(1)
        End If
    End With
End Function

Private Function AddSuffixToPath(ByVal fullPath As String, ByVal suffix As String) As String
    Dim p As Long
    p = InStrRev(fullPath, ".")
    If p > 0 Then
        AddSuffixToPath = Left$(fullPath, p - 1) & suffix & Mid$(fullPath, p)
    Else
        AddSuffixToPath = fullPath & suffix
    End If
End Function

' =============================================================================
' RUNTIME MODULE
' =============================================================================

Private Sub EnsureRuntimeModule(ByVal wb As Workbook)
    Dim c As Object
    On Error Resume Next
    Set c = wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0

    If c Is Nothing Then
        Set c = wb.VBProject.VBComponents.Add(1)
        c.Name = RUNTIME_MODULE_NAME
    End If

    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        .AddFromString RuntimeCode()
    End With
End Sub

Private Sub RemoveRuntimeModule(ByVal wb As Workbook)
    On Error Resume Next
    wb.VBProject.VBComponents.Remove wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0
End Sub

Private Function RuntimeCode() As String
    RuntimeCode = _
        "Option Explicit" & vbCrLf & _
        vbCrLf & _
        "Public Function dDecode(ByVal hex4 As String, ByVal k As Long) As String" & vbCrLf & _
        "    Dim i As Long, v As Long, r As String" & vbCrLf & _
        "    For i = 1 To Len(hex4) Step 4" & vbCrLf & _
        "        v = CLng(""&H"" & Mid$(hex4, i, 4))" & vbCrLf & _
        "        r = r & ChrW$(v Xor k)" & vbCrLf & _
        "    Next i" & vbCrLf & _
        "    dDecode = r" & vbCrLf & _
        "End Function"
End Function

' =============================================================================
' PROCESAMIENTO
' =============================================================================

Private Sub ObfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        If c.Name <> RUNTIME_MODULE_NAME Then
            code = GetCode(c)
            If Len(code) > 0 Then
                key = MakeKey()
                
                m_VarMap.RemoveAll
                BuildVariableMap code
                
                code = RenameVariables(code)
                code = InjectDummyDeclarationOnce(code)
                code = ObfuscateCodeSmart(code, key)
                
                SetCode c, m_TagKey & key & vbCrLf & _
                          SerializeVarMap() & _
                          code
            End If
        End If
    Next
End Sub

Private Sub DeobfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        code = GetCode(c)
        key = ExtractKey(code)
        If key > 0 Then
            ExtractVarMap code
            code = DeobfuscateCodeSmart(code, key)
            code = RestoreVariableNames(code)
            SetCode c, code
        End If
    Next
End Sub

Private Function GetCode(ByVal c As Object) As String
    With c.CodeModule
        If .CountOfLines = 0 Then
            GetCode = ""
        Else
            GetCode = .Lines(1, .CountOfLines)
        End If
    End With
End Function

Private Sub SetCode(ByVal c As Object, ByVal txt As String)
    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        If Len(txt) > 0 Then .AddFromString txt
    End With
End Sub

' =============================================================================
' VARIABLES
' =============================================================================

Private Sub BuildVariableMap(ByVal code As String)
    Dim lines() As String, i As Long, ln As String, trimmed As String, varName As String
    
    lines = Split(code, vbCrLf)
    
    For i = LBound(lines) To UBound(lines)
        ln = lines(i)
        trimmed = Trim$(ln)
        
        If trimmed Like "Dim *" Or trimmed Like "Private *" Or trimmed Like "Public *" Then
            If InStr(1, trimmed, "Const", vbTextCompare) > 0 Then GoTo NextVar
            
            varName = ExtractVariableName(trimmed)
            
            If Len(varName) > 0 And varName <> "ofuDummy" Then
                If Not m_VarMap.exists(varName) Then
                    m_VarMap(varName) = "v" & RandomString(8)
                End If
            End If
        End If
NextVar:
    Next
End Sub

Private Function ExtractVariableName(ByVal declaration As String) As String
    Dim varPart As String, p As Long
    
    declaration = Trim$(declaration)
    If LCase$(Left$(declaration, 4)) = "dim " Then
        declaration = Trim$(Mid$(declaration, 5))
    ElseIf LCase$(Left$(declaration, 8)) = "private " Then
        declaration = Trim$(Mid$(declaration, 9))
    ElseIf LCase$(Left$(declaration, 7)) = "public " Then
        declaration = Trim$(Mid$(declaration, 8))
    End If
    
    p = InStr(1, declaration, " As ", vbTextCompare)
    If p > 0 Then
        varPart = Trim$(Left$(declaration, p - 1))
    Else
        varPart = declaration
    End If
    
    p = InStr(varPart, "(")
    If p > 0 Then varPart = Trim$(Left$(varPart, p - 1))
    
    ExtractVariableName = varPart
End Function

Private Function SerializeVarMap() As String
    Dim result As String, k As Variant
    
    If m_VarMap.count = 0 Then Exit Function
    
    For Each k In m_VarMap.Keys
        result = result & CStr(k) & "=" & m_VarMap(k) & "|"
    Next
    
    If Len(result) > 0 Then
        result = Left$(result, Len(result) - 1)
        SerializeVarMap = m_TagVarMap & result & vbCrLf
    End If
End Function

Private Sub ExtractVarMap(ByVal src As String)
    Dim lines() As String, i As Long, ln As String, p As Long, mapData As String
    Dim pairs() As String, pair As String, parts() As String, j As Long
    
    Set m_VarMap = CreateObject("Scripting.Dictionary")
    lines = Split(src, vbCrLf)
    
    For i = LBound(lines) To UBound(lines)
        ln = lines(i)
        
        p = InStr(ln, "_V:")
        If p > 0 Then
            mapData = Mid$(ln, p + 3)
            
            If Len(mapData) > 0 Then
                pairs = Split(mapData, "|")
                
                For j = LBound(pairs) To UBound(pairs)
                    pair = pairs(j)
                    If InStr(pair, "=") > 0 Then
                        parts = Split(pair, "=")
                        If UBound(parts) >= 1 Then
                            m_VarMap(parts(1)) = parts(0)
                        End If
                    End If
                Next
            End If
            Exit For
        End If
    Next
End Sub

Private Function RenameVariables(ByVal code As String) As String
    Dim result As String, k As Variant
    
    result = code
    
    For Each k In m_VarMap.Keys
        result = ReplaceWholeWord(result, CStr(k), m_VarMap(k))
    Next
    
    RenameVariables = result
End Function

Private Function RestoreVariableNames(ByVal code As String) As String
    Dim result As String, k As Variant
    
    result = code
    
    For Each k In m_VarMap.Keys
        result = ReplaceWholeWord(result, CStr(k), m_VarMap(k))
    Next
    
    RestoreVariableNames = result
End Function

Private Function ReplaceWholeWord(ByVal text As String, ByVal oldWord As String, ByVal newWord As String) As String
    Dim result As String, i As Long, wordStart As Long
    Dim ch As String, inString As Boolean, inComment As Boolean
    
    result = ""
    i = 1
    inString = False
    inComment = False
    
    Do While i <= Len(text)
        ch = Mid$(text, i, 1)
        
        If ch = """" And Not inComment Then
            inString = Not inString
            result = result & ch
            i = i + 1
        ElseIf ch = "'" And Not inString Then
            inComment = True
            result = result & Mid$(text, i)
            Exit Do
        ElseIf Not inString And Not inComment Then
            If IsWordChar(ch) Then
                wordStart = i
                Do While i <= Len(text) And IsWordChar(Mid$(text, i, 1))
                    i = i + 1
                Loop
                
                Dim word As String
                word = Mid$(text, wordStart, i - wordStart)
                
                If StrComp(word, oldWord, vbTextCompare) = 0 Then
                    result = result & newWord
                Else
                    result = result & word
                End If
            Else
                result = result & ch
                i = i + 1
            End If
        Else
            result = result & ch
            i = i + 1
        End If
    Loop
    
    ReplaceWholeWord = result
End Function

Private Function IsWordChar(ByVal ch As String) As Boolean
    Dim code As Long
    code = Asc(ch)
    IsWordChar = (code >= 65 And code <= 90) Or _
                 (code >= 97 And code <= 122) Or _
                 (code >= 48 And code <= 57) Or _
                 ch = "_"
End Function

' =============================================================================
' INYECCIÓN DUMMY
' =============================================================================

Private Function InjectDummyDeclarationOnce(ByVal code As String) As String
    Dim lines() As String, i As Long
    Dim result() As String, injected As Boolean, count As Long
    
    lines = Split(code, vbCrLf)
    ReDim result(UBound(lines) + 1)
    
    injected = False
    count = 0

    For i = LBound(lines) To UBound(lines)
        result(count) = lines(i)
        count = count + 1
        
        If Not injected Then
            Dim trimLine As String
            trimLine = LCase$(Trim$(lines(i)))
            
            If trimLine Like "sub *" Or trimLine Like "public sub *" Or _
               trimLine Like "private sub *" Or trimLine Like "function *" Or _
               trimLine Like "public function *" Or trimLine Like "private function *" Then
                result(count) = "    Dim ofuDummy As Long"
                count = count + 1
                injected = True
            End If
        End If
    Next i
    
    ReDim Preserve result(count - 1)
    InjectDummyDeclarationOnce = Join(result, vbCrLf)
End Function

' =============================================================================
' OFUSCACIÓN PRINCIPAL
' =============================================================================

Private Function ObfuscateCodeSmart(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String, count As Long, noiseVariant As Long
    Dim insideProcedure As Boolean
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines) * 2)
    
    count = 0
    noiseVariant = 0
    insideProcedure = False

    For i = LBound(lines) To UBound(lines)
        Dim trimLine As String
        trimLine = LCase$(Trim$(lines(i)))
        
        If trimLine Like "sub *" Or trimLine Like "public sub *" Or _
           trimLine Like "private sub *" Or trimLine Like "function *" Or _
           trimLine Like "public function *" Or trimLine Like "private function *" Then
            insideProcedure = True
        End If
        
        If trimLine = "end sub" Or trimLine = "end function" Then
            insideProcedure = False
        End If
        
        result(count) = ObfuscateLineSmart(lines(i), key)
        count = count + 1
        
        If NOISE_RATE > 0 And i Mod NOISE_RATE = 0 And i > LBound(lines) Then
            If insideProcedure And Not LineEndsWithContinuation(lines(i)) Then
                If Not (trimLine Like "sub *" Or trimLine Like "function *" Or _
                        trimLine Like "public sub *" Or trimLine Like "public function *" Or _
                        trimLine Like "private sub *" Or trimLine Like "private function *") Then
                    
                    noiseVariant = (noiseVariant + 1) Mod 3
                    Select Case noiseVariant
                        Case 0
                            result(count) = m_TagNoise: count = count + 1
                            result(count) = "If False Then": count = count + 1
                            result(count) = "    ofuDummy = 0": count = count + 1
                            result(count) = "End If": count = count + 1
                        Case 1
                            result(count) = m_TagNoise: count = count + 1
                            result(count) = "On Error Resume Next": count = count + 1
                            result(count) = "ofuDummy = ofuDummy + 0": count = count + 1
                            result(count) = "On Error GoTo 0": count = count + 1
                        Case 2
                            result(count) = m_TagNoise: count = count + 1
                            result(count) = "Do While False": count = count + 1
                            result(count) = "    ofuDummy = 1": count = count + 1
                            result(count) = "Loop": count = count + 1
                    End Select
                End If
            End If
        End If
    Next

    ReDim Preserve result(count - 1)
    ObfuscateCodeSmart = Join(result, vbCrLf)
End Function

Private Function LineEndsWithContinuation(ByVal ln As String) As Boolean
    Dim trimmed As String, commentPos As Long
    
    trimmed = RTrim$(ln)
    If Len(trimmed) = 0 Then
        LineEndsWithContinuation = False
        Exit Function
    End If
    
    commentPos = InStr(trimmed, "'")
    If commentPos > 0 Then
        trimmed = RTrim$(Left$(trimmed, commentPos - 1))
    End If
    
    If Len(trimmed) = 0 Then
        LineEndsWithContinuation = False
    Else
        LineEndsWithContinuation = (Right$(trimmed, 1) = "_")
    End If
End Function

' =============================================================================
' OFUSCACIÓN DE LÍNEA
' =============================================================================

Private Function ObfuscateLineSmart(ByVal ln As String, ByVal key As Long) As String
    Dim i As Long, ch As String, result As String
    Dim inString As Boolean, commentStart As Long
    
    If IsConstDeclaration(ln) Then
        ObfuscateLineSmart = ln
        Exit Function
    End If
    
    inString = False
    commentStart = 0
    
    For i = 1 To Len(ln)
        ch = Mid$(ln, i, 1)
        If ch = """" Then
            inString = Not inString
        ElseIf ch = "'" And Not inString Then
            commentStart = i
            Exit For
        End If
    Next
    
    Dim codePart As String, commentPart As String
    
    If commentStart > 0 Then
        codePart = Left$(ln, commentStart - 1)
        commentPart = Mid$(ln, commentStart + 1)
    Else
        codePart = ln
        commentPart = ""
    End If
    
    result = ObfuscateStringsInCode(codePart, key)
    
    If Len(commentPart) > 0 Then
        result = result & m_TagComment & ToHex4(commentPart, key)
    End If
    
    ObfuscateLineSmart = result
End Function

Private Function IsConstDeclaration(ByVal ln As String) As Boolean
    Dim trimmed As String
    trimmed = LCase$(Trim$(ln))
    
    IsConstDeclaration = (trimmed Like "const *") Or _
                         (trimmed Like "private const *") Or _
                         (trimmed Like "public const *")
End Function

Private Function ObfuscateStringsInCode(ByVal code As String, ByVal key As Long) As String
    Dim result As String, i As Long, ch As String
    Dim inString As Boolean, currentString As String, beforeString As String
    
    result = ""
    inString = False
    currentString = ""
    beforeString = ""
    
    For i = 1 To Len(code)
        ch = Mid$(code, i, 1)
        
        If ch = """" Then
            If inString Then
                result = result & beforeString
                If Len(currentString) > 0 Then
                    result = result & "dDecode(""" & ToHex4(currentString, key) & """," & key & ")"
                Else
                    result = result & """"""
                End If
                beforeString = ""
                currentString = ""
                inString = False
            Else
                result = result & beforeString
                beforeString = ""
                inString = True
            End If
        Else
            If inString Then
                currentString = currentString & ch
            Else
                beforeString = beforeString & ch
            End If
        End If
    Next
    
    result = result & beforeString
    ObfuscateStringsInCode = result
End Function

' =============================================================================
' DESOFUSCACIÓN PRINCIPAL
' =============================================================================

Private Function DeobfuscateCodeSmart(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String, count As Long, skipNext As Long
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines))
    
    count = 0
    skipNext = 0

    For i = LBound(lines) To UBound(lines)
        If skipNext > 0 Then
            skipNext = skipNext - 1
            GoTo NextLine
        End If
        
        Dim ln As String, trimLine As String
        ln = lines(i)
        trimLine = Trim$(ln)
        
        ' Saltar TODAS las líneas que empiecen con '_
        If Left$(ln, 2) = "'_" Then
            If InStr(ln, "_K=") > 0 Or InStr(ln, "_V:") > 0 Then
                GoTo NextLine
            Else
                ' Es tag de ruido - saltar siguientes líneas
                If i + 1 <= UBound(lines) Then
                    Dim nextLine As String
                    nextLine = Trim$(lines(i + 1))
                    
                    If nextLine = "If False Then" Or nextLine = "On Error Resume Next" Or nextLine = "Do While False" Then
                        skipNext = 2
                    End If
                End If
                GoTo NextLine
            End If
        End If
        
        ' Filtrar líneas de ruido
        If trimLine = "If False Then" Or trimLine = "End If" Or _
           trimLine = "Do While False" Or trimLine = "Loop" Or _
           InStr(trimLine, "Dim ofuDummy") > 0 Or _
           trimLine = "ofuDummy = ofuDummy + 0" Or trimLine = "ofuDummy = 0" Or trimLine = "ofuDummy = 1" Then
            GoTo NextLine
        End If
        
        ' Restaurar línea
        result(count) = RestoreLineSmart(ln, key)
        count = count + 1
        
NextLine:
    Next

    ReDim Preserve result(count - 1)
    DeobfuscateCodeSmart = Join(result, vbCrLf)
End Function

Private Function RestoreLineSmart(ByVal ln As String, ByVal key As Long) As String
    Dim p As Long, result As String, colonPos As Long, hexStr As String
    
    result = ln
    
    ' 1. Restaurar comentario (buscar _C:)
    p = InStr(result, "_C:")
    If p > 0 Then
        hexStr = Mid$(result, p + 3)
        result = Left$(result, p - 2) & "'" & FromHex4Fast(hexStr, key)
        RestoreLineSmart = result
        Exit Function
    End If
    
    ' 2. Restaurar strings (buscar dDecode)
    Dim maxIterations As Long, p2 As Long, pEnd As Long, decoded As String
    maxIterations = 0
    
    Do While InStr(result, "dDecode(""") > 0 And maxIterations < 100
        maxIterations = maxIterations + 1
        
        p = InStr(result, "dDecode(""")
        
        p2 = InStr(p + 10, result, """")
        If p2 = 0 Then Exit Do
        
        pEnd = InStr(p2 + 1, result, ")")
        If pEnd = 0 Then Exit Do
        
        hexStr = Mid$(result, p + 9, p2 - p - 9)
        decoded = FromHex4Fast(hexStr, key)
        
        result = Left$(result, p - 1) & """" & decoded & """" & Mid$(result, pEnd + 1)
    Loop
    
    RestoreLineSmart = result
End Function

' =============================================================================
' HEX4
' =============================================================================

Private Function ToHex4(ByVal s As String, ByVal k As Long) As String
    Dim i As Long, charCode As Long, result As String, hexChunk As String
    
    result = Space$(Len(s) * 4)
    
    For i = 1 To Len(s)
        charCode = AscW(Mid$(s, i, 1)) Xor k
        hexChunk = Right$("0000" & Hex$(charCode), 4)
        Mid$(result, (i - 1) * 4 + 1, 4) = hexChunk
    Next
    
    ToHex4 = result
End Function

Private Function FromHex4Fast(ByVal hex4 As String, ByVal k As Long) As String
    Dim i As Long, v As Long, length As Long, result As String
    
    length = Len(hex4)
    If length Mod 4 <> 0 Then
        FromHex4Fast = ""
        Exit Function
    End If
    
    result = Space$(length \ 4)
    
    On Error Resume Next
    For i = 1 To length Step 4
        v = CLng("&H" & Mid$(hex4, i, 4))
        If Err.Number = 0 Then
            Mid$(result, (i \ 4) + 1, 1) = ChrW$(v Xor k)
        End If
    Next
    On Error GoTo 0
    
    FromHex4Fast = result
End Function

' =============================================================================
' UTILIDADES
' =============================================================================

Private Function MakeKey() As Long
    Randomize
    MakeKey = CLng(Rnd * 65534) + 1
End Function

Private Function ExtractKey(ByVal src As String) As Long
    Dim lines() As String, i As Long, ln As String, p As Long, s As String
    
    lines = Split(src, vbCrLf)
    
    For i = LBound(lines) To UBound(lines)
        ln = lines(i)
        If InStr(ln, "_K=") > 0 Then
            p = InStr(ln, "=")
            If p > 0 Then
                s = Trim$(Mid$(ln, p + 1))
                If IsNumeric(s) Then
                    ExtractKey = CLng(s)
                    Exit Function
                End If
            End If
        End If
    Next
    
    ExtractKey = 0
End Function
