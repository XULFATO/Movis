# ==========================================================
# Buscar literales en Blueprints (versiÃ³n C - OpenXML sin Excel)
# ==========================================================
$ErrorActionPreference = "Stop"

# ---------- ðŸ—‚ï¸ LISTA INTERNA (Modo 2) ----------
$rutasOrigen = @(
    "R:\Clientes\J18_GroupLink_6.1\01_DocumentaciÃ³n ImplantaciÃ³n\03_AnÃ¡lisis",
    "R:\Clientes\Z02_Finanzas_3.0\01_DocumentaciÃ³n ImplantaciÃ³n\03_AnÃ¡lisis\Blueprint.xlsx"
)

# ---------- FUNCIONES AUXILIARES ----------
function Remove-Diacritics([string]$s){
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray() | Where-Object {
        [Globalization.CharUnicodeInfo]::GetUnicodeCategory($_) -ne [Globalization.UnicodeCategory]::NonSpacingMark
    }) -join ''
}
function Normalize([string]$s){ (Remove-Diacritics $s).ToLowerInvariant().Trim() }
function Select-Mode {
    Write-Host "`nðŸŸ¦ MODO DE BÃšSQUEDA" -ForegroundColor Cyan
    Write-Host "1ï¸âƒ£  Escanear automÃ¡ticamente toda la estructura"
    Write-Host "2ï¸âƒ£  Usar listado interno (`$rutasOrigen`)"
    Write-Host "3ï¸âƒ£  Escanear filtrando solo carpetas que contengan un texto"
    $r = Read-Host "Elige modo (1, 2 o 3)"
    if ($r -eq '2'){ return 2 } elseif ($r -eq '3'){ return 3 } else { return 1 }
}

# ---------- ENTRADA ----------
Write-Host "ðŸ” BÃºsqueda rÃ¡pida en Blueprints (.xlsx) â†’ hoja 'AnÃ¡lisis conceptos'" -ForegroundColor Cyan
$mode = Select-Mode

Write-Host "`nâœï¸  Introduce hasta 10 literales (uno por lÃ­nea). Deja vacÃ­o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++){
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "âŒ No se introdujo ningÃºn literal. Saliendo."; exit }

$pattern = ($literals | ForEach-Object { [regex]::Escape((Normalize $_)) }) -join "|"
$reDoc = '(?i)(documentaci[oÃ³]n\s+implantaci[oÃ³]n)'
$reAna = '(?i)(an[aÃ¡]lisis)'

# ---------- LOCALIZAR BLUEPRINTS ----------
$blueprints = @()

if ($mode -eq 1 -or $mode -eq 3) {
    $basePath = Read-Host "ðŸ“‚ Introduce la ruta base (p.ej. R:\Proyectos)"
    if (-not (Test-Path $basePath)) { Write-Host "âŒ Ruta no vÃ¡lida."; exit }

    $filtro = ""
    if ($mode -eq 3) {
        $filtro = Read-Host "ðŸ”¤ Texto que deben contener las carpetas (p. ej. _23_ o _BKT_)"
        if ([string]::IsNullOrWhiteSpace($filtro)) { $filtro = "" }
    }

    Write-Host "`nðŸ“ Escaneando carpetas..." -ForegroundColor DarkCyan
    $carpetas = Get-ChildItem -Path $basePath -Directory |
                Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
                Sort-Object LastWriteTime -Descending
    if ($filtro -ne "") {
        $carpetas = $carpetas | Where-Object { $_.Name -match [regex]::Escape($filtro) }
        Write-Host ("ðŸ”Ž Aplicado filtro: '{0}' â†’ {1} carpetas" -f $filtro, $carpetas.Count) -ForegroundColor Yellow
    }

    foreach ($dir1 in $carpetas) {
        Write-Host ("â†’ Carpeta principal: {0}" -f $dir1.Name) -ForegroundColor Yellow
        Get-ChildItem -Path $dir1.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
            $dir2 = $_
            $docDirs = Get-ChildItem -Path $dir2.FullName -Directory -ErrorAction SilentlyContinue |
                       Where-Object { $_.Name -match $reDoc }
            foreach ($doc in $docDirs) {
                $anaDirs = Get-ChildItem -Path $doc.FullName -Directory -ErrorAction SilentlyContinue |
                           Where-Object { $_.Name -match $reAna }
                foreach ($ana in $anaDirs) {
                    Write-Host ("   ðŸ“‚ Subcarpeta AnÃ¡lisis: {0}" -f $ana.FullName) -ForegroundColor Cyan
                    $found = Get-ChildItem -Path $ana.FullName -Recurse -File -ErrorAction SilentlyContinue |
                             Where-Object { $_.Name -notlike '~$*' -and $_.Name -match '(?i)Blueprint.*\.xlsx$' }
                    foreach ($f in $found) {
                        Write-Host ("      âœ… Blueprint: {0}" -f $f.FullName) -ForegroundColor Green
                        $blueprints += $f.FullName
                    }
                }
            }
        }
    }
}
elseif ($mode -eq 2) {
    Write-Host "`nðŸ“„ Usando listado interno de rutas..." -ForegroundColor DarkCyan
    foreach ($ruta in $rutasOrigen) {
        if (-not (Test-Path $ruta)) { Write-Host "âš ï¸ Ruta no encontrada: $ruta" -ForegroundColor DarkYellow; continue }
        if ((Get-Item $ruta).PSIsContainer) {
            $found = Get-ChildItem -Path $ruta -Recurse -File -ErrorAction SilentlyContinue |
                     Where-Object { $_.Name -notlike '~$*' -and $_.Name -match '(?i)Blueprint.*\.xlsx$' }
            foreach ($f in $found) {
                Write-Host ("      âœ… Blueprint: {0}" -f $f.FullName) -ForegroundColor Green
                $blueprints += $f.FullName
            }
        } else {
            Write-Host ("      âœ… Blueprint: {0}" -f $ruta) -ForegroundColor Green
            $blueprints += $ruta
        }
    }
}

if ($blueprints.Count -eq 0) { Write-Host "âš ï¸ No se encontraron Blueprints."; exit }
Write-Host ("   â†’ {0} ficheros detectados." -f $blueprints.Count) -ForegroundColor Green

# ---------- ANALIZAR CON OPENXML ----------
$totalEncontrados = 0
$totalBlueprintsOK = 0
$detalles = @()
$inicio = Get-Date

foreach ($path in $blueprints) {
    Write-Host ("`nðŸ”¹ Analizando: {0}" -f $path) -ForegroundColor DarkCyan
    try {
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        $tmpDir = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), [System.IO.Path]::GetRandomFileName())
        [System.IO.Compression.ZipFile]::ExtractToDirectory($path, $tmpDir)

        # buscar hojas con â€œAnÃ¡lisisâ€ y â€œConceptosâ€
        $sheetFiles = Get-ChildItem "$tmpDir\xl\worksheets" -File -ErrorAction SilentlyContinue
        foreach ($sheet in $sheetFiles) {
            $content = Get-Content $sheet.FullName -Raw -ErrorAction SilentlyContinue
            if ($content -match '(?i)an[aÃ¡]lisis' -and $content -match '(?i)concept') {
                $textos = (Select-String -InputObject $content -Pattern ">([^<]+)<" -AllMatches).Matches.Value |
                          ForEach-Object { ($_ -replace '[><]', '') }
                foreach ($t in $textos) {
                    $v = Normalize $t
                    if ($v -match $pattern) {
                        Write-Host ("âœ… '{0}' â†’ {1}" -f $t.Trim(), $path) -ForegroundColor Green
                        $detalles += [PSCustomObject]@{
                            Fichero = $path
                            Valor   = $t.Trim()
                        }
                        $totalEncontrados++
                    }
                }
            }
        }

        Remove-Item -Path $tmpDir -Recurse -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Host ("âš ï¸ Error en {0}: {1}" -f $path, $_.Exception.Message) -ForegroundColor DarkYellow
    }
}

# ---------- RESUMEN ----------
$fin = Get-Date
$dur = New-TimeSpan -Start $inicio -End $fin
$agrupado = $detalles | Group-Object Fichero

Write-Host "`n==============================================" -ForegroundColor DarkCyan
Write-Host ("ðŸ“Š RESUMEN FINAL") -ForegroundColor Cyan
Write-Host ("   Blueprints analizados : {0}" -f $blueprints.Count)
Write-Host ("   Con hallazgos : {0}" -f $agrupado.Count)
Write-Host ("   Coincidencias totales : {0}" -f $totalEncontrados)
Write-Host ("   Tiempo total : {0} min {1:D2} s" -f $dur.Minutes, $dur.Seconds)
Write-Host "==============================================" -ForegroundColor DarkCyan

if ($agrupado.Count -gt 0) {
    foreach ($g in $agrupado) {
        Write-Host "`nðŸ“ $($g.Name)" -ForegroundColor Cyan
        foreach ($d in $g.Group) {
            Write-Host ("   â†’ {0}" -f $d.Valor)
        }
    }
} else {
    Write-Host "`nâšª No se encontraron coincidencias." -ForegroundColor Gray
}

Write-Host "`nâœ”ï¸ Proceso completado (sin abrir Excel, lectura OpenXML)." -ForegroundColor Green