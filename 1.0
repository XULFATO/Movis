# ===========================================
# Buscar-Blueprints.ps1
# Busca literales dentro de la hoja "An√°lisis Conceptos"
# en ficheros Excel cuyo nombre contenga "Blueprint"
# ===========================================

$ErrorActionPreference = 'Stop'

function Ask-YesNo($prompt) {
    while ($true) {
        $r = Read-Host "$prompt (S/N)"
        if ($r -match '^[sS]$') { return $true }
        if ($r -match '^[nN]$') { return $false }
    }
}

Write-Host "üîç B√∫squeda de literales en la hoja 'An√°lisis Conceptos' de ficheros 'Blueprint'..." -ForegroundColor Cyan

# Ruta base
$basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. R:\Proyectos)"
if (-not (Test-Path $basePath)) {
    Write-Host "‚ùå La ruta no existe: $basePath" -ForegroundColor Red
    exit 1
}

# Nombre exacto de la hoja (por si en tu entorno var√≠a el acento, puedes cambiarlo aqu√≠)
$sheetName = "An√°lisis Conceptos"

# Literales (hasta 10)
Write-Host "`nIntroduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++) {
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) {
    Write-Host "‚ùå No se introdujo ning√∫n literal." -ForegroundColor Red
    exit 1
}

# ¬øParar en la primera coincidencia global?
$stopAtFirst = Ask-YesNo "¬øParar al encontrar la primera coincidencia?"

# Recopilaci√≥n de archivos objetivo
Write-Host "`nüìÅ Recorriendo carpetas..." -ForegroundColor DarkCyan
$files = Get-ChildItem -Path $basePath -Recurse -File -Include '*Blueprint*.xlsx','*Blueprint*.xlsm','*Blueprint*.xls' `
         | Where-Object { $_.Name -notlike '~$*' }  # ignora temporales de Excel

if ($files.Count -eq 0) {
    Write-Host "‚ö†Ô∏è No se encontraron ficheros 'Blueprint' en $basePath" -ForegroundColor DarkYellow
    exit 0
}
Write-Host ("   ‚Üí {0} ficheros encontrados." -f $files.Count)

# Preparar Excel (COM)
$excel = $null
try {
    $excel = New-Object -ComObject Excel.Application
    $excel.Visible        = $false
    $excel.DisplayAlerts  = $false

    # Optimizar durante la b√∫squeda
    $prevCalc = $excel.Calculation
    $prevScreen = $excel.ScreenUpdating
    $excel.ScreenUpdating = $false
    $excel.Calculation    = -4135 # xlCalculationManual

    # Para resultados, crearemos un libro nuevo al final
    $results = New-Object System.Collections.Generic.List[object]

    # Constantes Excel
    $xlValues   = -4163  # LookIn
    $xlPart     = 2      # LookAt (contiene)
    $xlByRows   = 1
    $xlNext     = 1

    foreach ($file in $files) {
        foreach ($lit in $literals) {
            $wb = $null
            try {
                # Abrir en s√≥lo lectura, sin actualizar v√≠nculos
                $wb = $excel.Workbooks.Open($file.FullName, 0, $true)  # UpdateLinks:=0, ReadOnly:=True

                # Buscar la hoja exacta
                $sheet = $null
                foreach ($sh in $wb.Worksheets) {
                    if ($sh.Name -eq $sheetName) { $sheet = $sh; break }
                }
                if (-not $sheet) {
                    # No tiene la hoja requerida
                    continue
                }

                # Usar Find para localizar coincidencias (r√°pido y fiable)
                $firstHit = $sheet.Cells.Find($lit, [Type]::Missing, $xlValues, $xlPart, $xlByRows, $xlNext, $false, [Type]::Missing, [Type]::Missing)

                if ($firstHit -ne $null) {
                    # Registramos la primera coincidencia
                    $addrStart = $firstHit.Address(0,0)  # A1 style
                    $addrCurr  = $addrStart

                    $results.Add([PSCustomObject]@{
                        Fichero   = $file.FullName
                        Hoja      = $sheetName
                        Literal   = $lit
                        Celda     = $addrCurr
                    })

                    if ($stopAtFirst) {
                        $wb.Close($false)
                        throw [System.Exception]::new("STOP_GLOBAL")
                    }

                    # Si queremos todas, iteramos FindNext hasta volver al inicio
                    while ($true) {
                        $next = $sheet.Cells.FindNext($firstHit)
                        if ($next -eq $null) { break }
                        $addrNext = $next.Address(0,0)
                        if ($addrNext -eq $addrStart) { break } # cerramos ciclo

                        $results.Add([PSCustomObject]@{
                            Fichero   = $file.FullName
                            Hoja      = $sheetName
                            Literal   = $lit
                            Celda     = $addrNext
                        })

                        $firstHit = $next
                    }
                }
            } catch {
                # Si es la excepci√≥n de parada global, la relanzamos
                if ($_.Exception.Message -eq "STOP_GLOBAL") { throw }
                Write-Host ("‚ö†Ô∏è Error con: {0}  ‚Üí {1}" -f $file.FullName, $_.Exception.Message) -ForegroundColor DarkYellow
            } finally {
                if ($wb -ne $null) { $wb.Close($false) | Out-Null }
            }
        }
    }

    # Restaurar Excel
    $excel.ScreenUpdating = $prevScreen
    $excel.Calculation    = $prevCalc

    # Volcar resultados a un Excel nuevo
    $outPath = Join-Path $env:USERPROFILE "Desktop\Resultados_Blueprint.xlsx"
    $wbOut = $excel.Workbooks.Add()
    $wsOut = $wbOut.Worksheets.Item(1)
    $wsOut.Name = "Resultados"

    # Cabeceras
    $wsOut.Cells.Item(1,1) = "Fichero"
    $wsOut.Cells.Item(1,2) = "Hoja"
    $wsOut.Cells.Item(1,3) = "Literal"
    $wsOut.Cells.Item(1,4) = "Celda"

    $row = 2
    foreach ($r in $results) {
        $wsOut.Cells.Item($row,1) = $r.Fichero
        $wsOut.Cells.Item($row,2) = $r.Hoja
        $wsOut.Cells.Item($row,3) = $r.Literal
        $wsOut.Cells.Item($row,4) = $r.Celda
        $row++
    }

    # Autoajustar columnas si hay resultados
    if ($results.Count -gt 0) {
        $wsOut.Range("A1:D$($row-1)").EntireColumn.AutoFit() | Out-Null
    }

    $wbOut.SaveAs($outPath)
    $wbOut.Close($false)

    Write-Host "`n‚úÖ Terminado." -ForegroundColor Green
    if ($results.Count -gt 0) {
        Write-Host ("üìÑ Coincidencias: {0}" -f $results.Count)
        Write-Host ("üìÅ Archivo generado: {0}" -f $outPath) -ForegroundColor Cyan
    } else {
        Write-Host "‚ö†Ô∏è No se encontraron coincidencias." -ForegroundColor DarkYellow
    }

} catch {
    if ($_.Exception.Message -eq "STOP_GLOBAL") {
        # Parada voluntaria al primer hallazgo: a√∫n as√≠ volcamos lo encontrado
        Write-Host "`n‚èπ Parado en la primera coincidencia (por opci√≥n elegida)." -ForegroundColor Yellow
        # Crear Excel de salida m√≠nimo si no existe instancia (reutilizamos $excel activo)
        try {
            $outPath = Join-Path $env:USERPROFILE "Desktop\Resultados_Blueprint.xlsx"
            $wbOut = $excel.Workbooks.Add()
            $wsOut = $wbOut.Worksheets.Item(1)
            $wsOut.Name = "Resultados"
            $wsOut.Cells.Item(1,1) = "Fichero"
            $wsOut.Cells.Item(1,2) = "Hoja"
            $wsOut.Cells.Item(1,3) = "Literal"
            $wsOut.Cells.Item(1,4) = "Celda"
            $row = 2
            foreach ($r in $results) {
                $wsOut.Cells.Item($row,1) = $r.Fichero
                $wsOut.Cells.Item($row,2) = $r.Hoja
                $wsOut.Cells.Item($row,3) = $r.Literal
                $wsOut.Cells.Item($row,4) = $r.Celda
                $row++
            }
            if ($results.Count -gt 0) {
                $wsOut.Range("A1:D$($row-1)").EntireColumn.AutoFit() | Out-Null
            }
            $wbOut.SaveAs($outPath)
            $wbOut.Close($false)
            Write-Host ("üìÅ Archivo generado: {0}" -f $outPath) -ForegroundColor Cyan
        } catch {
            Write-Host ("‚ùå Error creando el Excel de resultados: {0}" -f $_.Exception.Message) -ForegroundColor Red
        }
    } else {
        Write-Host ("‚ùå Error inesperado: {0}" -f $_.Exception.Message) -ForegroundColor Red
    }
} finally {
    if ($excel -ne $null) {
        $excel.DisplayAlerts = $false
        $excel.Quit()
        [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
    }
}