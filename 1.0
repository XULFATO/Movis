Option Explicit

' =============================================================================
' VBA Excel Workbook Obfuscator/Deobfuscator (PRO)
'
' - No toca el original: crea una COPIA y trabaja sobre la copia.
' - Ofusca/desofusca todos los VBComponents del proyecto.
' - Strings: Unicode-safe (HEX 4 dígitos por char) + XOR por módulo.
' - Comentarios: a HEX (marcados).
' - Ruido: líneas marcadas y no ejecutables.
'
' IMPORTANTE:
' Requiere "Trust access to the VBA project object model" habilitado.
' =============================================================================

' ---- Marcadores internos (para poder revertir) ----
Private Const TAG_KEY As String = "'__OFUKEY__="
Private Const TAG_CMT As String = "'__OFUCMT__ "
Private Const TAG_NOISE As String = "'__OFUNOISE__"
Private Const RUNTIME_MODULE_NAME As String = "z__ofu_runtime"

' ---- Ajustes de ofuscación ----
Private Const NOISE_RATE As Long = 6          ' 1 de cada N líneas mete ruido (aprox)
Private Const HEX_CHUNK_LEN As Long = 120     ' trozos de HEX por literal para no romper líneas

' =============================================================================
' ENTRADAS PRINCIPALES (botones / macros)
' =============================================================================

Public Sub OFUSCAR_COPIA()
    ProcessWorkbook True
End Sub

Public Sub DESOFUSCAR_COPIA()
    ProcessWorkbook False
End Sub

' =============================================================================
' Flujo principal: selecciona libro, crea copia, procesa VBProject en la copia
' =============================================================================

Private Sub ProcessWorkbook(ByVal doObfuscate As Boolean)
    Dim srcPath As String, dstPath As String, ts As String
    Dim wbSrc As Workbook, wbDst As Workbook

    srcPath = PickXlsmFile()
    If Len(srcPath) = 0 Then Exit Sub

    ts = Format$(Now, "dd_mm_yy_hh_nn_ss")

    If doObfuscate Then
        dstPath = AddSuffixToPath(srcPath, "_OFU_" & ts)
    Else
        dstPath = AddSuffixToPath(srcPath, "_DESOFU_" & ts)
    End If

    Application.ScreenUpdating = False
    Application.DisplayAlerts = False

    ' Abrimos origen (solo para hacer SaveCopyAs, no lo tocamos)
    Set wbSrc = Workbooks.Open(Filename:=srcPath, ReadOnly:=True)

    ' Copia física del archivo (con todo: hojas, codenames, etc.)
    wbSrc.SaveCopyAs dstPath
    wbSrc.Close SaveChanges:=False

    ' Abrimos la copia y trabajamos SOBRE ella
    Set wbDst = Workbooks.Open(Filename:=dstPath, ReadOnly:=False)

    ' Asegura runtime decoder (solo si ofuscas)
    If doObfuscate Then EnsureRuntimeModule wbDst

    ' Procesa cada componente del VBProject
    If doObfuscate Then
        ObfuscateProject wbDst
    Else
        DeobfuscateProject wbDst
    End If

    wbDst.Save
    wbDst.Close SaveChanges:=True

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox IIf(doObfuscate, "OFUSCADO OK:", "DESOFUSCADO OK:") & vbCrLf & dstPath, vbInformation
End Sub

' =============================================================================
' Selección de archivo
' =============================================================================

Private Function PickXlsmFile() As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)

    With fd
        .Title = "Selecciona el .XLSM a procesar (se creará una copia)"
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled (*.xlsm)", "*.xlsm"
        If .Show <> -1 Then
            PickXlsmFile = vbNullString
        Else
            PickXlsmFile = .SelectedItems(1)
        End If
    End With
End Function

Private Function AddSuffixToPath(ByVal fullPath As String, ByVal suffix As String) As String
    Dim p As Long, base As String, ext As String
    p = InStrRev(fullPath, ".")
    If p = 0 Then
        AddSuffixToPath = fullPath & suffix
        Exit Function
    End If
    base = Left$(fullPath, p - 1)
    ext = Mid$(fullPath, p)
    AddSuffixToPath = base & suffix & ext
End Function

' =============================================================================
' Runtime module: decoder Unicode-safe
' =============================================================================

Private Sub EnsureRuntimeModule(ByVal wb As Workbook)
    Dim vbProj As Object, comps As Object, comp As Object
    Set vbProj = wb.VBProject
    Set comps = vbProj.VBComponents

    On Error Resume Next
    Set comp = comps.Item(RUNTIME_MODULE_NAME)
    On Error GoTo 0

    If comp Is Nothing Then
        Set comp = comps.Add(1) ' 1 = vbext_ct_StdModule (late-bound)
        comp.Name = RUNTIME_MODULE_NAME
    End If

    ' Reescribimos el runtime para tenerlo controlado
    With comp.CodeModule
        .DeleteLines 1, .CountOfLines
        .AddFromString RuntimeModuleText()
    End With
End Sub

Private Function RuntimeModuleText() As String
    ' Decoder: recibe HEX4 concatenado, hace ChrW( (val XOR key) )
    RuntimeModuleText = _
        "Option Explicit" & vbCrLf & _
        "' Runtime decoder para ofuscación" & vbCrLf & _
        "Public Function _d(ByVal hex4 As String, ByVal k As Long) As String" & vbCrLf & _
        "    Dim i As Long, v As Long" & vbCrLf & _
        "    For i = 1 To Len(hex4) Step 4" & vbCrLf & _
        "        v = CLng(""&H"" & Mid$(hex4, i, 4))" & vbCrLf & _
        "        _d = _d & ChrW$(v Xor k)" & vbCrLf & _
        "    Next i" & vbCrLf & _
        "End Function" & vbCrLf
End Function

' =============================================================================
' Proyecto: ofuscar / desofuscar VBComponents
' =============================================================================

Private Sub ObfuscateProject(ByVal wb As Workbook)
    Dim vbProj As Object, comps As Object, comp As Object
    Dim code As String, newCode As String, key As Long

    Set vbProj = wb.VBProject
    Set comps = vbProj.VBComponents

    For Each comp In comps
        ' No te ofusques el runtime a ti mismo
        If LCase$(comp.Name) = LCase$(RUNTIME_MODULE_NAME) Then GoTo NextComp

        ' Lee código completo
        code = GetComponentCode(comp)

        ' Si está vacío, saltar
        If Len(code) = 0 Then GoTo NextComp

        key = MakeKey()
        newCode = ObfuscateCode(code, key)

        ' Escribe de vuelta en la copia
        SetComponentCode comp, newCode, key

NextComp:
    Next comp
End Sub

Private Sub DeobfuscateProject(ByVal wb As Workbook)
    Dim vbProj As Object, comps As Object, comp As Object
    Dim code As String, newCode As String, key As Long

    Set vbProj = wb.VBProject
    Set comps = vbProj.VBComponents

    For Each comp In comps
        ' Runtime se puede dejar, o limpiarlo si quieres (yo lo dejo)
        code = GetComponentCode(comp)
        If Len(code) = 0 Then GoTo NextComp

        key = ExtractKey(code)
        If key = 0 Then GoTo NextComp ' no fue ofuscado por este tool

        newCode = DeobfuscateCode(code, key)
        SetComponentCodeRaw comp, newCode

NextComp:
    Next comp
End Sub

' =============================================================================
' Lectura / escritura segura de componentes
' =============================================================================

Private Function GetComponentCode(ByVal comp As Object) As String
    On Error GoTo EH
    With comp.CodeModule
        If .CountOfLines = 0 Then
            GetComponentCode = vbNullString
        Else
            GetComponentCode = .Lines(1, .CountOfLines)
        End If
    End With
    Exit Function
EH:
    ' Si algo no se puede leer (bloqueos corporativos), quedará vacío
    GetComponentCode = vbNullString
End Function

Private Sub SetComponentCode(ByVal comp As Object, ByVal newCode As String, ByVal key As Long)
    ' Inserta header con key para poder revertir
    Dim finalCode As String
    finalCode = TAG_KEY & CStr(key) & vbCrLf & newCode
    SetComponentCodeRaw comp, finalCode
End Sub

Private Sub SetComponentCodeRaw(ByVal comp As Object, ByVal newCode As String)
    On Error GoTo EH
    With comp.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        .AddFromString newCode
    End With
    Exit Sub
EH:
    ' Si no se puede escribir por permisos, aquí fallará
    Err.Raise Err.Number, , "No se pudo escribir en VBComponent: " & comp.Name & vbCrLf & Err.Description
End Sub

' =============================================================================
' Claves / extracción
' =============================================================================

Private Function MakeKey() As Long
    Randomize
    MakeKey = CLng(Int((65535 - 1 + 1) * Rnd + 1))
End Function

Private Function ExtractKey(ByVal code As String) As Long
    Dim pos As Long, line1 As String, eol As Long, s As String
    pos = InStr(1, code, TAG_KEY, vbTextCompare)
    If pos = 0 Then ExtractKey = 0: Exit Function

    eol = InStr(pos, code, vbCrLf)
    If eol = 0 Then
        line1 = Mid$(code, pos)
    Else
        line1 = Mid$(code, pos, eol - pos)
    End If

    s = Replace$(line1, TAG_KEY, "", 1, 1, vbTextCompare)
    s = Trim$(s)
    If IsNumeric(s) Then ExtractKey = CLng(s) Else ExtractKey = 0
End Function

' =============================================================================
' Ofuscación de código: línea a línea (strings + comentarios + ruido)
' =============================================================================

Private Function ObfuscateCode(ByVal code As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim out As String, ln As String

    lines = Split(NormalizeEOL(code), vbCrLf)

    For i = LBound(lines) To UBound(lines)
        ln = lines(i)

        ' No tocar líneas especiales típicas
        If StartsWithIgnoreSpace(ln, "Attribute ") Then
            out = out & ln & vbCrLf
            GoTo MaybeNoise
        End If

        ' Comentario de línea completa
        If IsFullLineComment(ln) Then
            out = out & TAG_CMT & TextToHex2(GetCommentText(ln)) & vbCrLf
            GoTo MaybeNoise
        End If

        ' Procesar: separar comentario inline si existe (fuera de strings)
        Dim codePart As String, cmtPart As String
        SplitInlineComment ln, codePart, cmtPart

        ' Ofuscar strings dentro de la parte de código
        codePart = ObfuscateStringsInLine(codePart, key)

        ' Comentario inline -> hex marcado (si existe)
        If Len(cmtPart) > 0 Then
            out = out & codePart & " " & TAG_CMT & TextToHex2(cmtPart) & vbCrLf
        Else
            out = out & codePart & vbCrLf
        End If

MaybeNoise:
        ' Ruido aleatorio (marcado para poder limpiarlo)
        If (NOISE_RATE > 0) Then
            If (i Mod NOISE_RATE = 0) Then
                out = out & TAG_NOISE & vbCrLf
                out = out & "If False Then Dim __n" & CStr(1000 + (i Mod 9000)) & " As Long: __n" & CStr(1000 + (i Mod 9000)) & " = 0" & vbCrLf
                out = out & "End If" & vbCrLf
            End If
        End If
    Next i

    ObfuscateCode = out
End Function

Private Function DeobfuscateCode(ByVal code As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim out As String, ln As String

    lines = Split(NormalizeEOL(code), vbCrLf)

    For i = LBound(lines) To UBound(lines)
        ln = lines(i)

        ' Quitar header key
        If InStr(1, ln, TAG_KEY, vbTextCompare) = 1 Then GoTo NextLine

        ' Quitar ruido marcado + bloque If False
        If InStr(1, ln, TAG_NOISE, vbTextCompare) = 1 Then GoTo NextLine
        If StartsWithIgnoreSpace(ln, "If False Then") Then GoTo NextLine
        If StartsWithIgnoreSpace(ln, "End If") Then GoTo NextLine

        ' Comentario hex completo
        If InStr(1, ln, TAG_CMT, vbTextCompare) = 1 Then
            out = out & "' " & Hex2ToText(Mid$(ln, Len(TAG_CMT) + 1)) & vbCrLf
            GoTo NextLine
        End If

        ' Comentario inline marcado
        If InStr(1, ln, TAG_CMT, vbTextCompare) > 0 Then
            Dim leftPart As String, hexPart As String
            leftPart = Left$(ln, InStr(1, ln, TAG_CMT, vbTextCompare) - 1)
            hexPart = Mid$(ln, InStr(1, ln, TAG_CMT, vbTextCompare) + Len(TAG_CMT))
            leftPart = DeobfuscateDCallsInLine(leftPart, key)
            out = out & RTrim$(leftPart) & " ' " & Hex2ToText(hexPart) & vbCrLf
        Else
            out = out & DeobfuscateDCallsInLine(ln, key) & vbCrLf
        End If

NextLine:
    Next i

    DeobfuscateCode = out
End Function

' =============================================================================
' Utilidades de parseo de líneas
' =============================================================================

Private Function NormalizeEOL(ByVal s As String) As String
    s = Replace$(s, vbCrLf, vbLf)
    s = Replace$(s, vbCr, vbLf)
    NormalizeEOL = Replace$(s, vbLf, vbCrLf)
End Function

Private Function StartsWithIgnoreSpace(ByVal s As String, ByVal prefix As String) As Boolean
    Dim t As String
    t = LTrim$(s)
    StartsWithIgnoreSpace = (StrComp(Left$(t, Len(prefix)), prefix, vbTextCompare) = 0)
End Function

Private Function IsFullLineComment(ByVal s As String) As Boolean
    IsFullLineComment = (Left$(LTrim$(s), 1) = "'")
End Function

Private Function GetCommentText(ByVal s As String) As String
    Dim t As String
    t = LTrim$(s)
    If Left$(t, 1) = "'" Then GetCommentText = Mid$(t, 2) Else GetCommentText = vbNullString
End Function

Private Sub SplitInlineComment(ByVal line As String, ByRef codePart As String, ByRef commentPart As String)
    ' Busca un apóstrofe que NO esté dentro de un string VBA
    Dim i As Long, inStr As Boolean
    Dim ch As String, nxt As String

    inStr = False
    For i = 1 To Len(line)
        ch = Mid$(line, i, 1)

        If ch = """" Then
            ' Si estamos en string y hay "" (doble comilla), se queda dentro
            If inStr Then
                If i < Len(line) Then
                    nxt = Mid$(line, i + 1, 1)
                    If nxt = """" Then
                        i = i + 1 ' consume la comilla escapada
                    Else
                        inStr = False
                    End If
                Else
                    inStr = False
                End If
            Else
                inStr = True
            End If
        ElseIf ch = "'" Then
            If Not inStr Then
                codePart = Left$(line, i - 1)
                commentPart = Mid$(line, i + 1)
                Exit Sub
            End If
        End If
    Next i

    codePart = line
    commentPart = vbNullString
End Sub

' =============================================================================
' Ofuscación de strings en una línea
' =============================================================================

Private Function ObfuscateStringsInLine(ByVal line As String, ByVal key As Long) As String
    Dim i As Long, inStr As Boolean
    Dim out As String, buf As String
    Dim ch As String, nxt As String

    out = ""
    buf = ""
    inStr = False

    For i = 1 To Len(line)
        ch = Mid$(line, i, 1)

        If ch = """" Then
            If inStr Then
                ' comillas escapadas "" dentro del string
                If i < Len(line) Then
                    nxt = Mid$(line, i + 1, 1)
                    If nxt = """" Then
                        buf = buf & """"  ' representa una comilla real
                        i = i + 1
                    Else
                        ' fin de literal
                        out = out & BuildDCall(buf, key)
                        buf = ""
                        inStr = False
                    End If
                Else
                    out = out & BuildDCall(buf, key)
                    buf = ""
                    inStr = False
                End If
            Else
                ' inicio de literal
                inStr = True
            End If
        Else
            If inStr Then
                buf = buf & ch
            Else
                out = out & ch
            End If
        End If
    Next i

    ' Si quedó un string sin cerrar, lo deja tal cual (mejor que romper)
    If inStr Then
        ObfuscateStringsInLine = line
    Else
        ObfuscateStringsInLine = out
    End If
End Function

Private Function BuildDCall(ByVal plain As String, ByVal key As Long) As String
    ' Convierte el texto en HEX4 XOR, trocea y construye:
    ' _d("AAAA" & "BBBB" & "CCCC", key)
    Dim hex4 As String, parts() As String, expr As String
    Dim p As Long, n As Long, chunk As String

    hex4 = TextToHex4Xor(plain, key)

    If Len(hex4) = 0 Then
        BuildDCall = """""" ' string vacío
        Exit Function
    End If

    n = (Len(hex4) + HEX_CHUNK_LEN - 1) \ HEX_CHUNK_LEN
    ReDim parts(1 To n)

    For p = 1 To n
        chunk = Mid$(hex4, ((p - 1) * HEX_CHUNK_LEN) + 1, HEX_CHUNK_LEN)
        parts(p) = """" & chunk & """"
    Next p

    expr = "_d(" & Join(parts, " & ") & ", " & CStr(key) & ")"
    BuildDCall = expr
End Function

' =============================================================================
' Desofuscación de llamadas _d(...) en una línea
' =============================================================================

Private Function DeobfuscateDCallsInLine(ByVal line As String, ByVal key As Long) As String
    ' Busca patrones _d("...." & "....", key) y los revierte a "texto"
    Dim out As String, pos As Long, startPos As Long, endPos As Long
    Dim before As String, after As String, inside As String, decoded As String

    out = line
    pos = InStr(1, out, "_d(", vbTextCompare)

    Do While pos > 0
        startPos = pos + 3

        endPos = FindMatchingParen(out, startPos)
        If endPos = 0 Then Exit Do

        before = Left$(out, pos - 1)
        inside = Mid$(out, startPos, endPos - startPos)
        after = Mid$(out, endPos + 1)

        decoded = DecodeDInsideToLiteral(inside, key)
        If Len(decoded) = 0 Then Exit Do

        out = before & decoded & after
        pos = InStr(pos + Len(decoded), out, "_d(", vbTextCompare)
    Loop

    DeobfuscateDCallsInLine = out
End Function

Private Function FindMatchingParen(ByVal s As String, ByVal fromPos As Long) As Long
    ' Encuentra el ')' correspondiente a partir de fromPos, respetando strings
    Dim i As Long, depth As Long, inStr As Boolean
    Dim ch As String, nxt As String

    depth = 1
    inStr = False

    For i = fromPos To Len(s)
        ch = Mid$(s, i, 1)

        If ch = """" Then
            If inStr Then
                If i < Len(s) Then
                    nxt = Mid$(s, i + 1, 1)
                    If nxt = """" Then
                        i = i + 1
                    Else
                        inStr = False
                    End If
                Else
                    inStr = False
                End If
            Else
                inStr = True
            End If
        ElseIf Not inStr Then
            If ch = "(" Then depth = depth + 1
            If ch = ")" Then
                depth = depth - 1
                If depth = 0 Then
                    FindMatchingParen = i
                    Exit Function
                End If
            End If
        End If
    Next i

    FindMatchingParen = 0
End Function

Private Function DecodeDInsideToLiteral(ByVal inside As String, ByVal key As Long) As String
    ' inside =  """AAAA"" & ""BBBB"", 12345"
    ' Extrae todas las strings entre comillas dentro del primer argumento.
    ' Ignora el segundo argumento (key) porque lo pasamos como parámetro aquí.
    Dim hex4 As String
    hex4 = ExtractQuotedStringsConcatenated(inside)
    If Len(hex4) = 0 Then
        DecodeDInsideToLiteral = vbNullString
        Exit Function
    End If

    Dim plain As String
    plain = Hex4XorToText(hex4, key)

    DecodeDInsideToLiteral = VbaStringLiteral(plain)
End Function

Private Function ExtractQuotedStringsConca
