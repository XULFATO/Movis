Option Explicit

' ============================
' Excel → Caja negra (one-way)
' ============================

Private Const TOOL_MARKER As String = "BBX_TOOL_KEEP"
Private Const MIN_NAME_LEN As Long = 10

' Entrypoints que NO se deben tocar (eventos, auto macros, etc.)
Private Function IsProtectedProcName(ByVal procName As String) As Boolean
    Dim n As String
    n = LCase$(procName)

    IsProtectedProcName = _
        (Left$(n, 9) = "workbook_") Or _
        (Left$(n, 10) = "worksheet_") Or _
        (Left$(n, 6) = "userform") Or _
        (n = "auto_open") Or (n = "auto_close") Or (n = "autoexec") Or (n = "autoclose")
End Function

' === Punto de entrada ===
Public Sub CAJA_NEGRA_COPIA()
    Dim srcPath As String, dstPath As String
    Dim wb As Workbook

    srcPath = PickXlsmFile()
    If Len(srcPath) = 0 Then Exit Sub

    dstPath = AddSuffixToPath(srcPath, "_BLACKBOX")

    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    On Error GoTo EH

    ' Abrir origen en RO, guardar copia y trabajar sobre la copia
    Workbooks.Open srcPath, ReadOnly:=True
    ActiveWorkbook.SaveCopyAs dstPath
    ActiveWorkbook.Close False

    Set wb = Workbooks.Open(dstPath, ReadOnly:=False)

    ' Procesar VBA Project
    BlackBoxProject wb

    wb.Save
    wb.Close False

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox "OK. Caja negra creada:" & vbCrLf & dstPath, vbInformation
    Exit Sub

EH:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "ERROR: " & Err.Description, vbCritical
End Sub

' ============================
' Proyecto: módulos + código
' ============================
Private Sub BlackBoxProject(ByVal wb As Workbook)
    Dim comps As VBIDE.VBComponents
    Dim c As VBIDE.VBComponent

    ' Necesario: referencia a VBIDE
    Set comps = wb.VBProject.VBComponents

    ' 1) Renombrar módulos (excepto ThisWorkbook / Sheets)
    For Each c In comps
        If c.Type = vbext_ct_StdModule Or c.Type = vbext_ct_ClassModule Then
            If LCase$(c.Name) <> LCase$(ThisWorkbook.VBProject.VBComponents(ThisWorkbook.CodeName).Name) Then
                ' No podemos detectar "módulo herramienta" dentro del destino,
                ' así que renombramos todos los módulos estándar/clase del archivo objetivo.
                SafeRenameComponent c
            End If
        End If
    Next c

    ' 2) Ofuscar código componente por componente
    For Each c In comps
        If c.Type = vbext_ct_StdModule Or c.Type = vbext_ct_ClassModule Or c.Type = vbext_ct_Document Then
            BlackBoxComponent c
        End If
    Next c
End Sub

Private Sub SafeRenameComponent(ByVal c As VBIDE.VBComponent)
    On Error Resume Next
    c.Name = "m" & RandomName(MIN_NAME_LEN)
    On Error GoTo 0
End Sub

Private Sub BlackBoxComponent(ByVal c As VBIDE.VBComponent)
    Dim code As String
    code = GetCode(c)
    If Len(code) = 0 Then Exit Sub

    ' 1) Limpieza de comentarios (líneas completas y trailing)
    code = RemoveCommentsSmart(code)

    ' 2) Construir mapa y renombrar:
    '    - Variables locales
    '    - Private Subs/Functions
    '    - NO tocar Public (para no romper botones/UI)
    Dim map As Object
    Set map = CreateObject("Scripting.Dictionary")

    BuildRenameMap code, map
    code = ApplyRenameMap(code, map)

    ' 3) Compactar espacios vacíos (opcional, reduce legibilidad)
    code = CompactBlankLines(code)

    SetCode c, code
End Sub

' ============================
' Lectura/escritura código
' ============================
Private Function GetCode(ByVal c As VBIDE.VBComponent) As String
    With c.CodeModule
        If .CountOfLines = 0 Then
            GetCode = ""
        Else
            GetCode = .Lines(1, .CountOfLines)
        End If
    End With
End Function

Private Sub SetCode(ByVal c As VBIDE.VBComponent, ByVal txt As String)
    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        If Len(txt) > 0 Then .AddFromString txt
    End With
End Sub

' ============================
' Comentarios: quitar sin romper strings
' ============================
Private Function RemoveCommentsSmart(ByVal src As String) As String
    Dim lines() As String, i As Long
    Dim out() As String, n As Long
    lines = Split(src, vbCrLf)
    ReDim out(UBound(lines))

    n = 0
    For i = LBound(lines) To UBound(lines)
        Dim ln As String
        ln = lines(i)

        ' Si la línea empieza por comentario, fuera
        If LCase$(Left$(Trim$(ln), Len("'" & TOOL_MARKER))) = "'" & LCase$(TOOL_MARKER) Then
            ' Por si quieres marcar líneas en tu fuente para preservarlas (opcional)
            out(n) = ln: n = n + 1
        ElseIf Left$(Trim$(ln), 1) = "'" Then
            ' eliminar
        Else
            out(n) = StripTrailingComment(ln)
            n = n + 1
        End If
    Next

    If n = 0 Then
        RemoveCommentsSmart = ""
    Else
        ReDim Preserve out(n - 1)
        RemoveCommentsSmart = Join(out, vbCrLf)
    End If
End Function

Private Function StripTrailingComment(ByVal ln As String) As String
    Dim i As Long, ch As String
    Dim inStr As Boolean

    inStr = False
    For i = 1 To Len(ln)
        ch = Mid$(ln, i, 1)
        If ch = """" Then inStr = Not inStr
        If (Not inStr) And ch = "'" Then
            StripTrailingComment = RTrim$(Left$(ln, i - 1))
            Exit Function
        End If
    Next
    StripTrailingComment = ln
End Function

' ============================
' Renombrado (conservador)
' ============================
Private Sub BuildRenameMap(ByVal code As String, ByVal map As Object)
    ' Renombra:
    '  - Private Sub/Function NOMBRE -> rXXXXXXXXXX
    '  - Variables en declaraciones Dim/Static (locales)
    '
    ' NO renombra Public ni eventos.

    Dim lines() As String, i As Long
    lines = Split(code, vbCrLf)

    For i = LBound(lines) To UBound(lines)
        Dim t As String
        t = Trim$(lines(i))
        If Len(t) = 0 Then GoTo NextLine

        Dim tl As String
        tl = LCase$(t)

        ' Private Sub/Function
        If Left$(tl, 8) = "private " Then
            If InStr(1, tl, "sub ", vbTextCompare) = 9 Then
                AddProcRename t, map, "sub"
            ElseIf InStr(1, tl, "function ", vbTextCompare) = 9 Then
                AddProcRename t, map, "function"
            End If
        End If

        ' Declaraciones locales: Dim / Static dentro de procedimientos
        ' (No podemos “saber” si estamos dentro por AST sin parser, pero es suficiente práctico)
        If Left$(tl, 4) = "dim " Or Left$(tl, 7) = "static " Then
            AddVarRenamesFromDeclaration t, map
        End If

NextLine:
    Next i
End Sub

Private Sub AddProcRename(ByVal lineText As String, ByVal map As Object, ByVal kind As String)
    Dim name As String
    name = ExtractProcName(lineText, kind)
    If Len(name) = 0 Then Exit Sub
    If IsProtectedProcName(name) Then Exit Sub

    If Not map.exists(name) Then
        map(name) = "p" & RandomName(MIN_NAME_LEN)
    End If
End Sub

Private Function ExtractProcName(ByVal lineText As String, ByVal kind As String) As String
    Dim s As String
    s = Trim$(lineText)

    ' s = "Private Sub X(..."
    Dim p As Long
    p = InStr(1, s, kind & " ", vbTextCompare)
    If p = 0 Then Exit Function

    s = Mid$(s, p + Len(kind) + 1) ' después de "sub " / "function "
    s = Trim$(s)

    ' hasta "(" o espacio
    Dim q As Long
    q = InStr(1, s, "(", vbTextCompare)
    If q > 0 Then
        ExtractProcName = Trim$(Left$(s, q - 1))
    Else
        ' sin paréntesis (raro)
        ExtractProcName = TakeWord(s)
    End If
End Function

Private Sub AddVarRenamesFromDeclaration(ByVal decl As String, ByVal map As Object)
    ' Soporta: Dim a As Long, b As String
    ' No renombra arrays complejos ni tipos definidos al 100%, pero cubre la mayoría.
    Dim s As String
    s = Trim$(decl)

    If LCase$(Left$(s, 4)) = "dim " Then s = Trim$(Mid$(s, 5))
    If LCase$(Left$(s, 7)) = "static " Then s = Trim$(Mid$(s, 8))

    Dim parts() As String, i As Long
    parts = Split(s, ",")

    For i = LBound(parts) To UBound(parts)
        Dim item As String, varName As String
        item = Trim$(parts(i))
        If Len(item) = 0 Then GoTo NextItem

        ' cortar en "As"
        Dim p As Long
        p = InStr(1, item, " As ", vbTextCompare)
        If p > 0 Then
            varName = Trim$(Left$(item, p - 1))
        Else
            varName = TakeWord(item)
        End If

        ' quitar () de arrays
        p = InStr(varName, "(")
        If p > 0 Then varName = Trim$(Left$(varName, p - 1))

        ' excluir dummy/keywords
        If Len(varName) = 0 Then GoTo NextItem
        If LCase$(varName) = "err" Then GoTo NextItem

        If Not map.exists(varName) Then
            map(varName) = "v" & RandomName(MIN_NAME_LEN)
        End If

NextItem:
    Next i
End Sub

Private Function ApplyRenameMap(ByVal code As String, ByVal map As Object) As String
    Dim k As Variant
    Dim result As String
    result = code

    ' Reemplazo conservador "palabra completa" fuera de strings
    For Each k In map.Keys
        result = ReplaceWholeWordSafe(result, CStr(k), CStr(map(k)))
    Next

    ApplyRenameMap = result
End Function

Private Function ReplaceWholeWordSafe(ByVal text As String, ByVal oldWord As String, ByVal newWord As String) As String
    Dim res As String, i As Long, ch As String
    Dim inStr As Boolean
    res = ""
    i = 1
    inStr = False

    Do While i <= Len(text)
        ch = Mid$(text, i, 1)

        If ch = """" Then
            inStr = Not inStr
            res = res & ch
            i = i + 1
        ElseIf Not inStr And IsWordChar(ch) Then
            Dim startPos As Long
            startPos = i
            Do While i <= Len(text) And IsWordChar(Mid$(text, i, 1))
                i = i + 1
            Loop

            Dim w As String
            w = Mid$(text, startPos, i - startPos)

            If StrComp(w, oldWord, vbTextCompare) = 0 Then
                res = res & newWord
            Else
                res = res & w
            End If
        Else
            res = res & ch
            i = i + 1
        End If
    Loop

    ReplaceWholeWordSafe = res
End Function

Private Function IsWordChar(ByVal ch As String) As Boolean
    Dim a As Long
    a = Asc(ch)
    IsWordChar = (a >= 48 And a <= 57) Or (a >= 65 And a <= 90) Or (a >= 97 And a <= 122) Or (ch = "_")
End Function

' ============================
' Compactación
' ============================
Private Function CompactBlankLines(ByVal src As String) As String
    Dim lines() As String, out() As String
    Dim i As Long, n As Long
    Dim lastBlank As Boolean

    lines = Split(src, vbCrLf)
    ReDim out(UBound(lines))
    n = 0
    lastBlank = False

    For i = LBound(lines) To UBound(lines)
        Dim t As String
        t = Trim$(lines(i))

        If Len(t) = 0 Then
            If Not lastBlank Then
                out(n) = ""
                n = n + 1
                lastBlank = True
            End If
        Else
            out(n) = lines(i)
            n = n + 1
            lastBlank = False
        End If
    Next

    If n = 0 Then
        CompactBlankLines = ""
    Else
        ReDim Preserve out(n - 1)
        CompactBlankLines = Join(out, vbCrLf)
    End If
End Function

' ============================
' Utilidades
' ============================
Private Function PickXlsmFile() As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = "Selecciona tu archivo .XLSM (origen)"
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled (*.xlsm)", "*.xlsm"
        If .Show <> -1 Then
            PickXlsmFile = ""
        Else
            PickXlsmFile = .SelectedItems(1)
        End If
    End With
End Function

Private Function AddSuffixToPath(ByVal fullPath As String, ByVal suffix As String) As String
    Dim p As Long
    p = InStrRev(fullPath, ".")
    If p > 0 Then
        AddSuffixToPath = Left$(fullPath, p - 1) & suffix & Mid$(fullPath, p)
    Else
        AddSuffixToPath = fullPath & suffix
    End If
End Function

Private Function RandomName(ByVal n As Long) As String
    Dim chars As String, i As Long
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    Randomize
    For i = 1 To n
        RandomName = RandomName & Mid$(chars, Int(Rnd * Len(chars)) + 1, 1)
    Next
End Function

Private Function TakeWord(ByVal s As String) As String
    Dim i As Long, ch As String
    s = Trim$(s)
    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)
        If Not IsWordChar(ch) Then
            TakeWord = Left$(s, i - 1)
            Exit Function
        End If
    Next
    TakeWord = s
End Function
