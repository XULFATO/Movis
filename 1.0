# =====================================================================
# üîç Buscador de literales en Blueprints (OpenXML en memoria, por fichero)
# - Pide RUTA BASE y hasta 10 LITERALES
# - Recorre: carpeta con '_' en 4¬™ pos. ‚Üí (2¬∫ nivel) ‚Üí "Documentaci√≥n Implantaci√≥n" ‚Üí "An√°lisis"
# - Ordena carpetas principales por FECHA DESC
# - Procesa CADA Blueprint EN EL MOMENTO (no acumula), con LOG paso a paso
# - Lee .xlsx/.xlsm en MEMORIA (ZipArchive + SharedStrings) sin Excel COM
# - No modifica nada; no cambia fechas; no deja ficheros temporales
# - Si no encuentra la hoja por nombre, puede buscar en todas las hojas (opcional)
# =====================================================================

$ErrorActionPreference = 'Stop'
Add-Type -AssemblyName System.IO.Compression.FileSystem

# ---------- Utilidades ----------
function Remove-Diacritics([string]$s){
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray() | Where-Object {
        [Globalization.CharUnicodeInfo]::GetUnicodeCategory($_) -ne [Globalization.UnicodeCategory]::NonSpacingMark
    }) -join ''
}
function Normalize([string]$s){ (Remove-Diacritics $s).ToLowerInvariant() }

function Ask-YesNo($prompt) {
    while ($true) {
        $r = Read-Host "$prompt (S/N)"
        if ($r -match '^[sS]$') { return $true }
        if ($r -match '^[nN]$') { return $false }
    }
}

# ---------- Lectura OpenXML ----------
function Get-SharedStrings {
    param([System.IO.Compression.ZipArchive]$zip)
    $entry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/sharedStrings.xml" }
    if (-not $entry){ return @() }
    $sr = New-Object IO.StreamReader($entry.Open())
    try {
        $xml = [xml]$sr.ReadToEnd()
    } finally { $sr.Dispose() }
    $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $sis = $xml.SelectNodes('//d:si',$ns)
    $list = New-Object System.Collections.Generic.List[string]
    foreach($si in $sis){
        $tNodes = $si.SelectNodes('.//d:t',$ns)
        if ($tNodes -and $tNodes.Count -gt 0){
            $list.Add( ($tNodes | ForEach-Object { $_.'#text' }) -join '' )
        } else {
            $list.Add([string]$si.InnerText)
        }
    }
    return ,$list
}

function Get-TargetSheetInfo {
    param([System.IO.Compression.ZipArchive]$zip)

    $wbEntry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/workbook.xml" }
    if (-not $wbEntry){ return $null }
    $sr = New-Object IO.StreamReader($wbEntry.Open()); $wbXml = $null
    try { $wbXml = [xml]$sr.ReadToEnd() } finally { $sr.Dispose() }

    $relsEntry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/_rels/workbook.xml.rels" }
    if (-not $relsEntry){ return $null }
    $sr2 = New-Object IO.StreamReader($relsEntry.Open()); $relsXml = $null
    try { $relsXml = [xml]$sr2.ReadToEnd() } finally { $sr2.Dispose() }

    $ns = New-Object System.Xml.XmlNamespaceManager($wbXml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $ns.AddNamespace('r','http://schemas.openxmlformats.org/officeDocument/2006/relationships')

    # 1) Buscar hoja por nombre: que contenga "analisis" y "concept"
    foreach($s in $wbXml.SelectNodes('//d:sheets/d:sheet',$ns)){
        $name = [string]$s.name
        $n = Normalize $name
        if ($n -match 'analisis' -and $n -match 'concept'){
            $rid = $s.'r:id'
            $relNode = $relsXml.SelectSingleNode("//Relationship[@Id='$rid']")
            if ($relNode){
                $t = [string]$relNode.Target
                if (-not $t.StartsWith("worksheets/")){ $t = "worksheets/$t" }
                return @{ Path = "xl/$t"; SheetName = $name }
            }
        }
    }

    # 2) Si no la encuentra, devuelve TODAS las hojas (para escaneo completo)
    $all = @()
    foreach($s in $wbXml.SelectNodes('//d:sheets/d:sheet',$ns)){
        $rid = $s.'r:id'
        $relNode = $relsXml.SelectSingleNode("//Relationship[@Id='$rid']")
        if ($relNode){
            $t = [string]$relNode.Target
            if (-not $t.StartsWith("worksheets/")){ $t = "worksheets/$t" }
            $all += ,(@{ Path = "xl/$t"; SheetName = [string]$s.name })
        }
    }
    if ($all.Count -gt 0){ return $all }
    return $null
}

function Read-SheetCells {
    param(
        [System.IO.Compression.ZipArchive]$zip,
        [string]$sheetPath,
        [System.Collections.Generic.List[string]]$sharedStrings
    )
    $entry = $zip.Entries | Where-Object { $_.FullName -ieq $sheetPath }
    if (-not $entry){ return @() }
    $sr = New-Object IO.StreamReader($entry.Open()); $xml = $null
    try { $xml = [xml]$sr.ReadToEnd() } finally { $sr.Dispose() }

    $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')

    $cells = $xml.SelectNodes('//d:worksheet/d:sheetData/d:row/d:c',$ns)
    $out = New-Object System.Collections.Generic.List[object]
    foreach($c in $cells){
        $addr = [string]$c.r
        $t    = [string]$c.t
        $valNode = $c.SelectSingleNode('d:v',$ns)
        $text = $null
        if ($t -eq 's'){
            if ($valNode){
                $idx = [int]$valNode.InnerText
                if ($idx -ge 0 -and $idx -lt $sharedStrings.Count){ $text = [string]$sharedStrings[$idx] }
            }
        } elseif ($t -eq 'inlineStr'){
            $tNodes = $c.SelectNodes('.//d:t',$ns)
            if ($tNodes){ $text = ($tNodes | ForEach-Object { $_.'#text' }) -join '' }
        } else {
            if ($valNode){ $text = [string]$valNode.InnerText }
        }

        if ($text -ne $null -and $text -ne ''){
            $out.Add([PSCustomObject]@{ Address = $addr; Text = $text })
        }
    }
    return ,$out
}

function Process-Blueprint {
    param(
        [string]$fullPath,
        [string[]]$literals,
        [bool]$stopAtFirst
    )

    # Abrir flujo y copiar a memoria (robusto en red)
    Write-Host "      üß© Abriendo flujo de lectura..." -ForegroundColor DarkCyan
    $fs = $null; $ms = $null; $zip = $null
    try {
        $fs = [System.IO.File]::Open($fullPath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
        $ms = New-Object System.IO.MemoryStream
        $fs.CopyTo($ms)
        $fs.Close()
        $ms.Position = 0

        Write-Host "      ‚úÖ Bytes cargados en memoria: $($ms.Length) bytes" -ForegroundColor Green

        $zip = New-Object System.IO.Compression.ZipArchive($ms, [System.IO.Compression.ZipArchiveMode]::Read, $false)

        $shared = Get-SharedStrings -zip $zip
        if ($shared.Count -eq 0) { Write-Host "      ‚ÑπÔ∏è  Sin sharedStrings o vac√≠o (ok)" -ForegroundColor DarkGray }

        $sheetInfo = Get-TargetSheetInfo -zip $zip
        if (-not $sheetInfo){ Write-Host "      ‚ö†Ô∏è No se encontraron hojas." -ForegroundColor DarkYellow; return @() }

        $hits = New-Object System.Collections.Generic.List[object]

        # Si devolvi√≥ una sola hoja (tipo Hashtable), la metemos en array para unificar
        $sheetsToScan = @()
        if ($sheetInfo -is [System.Collections.IEnumerable]) {
            $sheetsToScan = $sheetInfo
        } else {
            $sheetsToScan = @($sheetInfo)
        }

        foreach ($sh in $sheetsToScan){
            Write-Host ("      üîç Leyendo hoja '{0}'..." -f $sh.SheetName) -ForegroundColor Gray

            $cells = Read-SheetCells -zip $zip -sheetPath $sh.Path -sharedStrings $shared
            if ($cells.Count -eq 0) {
                Write-Host "         (hoja sin celdas legibles)" -ForegroundColor DarkGray
                continue
            }

            foreach ($lit in $literals){
                $needle = Normalize $lit
                foreach ($cell in $cells){
                    $v = Normalize $cell.Text
                    if ($v -like ("*"+$needle+"*")){
                        $hit = [PSCustomObject]@{
                            Fichero = $fullPath
                            Hoja    = $sh.SheetName
                            Literal = $lit
                            Celda   = $cell.Address
                            Valor   = $cell.Text
                        }
                        $hits.Add($hit)
                        Write-Host ("‚úÖ '{0}' ‚Üí Hoja '{1}' Celda {2}  ¬´{3}¬ª" -f $lit, $sh.SheetName, $cell.Address, $cell.Text) -ForegroundColor Green
                        if ($stopAtFirst) { return ,$hits }  # parar en la primera coincidencia global
                    }
                }
            }
        }

        return ,$hits
    }
    finally {
        if ($zip) { $zip.Dispose() }
        if ($ms)  { $ms.Dispose() }
        if ($fs)  { $fs.Dispose() }
    }
}

# ---------- Entradas del usuario ----------
Write-Host "üîç B√∫squeda de literales en hoja 'An√°lisis conceptos' (OpenXML en memoria)" -ForegroundColor Cyan
$basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`nIntroduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++){
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "‚ùå Sin literales."; exit }
$stopAtFirst = Ask-YesNo "¬øParar al encontrar la primera coincidencia?"

# ---------- Recorrido de carpetas ----------
$regexDocImpl = '(?i)(documentaci[o√≥]n\s+implantaci[o√≥]n)'
$regexAnalisis = '(?i)(an[a√°]lisis)'

Write-Host "`nüìÅ Recorriendo estructura (con '_' en 4¬™ posici√≥n, orden fecha desc.)..." -ForegroundColor DarkCyan

$results = New-Object System.Collections.Generic.List[object]

Get-ChildItem -Path $basePath -Directory |
  Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
  Sort-Object LastWriteTime -Descending |
  ForEach-Object {
    $dir1 = $_
    Write-Host ("‚Üí Revisando carpeta principal: {0}" -f $dir1.Name) -ForegroundColor Yellow

    # SEGUNDO NIVEL
    Get-ChildItem -Path $dir1.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $dir2 = $_

        # 01. Documentaci√≥n Implantaci√≥n
        $docDirs = Get-ChildItem -Path $dir2.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $regexDocImpl }
        foreach ($doc in $docDirs) {

            # 03. An√°lisis
            $anaDirs = Get-ChildItem -Path $doc.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $regexAnalisis }
            foreach ($ana in $anaDirs) {

                Write-Host ("   üìÇ Revisando subcarpeta: {0}" -f $ana.FullName) -ForegroundColor Cyan

                # Procesar EN EL ACTO cada Blueprint encontrado
                Get-ChildItem -Path $ana.FullName -File -ErrorAction SilentlyContinue |
                  Where-Object { $_.Name -notlike '~$*' -and $_.Name -match '(?i)Blueprint.*\.(xlsx|xlsm)$' } |
                  ForEach-Object {
                      $file = $_.FullName
                      Write-Host ("      üü¶ Detectado Blueprint: {0}" -f $file) -ForegroundColor Cyan

                      # Verificaci√≥n r√°pida de acceso
                      if (-not (Test-Path $file -PathType Leaf)) {
                          Write-Host "      ‚ö†Ô∏è Test-Path devolvi√≥ False (no se puede acceder realmente)." -ForegroundColor DarkYellow
                          return
                      }

                      try {
                          $hits = Process-Blueprint -fullPath $file -literals $literals -stopAtFirst $stopAtFirst
                          if ($hits -and $hits.Count -gt 0) {
                              $results.AddRange($hits)
                              if ($stopAtFirst) { throw "STOP_GLOBAL" }
                          } else {
                              Write-Host "      ‚ö™ Sin coincidencias en este Blueprint." -ForegroundColor Gray
                          }
                      }
                      catch {
                          if ($_.Exception.Message -eq "STOP_GLOBAL") { throw }
                          Write-Host ("      ‚ö†Ô∏è Error procesando: {0}" -f $_.Exception.Message) -ForegroundColor DarkYellow
                      }
                  }
            }
        }
    }
}

# ---------- Exportaci√≥n ----------
$outPath = Join-Path $env:USERPROFILE "Desktop\Resultados_Blueprint.xlsx"
if ($results.Count -gt 0) {
    try {
        # Exportaci√≥n v√≠a CSV + Excel (si disponible), con fallback a CSV
        $csv = Join-Path $env:TEMP "Resultados_Blueprint.csv"
        $results | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $csv
        try {
            $excel = New-Object -ComObject Excel.Application
            $excel.Visible = $false; $excel.DisplayAlerts = $false
            $wb = $excel.Workbooks.Open($csv)
            $wb.SaveAs($outPath, 51)
            $wb.Close($false)
            $excel.Quit()
            [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
            Remove-Item $csv -ErrorAction SilentlyContinue
            Write-Host "`n‚úÖ Resultados guardados en: $outPath" -ForegroundColor Green
        } catch {
            Write-Host "`n‚ÑπÔ∏è No se pudo crear XLSX; dejo CSV en: $csv" -ForegroundColor Yellow
        }
    } catch {
        Write-Host ("‚ö†Ô∏è Error exportando resultados: {0}" -f $_.Exception.Message) -ForegroundColor DarkYellow
    }
} else {
    Write-Host "`n‚ö™ No se encontraron coincidencias." -ForegroundColor Gray
}

Write-Host "`n‚úîÔ∏è Terminado." -ForegroundColor Green