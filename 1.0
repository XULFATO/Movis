' ============================================================================
' OFUSCADOR VBA ONE-WAY (NO REVERSIBLE)
' Inspirado en VBAD - Implementación 100% VBA
' Para entornos corporativos restringidos
' ============================================================================
' USO: Ejecutar RunOfuscador desde Excel con acceso a VBProject habilitado
' ============================================================================

Option Explicit

Private Const PREFIX_FUNC As String = "x_"
Private Const PREFIX_VAR As String = "v_"
Private Const CHARS_OFUSC As String = "abcdefghijklmnopqrstuvwxyz0123456789"

Private Type RenameMap
    Original As String
    Ofuscado As String
End Type

Private mRenameMaps() As RenameMap
Private mRenameCount As Long
Private mVarCounter As Long
Private mFuncCounter As Long

' ============================================================================
' PUNTO DE ENTRADA PRINCIPAL
' ============================================================================
Public Sub RunOfuscador()
    Dim srcPath As String
    Dim dstPath As String
    Dim wbDst As Workbook
    
    On Error GoTo ErrorHandler
    
    ' Seleccionar archivo origen
    srcPath = SeleccionarArchivo()
    If srcPath = "" Then
        MsgBox "Operación cancelada.", vbInformation
        Exit Sub
    End If
    
    ' Validar extensión
    If LCase(Right(srcPath, 5)) <> ".xlsm" And LCase(Right(srcPath, 5)) <> ".xlsb" Then
        MsgBox "Solo se admiten archivos .xlsm o .xlsb", vbExclamation
        Exit Sub
    End If
    
    ' Crear ruta destino
    dstPath = CrearRutaDestino(srcPath)
    
    ' Copiar archivo físicamente
    If Not CopiarArchivo(srcPath, dstPath) Then
        MsgBox "Error al copiar el archivo.", vbCritical
        Exit Sub
    End If
    
    ' Abrir copia con macros deshabilitadas
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    
    Set wbDst = AbrirArchivoSeguro(dstPath)
    If wbDst Is Nothing Then
        Application.EnableEvents = True
        Application.DisplayAlerts = True
        MsgBox "No se pudo abrir el archivo destino.", vbCritical
        Exit Sub
    End If
    
    ' Verificar acceso a VBProject
    If Not TieneAccesoVBProject(wbDst) Then
        wbDst.Close SaveChanges:=False
        Application.EnableEvents = True
        Application.DisplayAlerts = True
        MsgBox "No hay acceso al VBProject. Habilitar en:" & vbCrLf & _
               "Archivo > Opciones > Centro de confianza > " & vbCrLf & _
               "Configuración > Macros > Confiar en acceso al modelo de objetos VBA", vbCritical
        Exit Sub
    End If
    
    ' Inicializar contadores
    InicializarContadores
    
    ' FASE 1: Recolectar todos los identificadores a renombrar
    RecolectarIdentificadores wbDst
    
    ' FASE 2: Procesar cada módulo
    ProcesarTodosModulos wbDst
    
    ' Guardar y cerrar
    wbDst.Save
    wbDst.Close SaveChanges:=False
    
    Application.EnableEvents = True
    Application.DisplayAlerts = True
    
    MsgBox "Ofuscación completada:" & vbCrLf & dstPath, vbInformation
    Exit Sub

ErrorHandler:
    Application.EnableEvents = True
    Application.DisplayAlerts = True
    If Not wbDst Is Nothing Then
        On Error Resume Next
        wbDst.Close SaveChanges:=False
    End If
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical
End Sub

' ============================================================================
' SELECCIÓN Y COPIA DE ARCHIVOS
' ============================================================================
Private Function SeleccionarArchivo() As String
    Dim fd As Object
    Set fd = Application.FileDialog(3) ' msoFileDialogFilePicker
    
    With fd
        .Title = "Seleccionar archivo Excel con macros"
        .Filters.Clear
        .Filters.Add "Excel con macros", "*.xlsm;*.xlsb"
        .AllowMultiSelect = False
        
        If .Show = -1 Then
            SeleccionarArchivo = .SelectedItems(1)
        Else
            SeleccionarArchivo = ""
        End If
    End With
End Function

Private Function CrearRutaDestino(ByVal srcPath As String) As String
    Dim fso As Object
    Dim folder As String
    Dim baseName As String
    Dim ext As String
    
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    folder = fso.GetParentFolderName(srcPath)
    baseName = fso.GetBaseName(srcPath)
    ext = fso.GetExtensionName(srcPath)
    
    CrearRutaDestino = folder & "\" & baseName & "_BLACKBOX." & ext
End Function

Private Function CopiarArchivo(ByVal src As String, ByVal dst As String) As Boolean
    Dim fso As Object
    
    On Error GoTo ErrorHandler
    
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' Eliminar destino si existe
    If fso.FileExists(dst) Then
        fso.DeleteFile dst, True
    End If
    
    fso.CopyFile src, dst, True
    CopiarArchivo = True
    Exit Function

ErrorHandler:
    CopiarArchivo = False
End Function

Private Function AbrirArchivoSeguro(ByVal filePath As String) As Workbook
    Dim wb As Workbook
    
    On Error GoTo ErrorHandler
    
    ' Abrir sin ejecutar macros, sin actualizar links, sin notificaciones
    Set wb = Workbooks.Open( _
        Filename:=filePath, _
        UpdateLinks:=0, _
        ReadOnly:=False, _
        Notify:=False, _
        CorruptLoad:=xlNormalLoad)
    
    Set AbrirArchivoSeguro = wb
    Exit Function

ErrorHandler:
    Set AbrirArchivoSeguro = Nothing
End Function

Private Function TieneAccesoVBProject(ByVal wb As Workbook) As Boolean
    Dim test As Long
    
    On Error GoTo NoAccess
    test = wb.VBProject.VBComponents.Count
    TieneAccesoVBProject = True
    Exit Function

NoAccess:
    TieneAccesoVBProject = False
End Function

' ============================================================================
' INICIALIZACIÓN
' ============================================================================
Private Sub InicializarContadores()
    mRenameCount = 0
    mVarCounter = 0
    mFuncCounter = 0
    ReDim mRenameMaps(0 To 999)
End Sub

' ============================================================================
' FASE 1: RECOLECTAR IDENTIFICADORES
' ============================================================================
Private Sub RecolectarIdentificadores(ByVal wb As Workbook)
    Dim vbComp As Object
    Dim codeMod As Object
    Dim i As Long
    Dim linea As String
    
    For Each vbComp In wb.VBProject.VBComponents
        ' Solo módulos estándar y de clase (no UserForms completos)
        If vbComp.Type = 1 Or vbComp.Type = 2 Then ' vbext_ct_StdModule, vbext_ct_ClassModule
            Set codeMod = vbComp.CodeModule
            
            For i = 1 To codeMod.CountOfLines
                linea = codeMod.Lines(i, 1)
                RecolectarPrivateSubs linea
            Next i
        End If
    Next vbComp
End Sub

Private Sub RecolectarPrivateSubs(ByVal linea As String)
    Dim lineaTrim As String
    Dim nombre As String
    Dim posOpen As Long
    Dim posSpace As Long
    
    lineaTrim = UCase(Trim(linea))
    
    ' Buscar Private Sub / Private Function
    If Left(lineaTrim, 11) = "PRIVATE SUB" Then
        nombre = ExtraerNombreProcedimiento(linea, 11)
        If nombre <> "" And Not EsEventoReservado(nombre) Then
            AgregarRenameMap nombre, GenerarNombreOfuscado(PREFIX_FUNC)
        End If
        
    ElseIf Left(lineaTrim, 16) = "PRIVATE FUNCTION" Then
        nombre = ExtraerNombreProcedimiento(linea, 16)
        If nombre <> "" And Not EsEventoReservado(nombre) Then
            AgregarRenameMap nombre, GenerarNombreOfuscado(PREFIX_FUNC)
        End If
    End If
End Sub

Private Function ExtraerNombreProcedimiento(ByVal linea As String, ByVal offset As Long) As String
    Dim resto As String
    Dim posOpen As Long
    Dim posSpace As Long
    Dim nombre As String
    
    resto = Trim(Mid(linea, offset + 1))
    
    posOpen = InStr(resto, "(")
    posSpace = InStr(resto, " ")
    
    If posOpen > 0 Then
        nombre = Trim(Left(resto, posOpen - 1))
    ElseIf posSpace > 0 Then
        nombre = Trim(Left(resto, posSpace - 1))
    Else
        nombre = Trim(resto)
    End If
    
    ExtraerNombreProcedimiento = nombre
End Function

Private Function EsEventoReservado(ByVal nombre As String) As Boolean
    Dim n As String
    n = UCase(nombre)
    
    ' Eventos de Workbook
    If Left(n, 9) = "WORKBOOK_" Then EsEventoReservado = True: Exit Function
    
    ' Eventos de Worksheet
    If Left(n, 10) = "WORKSHEET_" Then EsEventoReservado = True: Exit Function
    
    ' Eventos de UserForm
    If Left(n, 9) = "USERFORM_" Then EsEventoReservado = True: Exit Function
    
    ' Eventos de clase
    If n = "CLASS_INITIALIZE" Or n = "CLASS_TERMINATE" Then EsEventoReservado = True: Exit Function
    
    ' Eventos de controles comunes (CommandButton, etc.)
    If InStr(n, "_CLICK") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_CHANGE") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_DBLCLICK") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_ENTER") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_EXIT") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_KEYDOWN") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_KEYUP") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_KEYPRESS") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_MOUSEDOWN") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_MOUSEUP") > 0 Then EsEventoReservado = True: Exit Function
    If InStr(n, "_MOUSEMOVE") > 0 Then EsEventoReservado = True: Exit Function
    
    EsEventoReservado = False
End Function

Private Sub AgregarRenameMap(ByVal original As String, ByVal ofuscado As String)
    Dim i As Long
    
    ' Verificar si ya existe
    For i = 0 To mRenameCount - 1
        If UCase(mRenameMaps(i).Original) = UCase(original) Then
            Exit Sub
        End If
    Next i
    
    ' Expandir array si es necesario
    If mRenameCount > UBound(mRenameMaps) Then
        ReDim Preserve mRenameMaps(0 To mRenameCount + 500)
    End If
    
    mRenameMaps(mRenameCount).Original = original
    mRenameMaps(mRenameCount).Ofuscado = ofuscado
    mRenameCount = mRenameCount + 1
End Sub

Private Function GenerarNombreOfuscado(ByVal prefix As String) As String
    Dim result As String
    Dim i As Long
    Dim idx As Long
    
    mFuncCounter = mFuncCounter + 1
    
    result = prefix
    For i = 1 To 8
        idx = Int(Rnd * Len(CHARS_OFUSC)) + 1
        result = result & Mid(CHARS_OFUSC, idx, 1)
    Next i
    result = result & mFuncCounter
    
    GenerarNombreOfuscado = result
End Function

Private Function GenerarNombreVariable() As String
    Dim result As String
    Dim i As Long
    Dim idx As Long
    
    mVarCounter = mVarCounter + 1
    
    result = PREFIX_VAR
    For i = 1 To 6
        idx = Int(Rnd * Len(CHARS_OFUSC)) + 1
        result = result & Mid(CHARS_OFUSC, idx, 1)
    Next i
    result = result & mVarCounter
    
    GenerarNombreVariable = result
End Function

' ============================================================================
' FASE 2: PROCESAR MÓDULOS
' ============================================================================
Private Sub ProcesarTodosModulos(ByVal wb As Workbook)
    Dim vbComp As Object
    
    For Each vbComp In wb.VBProject.VBComponents
        ' Solo módulos estándar y de clase
        If vbComp.Type = 1 Or vbComp.Type = 2 Then
            ProcesarModulo vbComp
        End If
    Next vbComp
End Sub

Private Sub ProcesarModulo(ByVal vbComp As Object)
    Dim codeMod As Object
    Dim allCode As String
    Dim lineas() As String
    Dim resultado As String
    Dim i As Long
    Dim lineaProcesada As String
    
    Set codeMod = vbComp.CodeModule
    
    If codeMod.CountOfLines = 0 Then Exit Sub
    
    ' Obtener todo el código
    allCode = codeMod.Lines(1, codeMod.CountOfLines)
    
    ' Dividir en líneas
    lineas = Split(allCode, vbCrLf)
    If UBound(lineas) = 0 And InStr(allCode, vbLf) > 0 Then
        lineas = Split(allCode, vbLf)
    End If
    
    ' Procesar línea por línea
    resultado = ""
    For i = 0 To UBound(lineas)
        lineaProcesada = ProcesarLinea(lineas(i))
        
        ' Eliminar líneas vacías consecutivas (compactar)
        If Trim(lineaProcesada) <> "" Or (i > 0 And Trim(lineas(i - 1)) <> "") Then
            If resultado <> "" Then resultado = resultado & vbCrLf
            resultado = resultado & lineaProcesada
        End If
    Next i
    
    ' Aplicar renombrado de Private Sub/Function
    resultado = AplicarRenombrados(resultado)
    
    ' Reemplazar código en el módulo
    codeMod.DeleteLines 1, codeMod.CountOfLines
    If Len(resultado) > 0 Then
        codeMod.AddFromString resultado
    End If
End Sub

Private Function ProcesarLinea(ByVal linea As String) As String
    Dim resultado As String
    Dim enString As Boolean
    Dim charActual As String
    Dim charAnterior As String
    Dim i As Long
    Dim posComentario As Long
    
    resultado = ""
    enString = False
    charAnterior = ""
    posComentario = 0
    
    ' Buscar comentarios fuera de strings
    For i = 1 To Len(linea)
        charActual = Mid(linea, i, 1)
        
        If charActual = """" Then
            enString = Not enString
        End If
        
        If Not enString Then
            ' Detectar comentario con '
            If charActual = "'" Then
                posComentario = i
                Exit For
            End If
            
            ' Detectar REM (debe estar al inicio o después de : )
            If UCase(Mid(linea, i, 4)) = "REM " Then
                If i = 1 Or Mid(linea, i - 1, 1) = ":" Or Trim(Left(linea, i - 1)) = "" Then
                    posComentario = i
                    Exit For
                End If
            End If
        End If
    Next i
    
    ' Quitar comentario si se encontró
    If posComentario > 0 Then
        resultado = Left(linea, posComentario - 1)
    Else
        resultado = linea
    End If
    
    ' Quitar espacios al final
    resultado = RTrim(resultado)
    
    ' Renombrar variables locales en declaraciones Dim
    resultado = ProcesarDeclaracionesDim(resultado)
    
    ProcesarLinea = resultado
End Function

Private Function ProcesarDeclaracionesDim(ByVal linea As String) As String
    Dim lineaTrim As String
    Dim resultado As String
    Dim partes() As String
    Dim i As Long
    Dim parte As String
    Dim nombreVar As String
    Dim posAs As Long
    Dim nuevoNombre As String
    
    lineaTrim = UCase(Trim(linea))
    
    ' Solo procesar líneas Dim (variables locales)
    If Left(lineaTrim, 4) <> "DIM " Then
        ProcesarDeclaracionesDim = linea
        Exit Function
    End If
    
    ' No procesar si parece ser nivel de módulo (heurística simple)
    ' Las variables de módulo típicamente están al inicio del módulo
    ' Aquí asumimos que si hay Dim, es local (conservador)
    
    resultado = linea
    ProcesarDeclaracionesDim = resultado
End Function

Private Function AplicarRenombrados(ByVal codigo As String) As String
    Dim i As Long
    Dim resultado As String
    
    resultado = codigo
    
    ' Aplicar cada renombrado
    For i = 0 To mRenameCount - 1
        resultado = ReemplazarIdentificador(resultado, _
                                            mRenameMaps(i).Original, _
                                            mRenameMaps(i).Ofuscado)
    Next i
    
    AplicarRenombrados = resultado
End Function

Private Function ReemplazarIdentificador(ByVal codigo As String, _
                                         ByVal original As String, _
                                         ByVal nuevo As String) As String
    Dim resultado As String
    Dim pos As Long
    Dim charAntes As String
    Dim charDespues As String
    Dim enString As Boolean
    Dim i As Long
    Dim checkPos As Long
    
    resultado = codigo
    pos = 1
    
    Do
        pos = InStr(pos, resultado, original, vbTextCompare)
        If pos = 0 Then Exit Do
        
        ' Verificar que no estamos dentro de un string
        enString = False
        For i = 1 To pos - 1
            If Mid(resultado, i, 1) = """" Then
                enString = Not enString
            End If
        Next i
        
        If enString Then
            pos = pos + 1
            GoTo ContinueLoop
        End If
        
        ' Verificar que es un identificador completo (no parte de otro)
        charAntes = ""
        charDespues = ""
        
        If pos > 1 Then charAntes = Mid(resultado, pos - 1, 1)
        If pos + Len(original) <= Len(resultado) Then
            charDespues = Mid(resultado, pos + Len(original), 1)
        End If
        
        ' Un identificador válido no debe tener letras/números/guión bajo adyacentes
        If EsCaracterIdentificador(charAntes) Or EsCaracterIdentificador(charDespues) Then
            pos = pos + 1
            GoTo ContinueLoop
        End If
        
        ' Realizar el reemplazo
        resultado = Left(resultado, pos - 1) & nuevo & Mid(resultado, pos + Len(original))
        pos = pos + Len(nuevo)
        
ContinueLoop:
    Loop
    
    ReemplazarIdentificador = resultado
End Function

Private Function EsCaracterIdentificador(ByVal c As String) As Boolean
    If Len(c) = 0 Then
        EsCaracterIdentificador = False
        Exit Function
    End If
    
    Dim code As Long
    code = Asc(UCase(c))
    
    ' A-Z
    If code >= 65 And code <= 90 Then EsCaracterIdentificador = True: Exit Function
    
    ' 0-9
    If code >= 48 And code <= 57 Then EsCaracterIdentificador = True: Exit Function
    
    ' Guión bajo
    If c = "_" Then EsCaracterIdentificador = True: Exit Function
    
    EsCaracterIdentificador = False
End Function

' ============================================================================
' UTILIDADES ADICIONALES
' ============================================================================
Public Sub MostrarMapeoGenerado()
    ' Utilidad para debug: muestra los renombrados realizados
    Dim i As Long
    Dim msg As String
    
    msg = "Mapeos generados:" & vbCrLf & vbCrLf
    
    For i = 0 To mRenameCount - 1
        msg = msg & mRenameMaps(i).Original & " -> " & mRenameMaps(i).Ofuscado & vbCrLf
        If i > 20 Then
            msg = msg & "... (+" & (mRenameCount - i - 1) & " más)"
            Exit For
        End If
    Next i
    
    MsgBox msg, vbInformation
End Sub
