# ==========================================================
# Buscar-Blueprints.ps1  (versi√≥n estable con limpieza de rutas)
# ==========================================================
# - Recorre carpetas con "_" en 4¬™ posici√≥n
# - Busca subcarpetas tipo "Documentaci√≥n Implantaci√≥n" -> "An√°lisis"
# - Abre en memoria los ficheros Blueprint .xlsx/.xlsm
# - Busca literales en la hoja "An√°lisis conceptos" (sin importar may√∫sculas ni tildes)
# - No toca fechas ni genera bloqueos en la red
# ==========================================================

$ErrorActionPreference = 'Stop'

# --- Funciones auxiliares ---
function Remove-Diacritics([string]$s) {
    if ([string]::IsNullOrEmpty($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    $sb = New-Object System.Text.StringBuilder
    foreach ($ch in $d.ToCharArray()) {
        if ([Globalization.CharUnicodeInfo]::GetUnicodeCategory($ch) -ne [Globalization.UnicodeCategory]::NonSpacingMark) {
            [void]$sb.Append($ch)
        }
    }
    $sb.ToString()
}
function Normalize([string]$s) { (Remove-Diacritics $s).ToLowerInvariant() }

function Get-SharedTextFromSiNode {
    param($siNode)
    $ns = New-Object System.Xml.XmlNamespaceManager($siNode.OwnerDocument.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $tNodes = $siNode.SelectNodes('.//d:t',$ns)
    if ($tNodes -and $tNodes.Count -gt 0) {
        ($tNodes | ForEach-Object { $_.'#text' }) -join ''
    } else {
        [string]$siNode.InnerText
    }
}

function Read-SharedStrings {
    param($zip)
    $entry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/sharedStrings.xml" }
    if (-not $entry) { return @() }
    $sr = New-Object IO.StreamReader($entry.Open())
    $xml = [xml]$sr.ReadToEnd()
    $sr.Dispose()
    $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $sis = $xml.SelectNodes('//d:si',$ns)
    $list = New-Object System.Collections.Generic.List[string]
    foreach ($n in $sis) { $list.Add((Get-SharedTextFromSiNode $n)) }
    return ,$list
}

function Get-SheetEntryPath {
    param($zip)
    $wbEntry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/workbook.xml" }
    if (-not $wbEntry) { return $null }
    $sr = New-Object IO.StreamReader($wbEntry.Open())
    $wbXml = [xml]$sr.ReadToEnd(); $sr.Dispose()
    $ns = New-Object System.Xml.XmlNamespaceManager($wbXml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $ns.AddNamespace('r','http://schemas.openxmlformats.org/officeDocument/2006/relationships')

    $targetSheetId = $null
    $targetSheetName = $null
    foreach ($s in $wbXml.SelectNodes('//d:sheets/d:sheet',$ns)) {
        $name = [string]$s.name
        $n = Normalize $name
        if ($n -match 'analisis' -and $n -match 'concept') {
            $targetSheetId = $s.'r:id'
            $targetSheetName = $name
            break
        }
    }
    if (-not $targetSheetId) { return $null }

    $relsEntry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/_rels/workbook.xml.rels" }
    if (-not $relsEntry) { return $null }
    $sr2 = New-Object IO.StreamReader($relsEntry.Open())
    $relsXml = [xml]$sr2.ReadToEnd(); $sr2.Dispose()
    $relNode = $relsXml.SelectSingleNode("//Relationship[@Id='$targetSheetId']")
    if (-not $relNode) { return $null }
    $target = [string]$relNode.Target
    if (-not $target.StartsWith("worksheets/")) { $target = "worksheets/$target" }
    return @{ Path = "xl/$target"; SheetName = $targetSheetName }
}

function Read-SheetCells {
    param($zip, $sheetPath, $shared)
    $entry = $zip.Entries | Where-Object { $_.FullName -ieq $sheetPath }
    if (-not $entry) { return @() }
    $sr = New-Object IO.StreamReader($entry.Open())
    $xml = [xml]$sr.ReadToEnd(); $sr.Dispose()
    $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $cells = $xml.SelectNodes('//d:worksheet/d:sheetData/d:row/d:c',$ns)
    $out = New-Object System.Collections.Generic.List[object]
    foreach ($c in $cells) {
        $addr = [string]$c.r
        $t = [string]$c.t
        $valNode = $c.SelectSingleNode('d:v',$ns)
        $text = $null
        if ($t -eq 's') {
            if ($valNode) {
                $idx = [int]$valNode.InnerText
                if ($idx -lt $shared.Count) { $text = [string]$shared[$idx] }
            }
        } elseif ($t -eq 'inlineStr') {
            $tNodes = $c.SelectNodes('.//d:t',$ns)
            if ($tNodes) { $text = ($tNodes | ForEach-Object { $_.'#text' }) -join '' }
        } else {
            if ($valNode) { $text = [string]$valNode.InnerText }
        }
        if ($text -ne $null -and $text -ne '') {
            $out.Add([PSCustomObject]@{ Address = $addr; Text = $text })
        }
    }
    return ,$out
}

function Ask-YesNo($prompt) {
    while ($true) {
        $r = Read-Host "$prompt (S/N)"
        if ($r -match '^[sS]$') { return $true }
        if ($r -match '^[nN]$') { return $false }
    }
}

Write-Host "üîç B√∫squeda de literales en hoja 'An√°lisis Conceptos'" -ForegroundColor Cyan

# --- Entrada de datos ---
$basePath = Read-Host "üìÇ Introduce la ruta base (por ejemplo O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`nIntroduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++) {
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "‚ùå Sin literales."; exit }

$stopAtFirst = Ask-YesNo "¬øParar al encontrar la primera coincidencia?"

# --- Recorre carpetas ---
$regexDocImpl = '(?i)(^\s*\d{0,3}\s*[-_. ]*\s*documentaci[o√≥]n\s+implantaci[o√≥]n\b)|(\bdocumentaci[o√≥]n\s+implantaci[o√≥]n\b)'
$regexAnalisis = '(?i)(^\s*\d{0,3}\s*[-_. ]*\s*an[a√°]lisis\b)|(\ban[a√°]lisis\b)'

Write-Host "`nüìÅ Recorriendo estructura (Doc. Implantaci√≥n / An√°lisis, orden desc.)..." -ForegroundColor DarkCyan
$files = @()

Get-ChildItem -Path $basePath -Directory |
  Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
  Sort-Object LastWriteTime -Descending |
  ForEach-Object {
    Write-Host ("‚Üí Revisando carpeta principal: {0}" -f $_.Name) -ForegroundColor Yellow
    Get-ChildItem -Path $_.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $docImplDirs = Get-ChildItem -Path $_.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $regexDocImpl }
        foreach ($docDir in $docImplDirs) {
            $analisisDirs = Get-ChildItem -Path $docDir.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $regexAnalisis }
            foreach ($anaDir in $analisisDirs) {
                Write-Host ("   üìÇ Revisando subcarpeta: {0}" -f $anaDir.FullName) -ForegroundColor Cyan
                $found = Get-ChildItem -Path $anaDir.FullName -File -ErrorAction SilentlyContinue |
                         Where-Object { $_.Name -notlike '~$*' -and $_.Name -match '(?i)Blueprint.*\.(xlsx|xlsm)$' }
                foreach ($f in $found) {
                    Write-Host ("      ‚úÖ Encontrado Blueprint: {0}" -f $f.Name) -ForegroundColor Green
                    $files += $f
                }
            }
        }
    }
}

if ($files.Count -eq 0) { Write-Host "‚ö†Ô∏è No se encontraron ficheros Blueprint."; exit }

# --- Lectura y b√∫squeda ---
$results = New-Object System.Collections.Generic.List[object]

foreach ($file in $files) {
    try {
        Write-Host ("      ‚è≥ Leyendo: {0}" -f $file.FullName) -ForegroundColor DarkGray

        # üß© Limpieza de ruta
        $pathClean = [System.IO.Path]::GetFullPath($file.FullName)
        $pathClean = $pathClean.TrimEnd(" ", ".")
        $bytes = [System.IO.File]::ReadAllBytes($pathClean)

        $ms = New-Object System.IO.MemoryStream(,$bytes)
        $zip = New-Object System.IO.Compression.ZipArchive($ms, [System.IO.Compression.ZipArchiveMode]::Read, $false)

        $sheetInfo = Get-SheetEntryPath -zip $zip
        if (-not $sheetInfo) {
            Write-Host ("      ‚ö†Ô∏è No se localiz√≥ hoja tipo 'An√°lisis Conceptos' en {0}" -f $file.Name) -ForegroundColor DarkYellow
            $zip.Dispose(); $ms.Dispose(); continue
        }

        $shared = Read-SharedStrings -zip $zip
        $cells  = Read-SheetCells -zip $zip -sheetPath $sheetInfo.Path -shared $shared

        $zip.Dispose(); $ms.Dispose()

        foreach ($lit in $literals) {
            $llow = Normalize $lit
            foreach ($cell in $cells) {
                $vnorm = Normalize $cell.Text
                if ($vnorm -like "*$llow*") {
                    Write-Host ("‚úÖ '{0}' encontrado en {1} ‚Üí {2}" -f $lit, $file.Name, $cell.Address) -ForegroundColor Green
                    $results.Add([PSCustomObject]@{
                        Fichero = $file.FullName
                        Hoja    = $sheetInfo.SheetName
                        Literal = $lit
                        Celda   = $cell.Address
                        Valor   = $cell.Text
                    })
                    if ($stopAtFirst) { throw "STOP_GLOBAL" }
                }
            }
        }
    }
    catch {
        if ($_.Exception.Message -eq "STOP_GLOBAL") { throw }
        Write-Host ("‚ö†Ô∏è Error leyendo {0}: {1}" -f $file.FullName, $_.Exception.Message) -ForegroundColor DarkYellow
    }
}

# --- Exportar resultados ---
$outPath = Join-Path $env:USERPROFILE "Desktop\Resultados_Blueprint.xlsx"
$csvPath = Join-Path $env:TEMP "Resultados_Blueprint.csv"

if ($results.Count -gt 0) {
    $results | Export-Csv -NoTypeInformation -Encoding UTF8 $csvPath
    try {
        $excel = New-Object -ComObject Excel.Application
        $excel.Visible = $false; $excel.DisplayAlerts = $false
        $wb = $excel.Workbooks.Open($csvPath)
        $wb.SaveAs($outPath, 51)
        $wb.Close($false)
        $excel.Quit()
        [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
        Remove-Item $csvPath -ErrorAction SilentlyContinue
        Write-Host "`n‚úÖ Terminado. Resultados guardados en: $outPath" -ForegroundColor Green
    }
    catch {
        Write-Host "`n‚úÖ Terminado. Dejo CSV en: $csvPath" -ForegroundColor Green
    }
}
else {
    Write-Host "`n‚ö™ No se encontraron coincidencias." -ForegroundColor Gray
}