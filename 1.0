# ==========================================================
# üîç OPCI√ìN 2 ‚Äî B√∫squeda Blueprint (sin Excel, Open XML)
# Basado en el mismo c√≥digo funcional, reemplazando COM.
# ==========================================================

Add-Type -AssemblyName System.IO.Compression.FileSystem
$ErrorActionPreference = "Stop"

Write-Host "üîç B√∫squeda de literales dentro de ficheros Blueprint (Open XML)" -ForegroundColor Cyan
$basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`n‚úèÔ∏è  Introduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++){
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "‚ùå Sin literales. Saliendo."; exit }

$stopAtFirst = Read-Host "¬øParar al encontrar la primera coincidencia? (S/N)"
$stopAtFirst = $stopAtFirst -match '^[sS]$'

function Normalize([string]$s){
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d=$s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray()|Where-Object{[Globalization.CharUnicodeInfo]::GetUnicodeCategory($_)-ne[Globalization.UnicodeCategory]::NonSpacingMark})-join''|ForEach-Object{$_}|Out-String|%{$_.Trim().ToLower()}
}

$reDoc = '(?i)(documentaci[o√≥]n\s+implantaci[o√≥]n)'
$reAna = '(?i)(an[a√°]lisis)'

Write-Host "`nüìÅ Recorriendo estructura..." -ForegroundColor DarkCyan
$blueprints = @()
Get-ChildItem -Path $basePath -Directory |
Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
Sort-Object LastWriteTime -Descending |
ForEach-Object {
    $dir1 = $_
    Write-Host "‚Üí Revisando carpeta principal: $($dir1.Name)" -ForegroundColor Yellow
    Get-ChildItem -Path $dir1.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $dir2 = $_
        $docDirs = Get-ChildItem -Path $dir2.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $reDoc }
        foreach ($doc in $docDirs) {
            $anaDirs = Get-ChildItem -Path $doc.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $reAna }
            foreach ($ana in $anaDirs) {
                $found = Get-ChildItem -Path $ana.FullName -File -ErrorAction SilentlyContinue | Where-Object { $_.Name -match '(?i)Blueprint.*\.xlsx$' -and $_.Name -notlike '~$*' }
                foreach ($f in $found) {
                    Write-Host "      ‚úÖ Encontrado Blueprint: $($f.Name)" -ForegroundColor Green
                    $blueprints += $f.FullName
                }
            }
        }
    }
}
if ($blueprints.Count -eq 0) { Write-Host "‚ö†Ô∏è No se encontraron Blueprints."; exit }

foreach ($path in $blueprints) {
    try {
        Write-Host "      ‚è≥ Analizando (OpenXML): $path" -ForegroundColor DarkGray
        $tmp = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), [System.IO.Path]::GetRandomFileName())
        [System.IO.Compression.ZipFile]::ExtractToDirectory($path, $tmp)

        $sheetFiles = Get-ChildItem (Join-Path $tmp "xl\worksheets") -Filter "*.xml"
        foreach ($sheet in $sheetFiles) {
            $xml = Get-Content $sheet.FullName -Raw
            $norm = (Normalize $xml)
            foreach ($lit in $literals) {
                if ($norm -like ("*" + (Normalize $lit) + "*")) {
                    Write-Host "‚úÖ '$lit' encontrado en hoja $($sheet.BaseName) de $(Split-Path $path -Leaf)" -ForegroundColor Green
                    if ($stopAtFirst) { throw "STOP_GLOBAL" }
                }
            }
        }

        Remove-Item -Path $tmp -Recurse -Force -ErrorAction SilentlyContinue
    }
    catch {
        if ($_.Exception.Message -eq "STOP_GLOBAL") { throw }
        Write-Host "‚ö†Ô∏è Error en $path : $($_.Exception.Message)" -ForegroundColor Yellow
    }
}
Write-Host "`n‚úîÔ∏è Proceso completado (OpenXML)." -ForegroundColor Green