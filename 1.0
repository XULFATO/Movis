# ==========================================================
# üîç OPCI√ìN 1 ‚Äî Versi√≥n Excel COM (parte del script funcional original)
# A√±ade logs üß© y ‚úÖ para detectar si Excel se abre correctamente.
# ==========================================================

$ErrorActionPreference = "Stop"

# ---------- ENTRADA ----------
Write-Host "üîç B√∫squeda de literales dentro de ficheros Blueprint (Excel COM)" -ForegroundColor Cyan
$basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`n‚úèÔ∏è  Introduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++){
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "‚ùå Sin literales. Saliendo."; exit }

$stopAtFirst = Read-Host "¬øParar al encontrar la primera coincidencia? (S/N)"
$stopAtFirst = $stopAtFirst -match '^[sS]$'

# ---------- FUNCIONES ----------
function Normalize([string]$s){
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d=$s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray()|Where-Object{[Globalization.CharUnicodeInfo]::GetUnicodeCategory($_)-ne[Globalization.UnicodeCategory]::NonSpacingMark})-join''|ForEach-Object{$_}|Out-String|%{$_.Trim().ToLower()}
}

# ---------- B√öSQUEDA DE BLUEPRINTS ----------
$reDoc = '(?i)(documentaci[o√≥]n\s+implantaci[o√≥]n)'
$reAna = '(?i)(an[a√°]lisis)'
Write-Host "`nüìÅ Recorriendo estructura..." -ForegroundColor DarkCyan

$blueprints = @()
Get-ChildItem -Path $basePath -Directory |
Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
Sort-Object LastWriteTime -Descending |
ForEach-Object {
    $dir1 = $_
    Write-Host "‚Üí Revisando carpeta principal: $($dir1.Name)" -ForegroundColor Yellow
    Get-ChildItem -Path $dir1.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $dir2 = $_
        $docDirs = Get-ChildItem -Path $dir2.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $reDoc }
        foreach ($doc in $docDirs) {
            $anaDirs = Get-ChildItem -Path $doc.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $reAna }
            foreach ($ana in $anaDirs) {
                Write-Host "   üìÇ Revisando subcarpeta: $($ana.FullName)" -ForegroundColor Cyan
                $found = Get-ChildItem -Path $ana.FullName -File -ErrorAction SilentlyContinue | Where-Object { $_.Name -match '(?i)Blueprint.*\.(xlsx|xlsm)$' -and $_.Name -notlike '~$*' }
                foreach ($f in $found) {
                    Write-Host "      ‚úÖ Encontrado Blueprint: $($f.Name)" -ForegroundColor Green
                    $blueprints += $f.FullName
                }
            }
        }
    }
}
if ($blueprints.Count -eq 0) { Write-Host "‚ö†Ô∏è No se encontraron Blueprints."; exit }

# ---------- LECTURA EXCEL ----------
$excel = $null
try {
    $excel = New-Object -ComObject Excel.Application
    $excel.Visible = $false
    $excel.DisplayAlerts = $false

    foreach ($path in $blueprints) {
        try {
            Write-Host "      ‚è≥ Abriendo (solo lectura): $path" -ForegroundColor DarkGray
            Write-Host "      üß© Intentando abrir Excel..." -ForegroundColor DarkCyan

            $wb = $excel.Workbooks.Open($path, 0, $true)
            Write-Host "      ‚úÖ Excel abierto correctamente." -ForegroundColor Green

            $sheet = $null
            foreach ($sh in $wb.Worksheets) {
                $n = Normalize $sh.Name
                if ($n -match 'analisis' -and $n -match 'concept') { $sheet = $sh; break }
            }

            if (-not $sheet) {
                Write-Host "‚ö†Ô∏è No hay hoja 'An√°lisis conceptos' en $(Split-Path $path -Leaf)" -ForegroundColor Yellow
                $wb.Close($false) | Out-Null
                continue
            }

            Write-Host "üîç Analizando hoja: $($sheet.Name)" -ForegroundColor Gray
            $used = $sheet.UsedRange
            $rows = $used.Rows.Count
            $cols = $used.Columns.Count

            for ($r=1; $r -le $rows; $r++) {
                for ($c=1; $c -le $cols; $c++) {
                    $txt = ""
                    try { $txt = [string]$used.Cells.Item($r,$c).Text } catch { continue }
                    if ([string]::IsNullOrWhiteSpace($txt)) { continue }
                    $v = Normalize $txt
                    foreach ($lit in $literals) {
                        if ($v -like ("*" + (Normalize $lit) + "*")) {
                            Write-Host "‚úÖ '$lit' en $(Split-Path $path -Leaf) ‚Üí R$r,C$c ('$txt')" -ForegroundColor Green
                            if ($stopAtFirst) { throw "STOP_GLOBAL" }
                        }
                    }
                }
            }

            $wb.Close($false) | Out-Null
        }
        catch {
            if ($_.Exception.Message -eq "STOP_GLOBAL") { throw }
            Write-Host "‚ö†Ô∏è Error con $(Split-Path $path -Leaf): $($_.Exception.Message)" -ForegroundColor Yellow
        }
    }
}
finally {
    if ($excel) { $excel.Quit(); [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null }
    Get-Process excel -ErrorAction SilentlyContinue | ForEach-Object { try { $_.Kill() } catch {} }
}

Write-Host "`n‚úîÔ∏è Proceso completado (Excel COM)." -ForegroundColor Green







# ==========================================================
# üîç OPCI√ìN 2 ‚Äî B√∫squeda Blueprint (sin Excel, Open XML)
# Basado en el mismo c√≥digo funcional, reemplazando COM.
# ==========================================================

Add-Type -AssemblyName System.IO.Compression.FileSystem
$ErrorActionPreference = "Stop"

Write-Host "üîç B√∫squeda de literales dentro de ficheros Blueprint (Open XML)" -ForegroundColor Cyan
$basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`n‚úèÔ∏è  Introduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++){
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "‚ùå Sin literales. Saliendo."; exit }

$stopAtFirst = Read-Host "¬øParar al encontrar la primera coincidencia? (S/N)"
$stopAtFirst = $stopAtFirst -match '^[sS]$'

function Normalize([string]$s){
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d=$s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray()|Where-Object{[Globalization.CharUnicodeInfo]::GetUnicodeCategory($_)-ne[Globalization.UnicodeCategory]::NonSpacingMark})-join''|ForEach-Object{$_}|Out-String|%{$_.Trim().ToLower()}
}

$reDoc = '(?i)(documentaci[o√≥]n\s+implantaci[o√≥]n)'
$reAna = '(?i)(an[a√°]lisis)'

Write-Host "`nüìÅ Recorriendo estructura..." -ForegroundColor DarkCyan
$blueprints = @()
Get-ChildItem -Path $basePath -Directory |
Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
Sort-Object LastWriteTime -Descending |
ForEach-Object {
    $dir1 = $_
    Write-Host "‚Üí Revisando carpeta principal: $($dir1.Name)" -ForegroundColor Yellow
    Get-ChildItem -Path $dir1.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $dir2 = $_
        $docDirs = Get-ChildItem -Path $dir2.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $reDoc }
        foreach ($doc in $docDirs) {
            $anaDirs = Get-ChildItem -Path $doc.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $reAna }
            foreach ($ana in $anaDirs) {
                $found = Get-ChildItem -Path $ana.FullName -File -ErrorAction SilentlyContinue | Where-Object { $_.Name -match '(?i)Blueprint.*\.xlsx$' -and $_.Name -notlike '~$*' }
                foreach ($f in $found) {
                    Write-Host "      ‚úÖ Encontrado Blueprint: $($f.Name)" -ForegroundColor Green
                    $blueprints += $f.FullName
                }
            }
        }
    }
}
if ($blueprints.Count -eq 0) { Write-Host "‚ö†Ô∏è No se encontraron Blueprints."; exit }

foreach ($path in $blueprints) {
    try {
        Write-Host "      ‚è≥ Analizando (OpenXML): $path" -ForegroundColor DarkGray
        $tmp = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), [System.IO.Path]::GetRandomFileName())
        [System.IO.Compression.ZipFile]::ExtractToDirectory($path, $tmp)

        $sheetFiles = Get-ChildItem (Join-Path $tmp "xl\worksheets") -Filter "*.xml"
        foreach ($sheet in $sheetFiles) {
            $xml = Get-Content $sheet.FullName -Raw
            $norm = (Normalize $xml)
            foreach ($lit in $literals) {
                if ($norm -like ("*" + (Normalize $lit) + "*