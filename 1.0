# ==========================================================
# C√ìDIGO 2 ‚Äî Buscar literales en Blueprints (Open XML, sin Excel)
# - Pide ruta y literales (hasta 10)
# - Mismo recorrido y logs
# - Abre .xlsx como ZIP en memoria y busca en hojas
# - Exporta resultados a XLSX/CSV
# ==========================================================

Add-Type -AssemblyName System.IO.Compression.FileSystem
$ErrorActionPreference = "Stop"

# ---------- ENTRADA ----------
Write-Host "üîç B√∫squeda de literales dentro de ficheros Blueprint (Open XML)" -ForegroundColor Cyan
$basePath = Read-Host "üìÇ Introduce la ruta base (p.ej. O:\ADP_SP\Clientes_Bob_LOPD)"
if (-not (Test-Path $basePath)) { Write-Host "‚ùå Ruta no v√°lida."; exit }

Write-Host "`n‚úèÔ∏è  Introduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++) {
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0) { Write-Host "‚ùå Sin literales. Saliendo."; exit }

$stopAtFirst = (Read-Host "¬øParar al encontrar la primera coincidencia? (S/N)") -match '^[sS]$'

# ---------- UTILIDADES ----------
function Remove-Diacritics([string]$s) {
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray() | Where-Object {
        [Globalization.CharUnicodeInfo]::GetUnicodeCategory($_) -ne [Globalization.UnicodeCategory]::NonSpacingMark
    }) -join ''
}
function Normalize([string]$s) { (Remove-Diacritics $s).ToLowerInvariant() }

# ---------- RECORRIDO ----------
$reDoc = '(?i)(documentaci[o√≥]n\s+implantaci[o√≥]n)'
$reAna = '(?i)(an[a√°]lisis)'

Write-Host "`nüìÅ Recorriendo estructura (orden por fecha desc.)..." -ForegroundColor DarkCyan

$blueprints = @()

Get-ChildItem -Path $basePath -Directory |
Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
Sort-Object LastWriteTime -Descending |
ForEach-Object {
    $dir1 = $_
    Write-Host "‚Üí Revisando carpeta principal: $($dir1.Name)" -ForegroundColor Yellow

    Get-ChildItem -Path $dir1.FullName -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $dir2 = $_

        $docDirs = Get-ChildItem -Path $dir2.FullName -Directory -ErrorAction SilentlyContinue |
                   Where-Object { $_.Name -match $reDoc }

        foreach ($doc in $docDirs) {
            $anaDirs = Get-ChildItem -Path $doc.FullName -Directory -ErrorAction SilentlyContinue |
                       Where-Object { $_.Name -match $reAna }

            foreach ($ana in $anaDirs) {
                Write-Host "   üìÇ Revisando subcarpeta: $($ana.FullName)" -ForegroundColor Cyan

                $found = Get-ChildItem -Path $ana.FullName -File -ErrorAction SilentlyContinue |
                         Where-Object { $_.Name -notlike '~$*' -and $_.Name -match '(?i)Blueprint.*\.xlsx$' }

                foreach ($f in $found) {
                    Write-Host "      ‚úÖ Encontrado Blueprint: $($f.Name)" -ForegroundColor Green
                    $blueprints += $f.FullName
                }
            }
        }
    }
}

if ($blueprints.Count -eq 0) { Write-Host "‚ö†Ô∏è No se encontraron Blueprints."; exit }

# ---------- LECTURA OPEN XML ----------
function Search-InWorksheetXml([string]$xmlContent, [string[]]$literals) {
    $norm = Normalize $xmlContent
    $hits = @()
    foreach ($lit in $literals) {
        $needle = Normalize $lit
        if ($norm -like ("*" + $needle + "*")) {
            $hits += $lit
        }
    }
    return $hits
}

$results = New-Object System.Collections.Generic.List[object]

foreach ($path in $blueprints) {
    try {
        Write-Host "      ‚è≥ Analizando (OpenXML): $path" -ForegroundColor DarkGray

        # Extrae a carpeta temporal (m√°s robusto en red que abrir ZipArchive directo)
        $tmp = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), [System.IO.Path]::GetRandomFileName())
        [System.IO.Compression.ZipFile]::ExtractToDirectory($path, $tmp)

        # Intentamos localizar una hoja que contenga "analisis" y "concept" en su nombre
        $workbookXmlPath = Join-Path $tmp "xl\workbook.xml"
        $targetWorksheets = @()

        if (Test-Path $workbookXmlPath) {
            $wbXml = [xml](Get-Content $workbookXmlPath -Raw)
            $ns = New-Object System.Xml.XmlNamespaceManager($wbXml.NameTable)
            $ns.AddNamespace("d","http://schemas.openxmlformats.org/spreadsheetml/2006/main")

            $sheets = $wbXml.SelectNodes("//d:sheets/d:sheet", $ns)
            foreach ($s in $sheets) {
                $sheetName = [string]$s.name
                $n = Normalize $sheetName
                if ($n -match "analisis" -and $n -match "concept") {
                    $targetWorksheets += @{ SheetId = $s.id; Name = $sheetName }
                }
            }

            # Si no encontramos por nombre, buscamos en todas las hojas
            if ($targetWorksheets.Count -eq 0) {
                foreach ($s in $sheets) {
                    $targetWorksheets += @{ SheetId = $s.id; Name = [string]$s.name }
                }
            }
        }

        # Mapa rels para hallar el path de cada hoja
        $relsPath = Join-Path $tmp "xl\_rels\workbook.xml.rels"
        $rels = $null
        if (Test-Path $relsPath) {
            $rels = [xml](Get-Content $relsPath -Raw)
        }

        foreach ($tw in $targetWorksheets) {
            $sheetPath = $null
            if ($rels) {
                $relNode = $rels.SelectSingleNode("//Relationship[@Id='$($tw.SheetId)']")
                if ($relNode) {
                    $t = [string]$relNode.Target
                    if (-not $t.StartsWith("worksheets/")) { $t = "worksheets/$t" }
                    $sheetPath = Join-Path $tmp ("xl\" + $t)
                }
            }
            if (-not $sheetPath) {
                # fallback: probar todas las hojas .xml
                $sheetPath = $null
            }

            if ($sheetPath -and (Test-Path $sheetPath)) {
                $xml = Get-Content $sheetPath -Raw
                $hits = Search-InWorksheetXml -xmlContent $xml -literals $literals
                foreach ($h in $hits) {
                    $results.Add([PSCustomObject]@{
                        Fichero = $path
                        Hoja    = $tw.Name
                        Literal = $h
                        Celda   = ""      # sin coordenada en este modo
                        Valor   = ""      # sin valor exacto reconstruido
                    })
                    Write-Host "‚úÖ '$h' en hoja '$($tw.Name)' de $(Split-Path $path -Leaf)" -ForegroundColor Green
                    if ($stopAtFirst) { throw "STOP_GLOBAL" }
                }
            } else {
                # Si no resolvimos la ruta exacta, escaneamos todas las hojas
                $allSheets = Get-ChildItem -Path (Join-Path $tmp "xl\worksheets") -Filter "*.xml" -ErrorAction SilentlyContinue
                foreach ($sf in $allSheets) {
                    $xml = Get-Content $sf.FullName -Raw
                    $hits = Search-InWorksheetXml -xmlContent $xml -literals $literals
                    foreach ($h in $hits) {
                        $results.Add([PSCustomObject]@{
                            Fichero = $path
                            Hoja    = $sf.BaseName
                            Literal = $h
                            Celda   = ""
                            Valor   = ""
                        })
                        Write-Host "‚úÖ '$h' en hoja '$($sf.BaseName)' de $(Split-Path $path -Leaf)" -ForegroundColor Green
                        if ($stopAtFirst) { throw "STOP_GLOBAL" }
                    }
                }
            }
        }

        Remove-Item -Path $tmp -Recurse -Force -ErrorAction SilentlyContinue
    } catch {
        if ($_.Exception.Message -eq "STOP_GLOBAL") { break }
        Write-Host "‚ö†Ô∏è Error con $path : $($_.Exception.Message)" -ForegroundColor Yellow
        try { Remove-Item -Path $tmp -Recurse -Force -ErrorAction SilentlyContinue } catch {}
        continue
    }
}

# ---------- EXPORTACI√ìN ----------
if ($results.Count -gt 0) {
    $outFile = Join-Path $env:USERPROFILE "Desktop\Resultados_Blueprint_OpenXML.xlsx"
    try {
        $excelOut = New-Object -ComObject Excel.Application
        $excelOut.Visible = $false; $excelOut.DisplayAlerts = $false
        $wbOut = $excelOut.Workbooks.Add()
        $ws = $wbOut.Worksheets.Item(1)
        $ws.Cells.Item(1,1) = "Fichero"
        $ws.Cells.Item(1,2) = "Hoja"
        $ws.Cells.Item(1,3) = "Literal"
        $ws.Cells.Item(1,4) = "Celda"
        $ws.Cells.Item(1,5) = "Valor"
        $row = 2
        foreach ($r in $results) {
            $ws.Cells.Item($row,1) = $r.Fichero
            $ws.Cells.Item($row,2) = $r.Hoja
            $ws.Cells.Item($row,3) = $r.Literal
            $ws.Cells.Item($row,4) = $r.Celda
            $ws.Cells.Item($row,5) = $r.Valor
            $row++
        }
        $ws.Range("A1:E1").Font.Bold = $true
        $ws.Columns.AutoFit() | Out-Null
        $wbOut.SaveAs($outFile)
        $wbOut.Close($false)
        $excelOut.Quit()
        [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excelOut) | Out-Null
        Write-Host "`n‚úÖ Resultados guardados en: $outFile" -ForegroundColor Green
    } catch {
        Write-Host "‚ö†Ô∏è No se pudo crear XLSX, exporto CSV en %TEMP%." -ForegroundColor Yellow
        $csv = Join-Path $env:TEMP "Resultados_Blueprint_OpenXML.csv"
        $results | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $csv
        Write-Host "üìÑ CSV: $csv" -ForegroundColor Green
    }
} else {
    Write-Host "`n‚ö™ No se encontraron coincidencias." -ForegroundColor Gray
}

Write-Host "`n‚úîÔ∏è Proceso completado (Open XML)." -ForegroundColor Green