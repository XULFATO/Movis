Option Explicit

' =============================================================================
' VBA Excel Workbook Obfuscator / Deobfuscator - VERSIÓN FUNCIONAL COMPLETA
'
' OFUSCAR:
'   - Ofusca strings literales "texto"
'   - Ofusca comentarios ' texto
'   - Inserta ruido VBA-legal
'   - Runtime decoder automático
'
' DESOFUSCAR:
'   - Restaura código 100% limpio original
'   - Sin tags, sin ruido, sin runtime
' =============================================================================

Private Const TAG_KEY As String = "'__OFUKEY__="
Private Const TAG_NOISE As String = "'__OFUNOISE__"
Private Const TAG_COMMENT As String = "'__OFUCOMMENT__:"
Private Const RUNTIME_MODULE_NAME As String = "z_ofu_runtime"
Private Const NOISE_RATE As Long = 5

' =============================================================================
' PUNTOS DE ENTRADA
' =============================================================================

Public Sub OFUSCAR_COPIA()
    ProcessWorkbook True
End Sub

Public Sub DESOFUSCAR_COPIA()
    ProcessWorkbook False
End Sub

' =============================================================================
' FLUJO PRINCIPAL
' =============================================================================

Private Sub ProcessWorkbook(ByVal doObfuscate As Boolean)
    Dim srcPath As String, dstPath As String
    Dim wbSrc As Workbook, wbDst As Workbook

    srcPath = PickXlsmFile()
    If Len(srcPath) = 0 Then Exit Sub

    If doObfuscate Then
        dstPath = AddSuffixToPath(srcPath, "_OFUSCADO")
    Else
        dstPath = AddSuffixToPath(srcPath, "_DESOFUSCADO")
    End If

    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    On Error GoTo ErrorHandler

    Set wbSrc = Workbooks.Open(srcPath, ReadOnly:=True)
    wbSrc.SaveCopyAs dstPath
    wbSrc.Close False

    Set wbDst = Workbooks.Open(dstPath, ReadOnly:=False)

    If doObfuscate Then
        EnsureRuntimeModule wbDst
        ObfuscateProject wbDst
    Else
        DeobfuscateProject wbDst
        RemoveRuntimeModule wbDst
    End If

    wbDst.Save
    wbDst.Close

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox IIf(doObfuscate, "OFUSCADO OK:", "DESOFUSCADO OK:") & vbCrLf & dstPath, vbInformation
    Exit Sub

ErrorHandler:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "Error: " & Err.Description, vbCritical
End Sub

' =============================================================================
' SELECCIÓN DE ARCHIVO
' =============================================================================

Private Function PickXlsmFile() As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = "Selecciona el archivo .XLSM"
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled (*.xlsm)", "*.xlsm"
        If .Show <> -1 Then
            PickXlsmFile = ""
        Else
            PickXlsmFile = .SelectedItems(1)
        End If
    End With
End Function

Private Function AddSuffixToPath(ByVal fullPath As String, ByVal suffix As String) As String
    Dim p As Long
    p = InStrRev(fullPath, ".")
    If p > 0 Then
        AddSuffixToPath = Left$(fullPath, p - 1) & suffix & Mid$(fullPath, p)
    Else
        AddSuffixToPath = fullPath & suffix
    End If
End Function

' =============================================================================
' GESTIÓN DEL MÓDULO RUNTIME
' =============================================================================

Private Sub EnsureRuntimeModule(ByVal wb As Workbook)
    Dim c As Object
    On Error Resume Next
    Set c = wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0

    If c Is Nothing Then
        Set c = wb.VBProject.VBComponents.Add(1)
        c.Name = RUNTIME_MODULE_NAME
    End If

    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        .AddFromString RuntimeCode()
    End With
End Sub

Private Sub RemoveRuntimeModule(ByVal wb As Workbook)
    On Error Resume Next
    wb.VBProject.VBComponents.Remove wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0
End Sub

Private Function RuntimeCode() As String
    RuntimeCode = _
        "Option Explicit" & vbCrLf & _
        vbCrLf & _
        "Public Function dDecode(ByVal hex4 As String, ByVal k As Long) As String" & vbCrLf & _
        "    Dim i As Long, v As Long, r As String" & vbCrLf & _
        "    For i = 1 To Len(hex4) Step 4" & vbCrLf & _
        "        v = CLng(""&H"" & Mid$(hex4, i, 4))" & vbCrLf & _
        "        r = r & ChrW$(v Xor k)" & vbCrLf & _
        "    Next i" & vbCrLf & _
        "    dDecode = r" & vbCrLf & _
        "End Function"
End Function

' =============================================================================
' PROCESAMIENTO DEL PROYECTO
' =============================================================================

Private Sub ObfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        If c.Name <> RUNTIME_MODULE_NAME Then
            code = GetCode(c)
            If Len(code) > 0 Then
                key = MakeKey()
                code = InjectDummyDeclarationOnce(code)
                code = ObfuscateCode(code, key)
                SetCode c, TAG_KEY & key & vbCrLf & code
            End If
        End If
    Next
End Sub

Private Sub DeobfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        code = GetCode(c)
        key = ExtractKey(code)
        If key > 0 Then
            code = DeobfuscateCode(code, key)
            SetCode c, code
        End If
    Next
End Sub

' =============================================================================
' LECTURA Y ESCRITURA
' =============================================================================

Private Function GetCode(ByVal c As Object) As String
    With c.CodeModule
        If .CountOfLines = 0 Then
            GetCode = ""
        Else
            GetCode = .Lines(1, .CountOfLines)
        End If
    End With
End Function

Private Sub SetCode(ByVal c As Object, ByVal txt As String)
    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        If Len(txt) > 0 Then .AddFromString txt
    End With
End Sub

' =============================================================================
' INYECCIÓN DE VARIABLE DUMMY
' =============================================================================

Private Function InjectDummyDeclarationOnce(ByVal code As String) As String
    Dim lines() As String, i As Long, out As String
    Dim injected As Boolean
    
    lines = Split(code, vbCrLf)
    injected = False

    For i = LBound(lines) To UBound(lines)
        Dim trimLine As String
        trimLine = LCase$(Trim$(lines(i)))
        
        If i > LBound(lines) Then out = out & vbCrLf
        out = out & lines(i)

        If Not injected Then
            If trimLine Like "sub *" Or trimLine Like "public sub *" Or _
               trimLine Like "private sub *" Or trimLine Like "function *" Or _
               trimLine Like "public function *" Or trimLine Like "private function *" Then
                out = out & vbCrLf & "    Dim ofuDummy As Long"
                injected = True
            End If
        End If
    Next i

    InjectDummyDeclarationOnce = out
End Function

' =============================================================================
' OFUSCACIÓN DE CÓDIGO
' =============================================================================

Private Function ObfuscateCode(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long, out As String
    lines = Split(src, vbCrLf)

    For i = LBound(lines) To UBound(lines)
        If i > LBound(lines) Then out = out & vbCrLf
        out = out & ObfuscateLine(lines(i), key)
        
        If NOISE_RATE > 0 And i Mod NOISE_RATE = 0 And i > LBound(lines) Then
            out = out & vbCrLf & TAG_NOISE
            out = out & vbCrLf & "If False Then"
            out = out & vbCrLf & "    ofuDummy = 0"
            out = out & vbCrLf & "End If"
        End If
    Next

    ObfuscateCode = out
End Function

' =============================================================================
' OFUSCACIÓN DE LÍNEA (STRINGS + COMENTARIOS)
' =============================================================================

Private Function ObfuscateLine(ByVal ln As String, ByVal key As Long) As String
    Dim result As String, commentPos As Long
    Dim beforeComment As String, commentText As String
    
    result = ln
    
    ' 1. BUSCAR COMENTARIO (fuera de strings)
    commentPos = FindCommentPosition(result)
    
    If commentPos > 0 Then
        beforeComment = Left$(result, commentPos - 1)
        commentText = Mid$(result, commentPos + 1) ' Sin el '
        
        ' Ofuscar strings en la parte de código
        beforeComment = ReplaceStrings(beforeComment, key)
        
        ' Ofuscar comentario (guardar HEX después del tag)
        result = beforeComment & TAG_COMMENT & ToHex4(commentText, key)
    Else
        ' Solo ofuscar strings
        result = ReplaceStrings(result, key)
    End If
    
    ObfuscateLine = result
End Function

' Encuentra posición del comentario (fuera de strings)
Private Function FindCommentPosition(ByVal ln As String) As Long
    Dim i As Long, inString As Boolean
    FindCommentPosition = 0
    inString = False
    
    For i = 1 To Len(ln)
        If Mid$(ln, i, 1) = """" Then
            inString = Not inString
        ElseIf Mid$(ln, i, 1) = "'" And Not inString Then
            FindCommentPosition = i
            Exit Function
        End If
    Next
End Function

' Ofusca strings literales "texto"
Private Function ReplaceStrings(ByVal ln As String, ByVal key As Long) As String
    Dim p1 As Long, p2 As Long, s As String, result As String
    
    result = ln
    
    Do
        p1 = InStr(result, """")
        If p1 = 0 Then Exit Do
        
        p2 = InStr(p1 + 1, result, """")
        If p2 = 0 Then Exit Do
        
        s = Mid$(result, p1 + 1, p2 - p1 - 1)
        
        If Len(s) > 0 Then
            result = Left$(result, p1 - 1) & _
                     "dDecode(""" & ToHex4(s, key) & """," & key & ")" & _
                     Mid$(result, p2 + 1)
        Else
            ' String vacío ""
            result = Left$(result, p2) & Mid$(result, p2 + 1)
        End If
    Loop
    
    ReplaceStrings = result
End Function

' =============================================================================
' DESOFUSCACIÓN DE CÓDIGO
' =============================================================================

Private Function DeobfuscateCode(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long, out As String
    Dim trimLine As String, skipNext As Long
    
    lines = Split(src, vbCrLf)
    skipNext = 0

    For i = LBound(lines) To UBound(lines)
        trimLine = Trim$(lines(i))
        
        If skipNext > 0 Then
            skipNext = skipNext - 1
            GoTo NextLine
        End If
        
        ' Filtrar tags y ruido
        If InStr(lines(i), TAG_KEY) = 1 Then GoTo NextLine
        If InStr(lines(i), TAG_NOISE) = 1 Then
            skipNext = 2
            GoTo NextLine
        End If
        If trimLine = "If False Then" Then GoTo NextLine
        If trimLine = "End If" Then GoTo NextLine
        If InStr(trimLine, "Dim ofuDummy") > 0 Then GoTo NextLine
        
        ' Restaurar línea
        If i > LBound(lines) And Len(out) > 0 Then out = out & vbCrLf
        out = out & RestoreLine(lines(i), key)
        
NextLine:
    Next

    DeobfuscateCode = out
End Function

' =============================================================================
' RESTAURACIÓN DE LÍNEA (STRINGS + COMENTARIOS)
' =============================================================================

Private Function RestoreLine(ByVal ln As String, ByVal key As Long) As String
    Dim result As String
    result = ln
    
    ' 1. Restaurar comentarios PRIMERO
    result = RestoreComments(result, key)
    
    ' 2. Restaurar strings
    result = RestoreStrings(result, key)
    
    RestoreLine = result
End Function

Private Function RestoreComments(ByVal ln As String, ByVal key As Long) As String
    Dim p As Long, hexStr As String, original As String
    Dim result As String
    
    result = ln
    
    ' Buscar tag de comentario
    p = InStr(result, TAG_COMMENT)
    If p > 0 Then
        ' Extraer HEX después del tag
        hexStr = Mid$(result, p + Len(TAG_COMMENT))
        
        ' Decodificar
        original = FromHex4(hexStr, key)
        
        ' Reconstruir con comentario original
        result = Left$(result, p - 1) & "'" & original
    End If
    
    RestoreComments = result
End Function

Private Function RestoreStrings(ByVal ln As String, ByVal key As Long) As String
    Dim p1 As Long, p2 As Long, pEnd As Long
    Dim hexStr As String, original As String, result As String
    
    result = ln
    
    Do
        p1 = InStr(result, "dDecode(""")
        If p1 = 0 Then Exit Do
        
        p2 = InStr(p1 + 10, result, """")
        If p2 = 0 Then Exit Do
        
        pEnd = InStr(p2, result, ")")
        If pEnd = 0 Then Exit Do
        
        hexStr = Mid$(result, p1 + 9, p2 - p1 - 9)
        original = FromHex4(hexStr, key)
        
        result = Left$(result, p1 - 1) & """" & original & """" & Mid$(result, pEnd + 1)
    Loop
    
    RestoreStrings = result
End Function

' =============================================================================
' CODIFICACIÓN / DECODIFICACIÓN HEX4 (CORREGIDO)
' =============================================================================

Private Function ToHex4(ByVal s As String, ByVal k As Long) As String
    Dim i As Long, r As String, charCode As Long
    
    For i = 1 To Len(s)
        charCode = AscW(Mid$(s, i, 1)) Xor k
        r = r & Right$("0000" & Hex$(charCode), 4)
    Next
    
    ToHex4 = r
End Function

Private Function FromHex4(ByVal hex4 As String, ByVal k As Long) As String
    Dim i As Long, v As Long, r As String
    
    ' Validar longitud
    If Len(hex4) Mod 4 <> 0 Then
        FromHex4 = ""
        Exit Function
    End If
    
    For i = 1 To Len(hex4) Step 4
        On Error Resume Next
        v = CLng("&H" & Mid$(hex4, i, 4))
        If Err.Number = 0 Then
            r = r & ChrW$(v Xor k)
        End If
        On Error GoTo 0
    Next
    
    FromHex4 = r
End Function

' =============================================================================
' UTILIDADES
' =============================================================================

Private Function MakeKey() As Long
    Randomize
    MakeKey = CLng(Rnd * 65534) + 1
End Function

Private Function ExtractKey(ByVal src As String) As Long
    Dim p As Long, e As Long, s As String
    
    p = InStr(src, TAG_KEY)
    If p = 0 Then Exit Function
    
    e = InStr(p, src, vbCrLf)
    If e = 0 Then e = Len(src) + 1
    
    s = Trim$(Mid$(src, p + Len(TAG_KEY), e - p - Len(TAG_KEY)))
    
    If IsNumeric(s) Then ExtractKey = CLng(s)
End Function
