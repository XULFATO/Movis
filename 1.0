# ==========================================================
# Buscar-Blueprints.ps1  (Open XML + red: FileShare.ReadWrite + ruta larga)
# ==========================================================
$ErrorActionPreference = 'Stop'

function Remove-Diacritics([string]$s){
    if ([string]::IsNullOrEmpty($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    $sb = New-Object System.Text.StringBuilder
    foreach ($ch in $d.ToCharArray()){
        if ([Globalization.CharUnicodeInfo]::GetUnicodeCategory($ch) -ne [Globalization.UnicodeCategory]::NonSpacingMark){
            [void]$sb.Append($ch)
        }
    }
    $sb.ToString()
}
function Normalize([string]$s){ (Remove-Diacritics $s).ToLowerInvariant() }

# ---- Rutas largas/UNC ----
function To-LongPath([string]$path) {
    if ($path -match '^[A-Za-z]:\\') { return "\\?\$path" }           # unidad local
    if ($path -match '^(\\\\)')       { return $path -replace '^\\\\', '\\?\UNC\' } # UNC -> \\?\UNC\
    return $path
}

# ---- ZIP v√≠a FileStream (red) con FileShare.ReadWrite + reintentos ----
Add-Type -AssemblyName System.IO.Compression.FileSystem | Out-Null
function Open-ZipArchiveShared {
    param([string]$fullPath, [int]$retries=3, [int]$delayMs=250)
    $lp = To-LongPath $fullPath
    for ($i=0; $i -lt $retries; $i++) {
        try {
            $fs = [System.IO.File]::Open($lp, [IO.FileMode]::Open, [IO.FileAccess]::Read, [IO.FileShare]::ReadWrite)
            $zip = New-Object System.IO.Compression.ZipArchive($fs, [System.IO.Compression.ZipArchiveMode]::Read, $false)
            return @{ Zip = $zip; Stream = $fs }
        } catch {
            if ($i -eq ($retries-1)) { throw $_ }
            Start-Sleep -Milliseconds $delayMs
        }
    }
}

# ---- SharedStrings ----
function Get-SharedTextFromSiNode {
    param($siNode)
    $ns = New-Object System.Xml.XmlNamespaceManager($siNode.OwnerDocument.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $tNodes = $siNode.SelectNodes('.//d:t',$ns)
    if ($tNodes -and $tNodes.Count -gt 0){
        ($tNodes | ForEach-Object { $_.'#text' }) -join ''
    } else {
        [string]$siNode.InnerText
    }
}
function Read-SharedStrings {
    param($zip)
    $entry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/sharedStrings.xml" }
    if (-not $entry){ return @() }
    $sr = New-Object IO.StreamReader($entry.Open())
    $xml = [xml]$sr.ReadToEnd()
    $sr.Dispose()

    $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $sis = $xml.SelectNodes('//d:si',$ns)
    $list = New-Object System.Collections.Generic.List[string]
    foreach($n in $sis){ $list.Add( (Get-SharedTextFromSiNode $n) ) }
    return ,$list
}

# ---- workbook.xml + rels -> localizar sheet por nombre (analisis + concept) ----
function Get-SheetEntryPath {
    param($zip)

    $wbEntry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/workbook.xml" }
    if (-not $wbEntry){ return $null }
    $sr = New-Object IO.StreamReader($wbEntry.Open())
    $wbXml = [xml]$sr.ReadToEnd(); $sr.Dispose()

    $ns = New-Object System.Xml.XmlNamespaceManager($wbXml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')
    $ns.AddNamespace('r','http://schemas.openxmlformats.org/officeDocument/2006/relationships')

    $targetSheetId = $null
    $targetSheetName = $null
    foreach($s in $wbXml.SelectNodes('//d:sheets/d:sheet',$ns)){
        $name = [string]$s.name
        $n = Normalize $name
        if ($n -match 'analisis' -and $n -match 'concept'){
            $targetSheetId = $s.'r:id'
            $targetSheetName = $name
            break
        }
    }
    if (-not $targetSheetId){ return $null }

    $relsEntry = $zip.Entries | Where-Object { $_.FullName -ieq "xl/_rels/workbook.xml.rels" }
    if (-not $relsEntry){ return $null }
    $sr2 = New-Object IO.StreamReader($relsEntry.Open())
    $relsXml = [xml]$sr2.ReadToEnd(); $sr2.Dispose()

    $relNode = $relsXml.SelectSingleNode("//Relationship[@Id='$targetSheetId']")
    if (-not $relNode){ return $null }
    $target = [string]$relNode.Target
    if (-not $target.StartsWith("worksheets/")){ $target = "worksheets/$target" }
    return @{ Path = "xl/$target"; SheetName = $targetSheetName }
}

# ---- Lee cells de la hoja (resuelve shared strings e inlineStr) ----
function Read-SheetCells {
    param($zip, $sheetPath, $shared)

    $entry = $zip.Entries | Where-Object { $_.FullName -ieq $sheetPath }
    if (-not $entry){ return @() }
    $sr = New-Object IO.StreamReader($entry.Open())
    $xml = [xml]$sr.ReadToEnd(); $sr.Dispose()

    $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
    $ns.AddNamespace('d','http://schemas.openxmlformats.org/spreadsheetml/2006/main')

    $cells = $xml.SelectNodes('//d:worksheet/d:sheetData/d:row/d:c',$ns)
    $out = New-Object System.Collections.Generic.List[object]
    foreach($c in $cells){
        $addr = [string]$c.r
        $t    = [string]$c.t
        $valNode = $c.SelectSingleNode('d:v',$ns)
        $text = $null

        if ($t -eq 's'){
            if ($valNode){
                $idx = [int]$valNode.InnerText
                if ($idx -lt $shared.Count){ $text = [string]$shared[$idx] }
            }
        } elseif ($t -eq 'inlineStr') {
            $tNodes = $c.SelectNodes('.//d:t',$ns)
            if ($tNodes){ $text = ($tNodes | ForEach-Object { $_.'#text' }) -join '' }
        } else {
            if ($valNode){ $text = [string]$valNode.InnerText }
        }

        if ($text -ne $null -and $text -ne ''){
            $out.Add([PSCustomObject]@{ Address = $addr; Text = $text })
        }
    }
    return ,$out
}

function Ask-YesNo($prompt) {
    while ($true) {
        $r = Read-Host "$prompt (S/N)"
        if ($r -match '^[sS]$') { return $true }
        if ($r -match '^[nN]$') { return $false }
    }
}

Write-Host "üîç B√∫squeda de literales Open XML (compatible red, sin copiar archivos)" -ForegroundColor Cyan

# -------- Entrada --------
$basePath = Read-Host "üìÇ Introduce la ruta base"
if (-not (Test-Path $basePath)){ Write-Host "‚ùå Ruta no v√°lida." -ForegroundColor Red; exit }

Write-Host "`nIntroduce hasta 10 literales (uno por l√≠nea). Deja vac√≠o para terminar." -ForegroundColor Yellow
$literals = @()
for ($i=1; $i -le 10; $i++){
    $lit = Read-Host ("Literal #{0}" -f $i)
    if ([string]::IsNullOrWhiteSpace($lit)) { break }
    $literals += $lit
}
if ($literals.Count -eq 0){ Write-Host "‚ùå Sin literales." -ForegroundColor Red; exit }
$stopAtFirst = Ask-YesNo "¬øParar al encontrar la primera coincidencia?"

# -------- Recorrido (igual que el tuyo) --------
$regexDocImpl = '(?i)(^\s*\d{0,3}\s*[-_. ]*\s*documentaci[o√≥]n\s+implantaci[o√≥]n\b)|(\bdocumentaci[o√≥]n\s+implantaci[o√≥]n\b)'
$regexAnalisis = '(?i)(^\s*\d{0,3}\s*[-_. ]*\s*an[a√°]lisis\b)|(\ban[a√°]lisis\b)'

Write-Host "`nüìÅ Recorriendo estructura (con '_' en 4¬™ posici√≥n, Doc. Implantaci√≥n/An√°lisis, orden desc.)..." -ForegroundColor DarkCyan
$files = @()

Get-ChildItem -Path $basePath -Directory |
  Where-Object { $_.Name.Length -ge 4 -and $_.Name[3] -eq '_' } |
  Sort-Object LastWriteTime -Descending |
  ForEach-Object {
    $nivel1 = $_.FullName
    Write-Host ("‚Üí Revisando carpeta principal: {0}" -f $_.Name) -ForegroundColor Yellow

    Get-ChildItem -Path $nivel1 -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $nivel2 = $_.FullName

        $docImplDirs = Get-ChildItem -Path $nivel2 -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $regexDocImpl }
        foreach ($docDir in $docImplDirs) {
            $analisisDirs = Get-ChildItem -Path $docDir.FullName -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match $regexAnalisis }
            foreach ($anaDir in $analisisDirs) {
                Write-Host ("   üìÇ Revisando subcarpeta: {0}" -f $anaDir.FullName) -ForegroundColor Cyan
                $found = Get-ChildItem -Path $anaDir.FullName -File -ErrorAction SilentlyContinue |
                         Where-Object { $_.Name -notlike '~$*' -and $_.Name -match '(?i)Blueprint.*\.(xlsx|xlsm|xls)$' }
                if ($found) {
                    foreach ($f in $found) {
                        Write-Host ("      ‚úÖ Encontrado Blueprint: {0}" -f $f.Name) -ForegroundColor Green
                    }
                    $files += $found
                }
            }
        }
    }
}

if ($files.Count -eq 0){ Write-Host "‚ö†Ô∏è No se encontraron ficheros 'Blueprint'." -ForegroundColor DarkYellow; exit 0 }
Write-Host ("   ‚Üí {0} ficheros 'Blueprint' detectados." -f $files.Count) -ForegroundColor Green

# -------- B√∫squeda Open XML con stream compartido --------
$results = New-Object System.Collections.Generic.List[object]

foreach ($file in $files){
    if ($file.Extension -notmatch '^\.(xlsx|xlsm)$') {
        Write-Host ("      ‚ö†Ô∏è {0} es .xls (binario). Se omite en modo Open XML." -f $file.Name) -ForegroundColor DarkYellow
        continue
    }

    try {
        Write-Host ("      ‚è≥ Abriendo (stream compartido) {0}" -f $file.FullName) -ForegroundColor DarkGray
        $opened = Open-ZipArchiveShared -fullPath $file.FullName -retries 4 -delayMs 300
        $zip = $opened.Zip; $fs = $opened.Stream

        $sheetInfo = Get-SheetEntryPath -zip $zip
        if (-not $sheetInfo){
            Write-Host ("      ‚ö†Ô∏è No se localiz√≥ hoja tipo 'An√°lisis Conceptos' en {0}" -f $file.Name) -ForegroundColor DarkYellow
            $zip.Dispose(); $fs.Dispose()
            continue
        }

        $shared = Read-SharedStrings -zip $zip
        $cells  = Read-SheetCells -zip $zip -sheetPath $sheetInfo.Path -shared $shared

        $zip.Dispose(); $fs.Dispose()

        if ($cells.Count -eq 0){
            Write-Host ("      ‚ö™ Hoja '{0}' sin celdas legibles (Open XML)" -f $sheetInfo.SheetName) -ForegroundColor Gray
            continue
        }

        foreach($lit in $literals){
            $llow = Normalize $lit
            foreach($cell in $cells){
                $vnorm = Normalize $cell.Text
                if ($vnorm -like "*$llow*"){
                    $results.Add([PSCustomObject]@{
                        Fichero = $file.FullName
                        Hoja    = $sheetInfo.SheetName
                        Literal = $lit
                        Celda   = $cell.Address
                        Valor   = $cell.Text
                    })
                    Write-Host ("‚úÖ '{0}' en {1} ‚Üí {2} (valor: {3})" -f $lit, $file.Name, $cell.Address, $cell.Text) -ForegroundColor Green
                    if ($stopAtFirst){ throw "STOP_GLOBAL" }
                }
            }
        }

    } catch {
        if ($_.Exception.Message -eq "STOP_GLOBAL"){ throw }
        Write-Host ("‚ö†Ô∏è Error (red/stream) en {0}: {1}" -f $file.FullName, $_.Exception.Message) -ForegroundColor DarkYellow
        continue
    }
}

# -------- Exportar resultados (CSV/XLSX sin tocar originales) --------
$outPath = Join-Path $env:USERPROFILE "Desktop\Resultados_Blueprint.xlsx"
$csvPath = Join-Path $env:TEMP "Resultados_Blueprint.csv"
if ($results.Count -gt 0){
    $results | Export-Csv -NoTypeInformation -Encoding UTF8 $csvPath
    try {
        $excel = New-Object -ComObject Excel.Application
        $excel.Visible = $false; $excel.DisplayAlerts = $false
        $wb = $excel.Workbooks.Open($csvPath)
        $wb.SaveAs($outPath, 51) # xlsx
        $wb.Close($false)
        $excel.Quit(); [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
        Remove-Item $csvPath -ErrorAction SilentlyContinue
        Write-Host "`n‚úÖ Terminado. Resultados guardados en: $outPath" -ForegroundColor Green
    } catch {
        Write-Host "`n‚úÖ Terminado. Dejo CSV en: $csvPath" -ForegroundColor Green
    }
} else {
    Write-Host "`n‚ö™ No se encontraron coincidencias." -ForegroundColor Gray
}