El problema es que no est√°s buscando en las hojas del Excel, solo en sharedStrings.xml. Muchas veces los valores est√°n directamente en las celdas (<v> tags) y no en la tabla de strings compartidos.
Aqu√≠ tienes la versi√≥n corregida que busca en ambos sitios:
$ErrorActionPreference = "Stop"
Add-Type -AssemblyName System.IO.Compression.FileSystem

# === CONFIGURA AQU√ç ===
$path = "C:\Users\Joquina\OneDrive - Automatic Data Processing Inc\Escritorio\PRUEBA\123_PRUEBE\123\01. Documentaci√≥n Implantaci√≥n\ANALISIS\J18-Blueprint_v6.1_validado_09102025.xlsx"
$literal = "embargo"

# === FUNCIONES ===
function Remove-Diacritics([string]$s) {
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray() | Where-Object {
        [Globalization.CharUnicodeInfo]::GetUnicodeCategory($_) -ne [Globalization.UnicodeCategory]::NonSpacingMark
    }) -join ''
}

function Normalize([string]$s) {
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $s = $s -replace '\s+', ' '
    $s = $s -replace '[\u0000-\u001F]', ''
    (Remove-Diacritics $s).ToLowerInvariant().Trim()
}

# === DESCOMPRIMIR ===
Write-Host "üìÇ Descomprimiendo Excel..." -ForegroundColor Cyan
$tmpDir = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), [System.IO.Path]::GetRandomFileName())
[System.IO.Compression.ZipFile]::ExtractToDirectory($path, $tmpDir)

$literalNorm = Normalize $literal
$found = 0
$detalles = @()

# === 1. BUSCAR EN sharedStrings.xml ===
Write-Host "`nüîç Buscando en sharedStrings.xml..." -ForegroundColor Yellow
$sharedFile = "$tmpDir\xl\sharedStrings.xml"
if (Test-Path $sharedFile) {
    $xml = [xml](Get-Content $sharedFile -Raw)
    $idx = 0
    foreach ($si in $xml.sst.si) {
        $txt = ""
        foreach ($node in $si.ChildNodes) {
            if ($node.t) { $txt += $node.t }
            elseif ($node.r) {
                foreach ($r in $node.r) { if ($r.t) { $txt += $r.t } }
            }
        }
        $txtNorm = Normalize $txt
        if ($txtNorm -match [regex]::Escape($literalNorm)) {
            Write-Host "   ‚úÖ [SharedString #$idx]: $txt" -ForegroundColor Green
            $found++
            $detalles += [PSCustomObject]@{
                Ubicacion = "sharedStrings.xml [√≠ndice $idx]"
                Valor = $txt
            }
        }
        $idx++
    }
}
else {
    Write-Host "   ‚ö†Ô∏è No existe sharedStrings.xml" -ForegroundColor DarkYellow
}

# === 2. BUSCAR EN TODAS LAS HOJAS ===
Write-Host "`nüîç Buscando en hojas del Excel..." -ForegroundColor Yellow
$worksheetsDir = "$tmpDir\xl\worksheets"
if (Test-Path $worksheetsDir) {
    $sheetFiles = Get-ChildItem $worksheetsDir -Filter "*.xml" -File
    
    # Obtener nombres de hojas
    $workbookFile = "$tmpDir\xl\workbook.xml"
    $sheetNames = @{}
    if (Test-Path $workbookFile) {
        $wbXml = [xml](Get-Content $workbookFile -Raw)
        foreach ($s in $wbXml.workbook.sheets.sheet) {
            $sheetNames["sheet$($s.sheetId)"] = $s.name
        }
    }
    
    foreach ($sheetFile in $sheetFiles) {
        $sheetName = [System.IO.Path]::GetFileNameWithoutExtension($sheetFile.Name)
        $displayName = if ($sheetNames.ContainsKey($sheetName)) { $sheetNames[$sheetName] } else { $sheetName }
        
        Write-Host "   üìÑ Analizando hoja: $displayName" -ForegroundColor Cyan
        
        $sheetXml = [xml](Get-Content $sheetFile.FullName -Raw)
        
        # Buscar en valores inline (<v> con atributo t="inlineStr")
        foreach ($row in $sheetXml.worksheet.sheetData.row) {
            foreach ($cell in $row.c) {
                $valor = ""
                
                # Tipo 1: Valor inline
                if ($cell.is -and $cell.is.t) {
                    $valor = $cell.is.t
                }
                # Tipo 2: String compartido (referencia a sharedStrings)
                elseif ($cell.t -eq "s" -and $cell.v) {
                    # Este valor es un √≠ndice, ya lo buscamos en sharedStrings
                    continue
                }
                # Tipo 3: Valor directo en <v>
                elseif ($cell.v) {
                    $valor = $cell.v
                }
                
                if (-not [string]::IsNullOrWhiteSpace($valor)) {
                    $valorNorm = Normalize $valor
                    if ($valorNorm -match [regex]::Escape($literalNorm)) {
                        $cellRef = $cell.r
                        Write-Host "      ‚úÖ Celda $cellRef : $valor" -ForegroundColor Green
                        $found++
                        $detalles += [PSCustomObject]@{
                            Ubicacion = "$displayName (celda $cellRef)"
                            Valor = $valor
                        }
                    }
                }
            }
        }
    }
}
else {
    Write-Host "   ‚ö†Ô∏è No se encontr√≥ carpeta de hojas" -ForegroundColor DarkYellow
}

# === RESUMEN ===
Write-Host "`n========================================" -ForegroundColor DarkCyan
if ($found -gt 0) {
    Write-Host "‚úÖ Se encontraron $found coincidencias de '$literal'" -ForegroundColor Green
    Write-Host "`nüìã DETALLE:" -ForegroundColor Cyan
    foreach ($d in $detalles) {
        Write-Host "   üìç $($d.Ubicacion)" -ForegroundColor Yellow
        Write-Host "      üí¨ $($d.Valor)" -ForegroundColor White
    }
}
else {
    Write-Host "‚ùå No se encontr√≥ '$literal' en el fichero" -ForegroundColor Red
    Write-Host "   Posibles causas:" -ForegroundColor Yellow
    Write-Host "   ‚Ä¢ El literal est√° en una hoja oculta" -ForegroundColor Gray
    Write-Host "   ‚Ä¢ El texto tiene formato especial (negritas, colores)" -ForegroundColor Gray
    Write-Host "   ‚Ä¢ Est√° en f√≥rmulas (no en valores)" -ForegroundColor Gray
    Write-Host "   ‚Ä¢ Tiene espacios/saltos de l√≠nea invisibles" -ForegroundColor Gray
}
Write-Host "========================================" -ForegroundColor DarkCyan

Remove-Item -Path $tmpDir -Recurse -Force -ErrorAction SilentlyContinue
üîç Cambios principales:
Busca en las hojas reales (xl/worksheets/sheet*.xml), no solo en strings compartidos
Muestra la celda exacta donde encuentra el literal (ej: "A5", "B12")
Muestra el nombre de la hoja real (no solo "sheet1")
Detalla todas las coincidencias con ubicaci√≥n precisa
Maneja 3 tipos de valores:
Valores inline (<is><t>)
Referencias a sharedStrings (ya cubierto)
Valores directos en celdas (<v>)
üí° ¬øPor qu√© no encontraba el literal antes?
Excel guarda los textos de dos formas:
sharedStrings.xml: para textos repetidos (ahorra espacio)
Directamente en las celdas: textos √∫nicos o valores especiales
Tu script solo miraba sharedStrings.xml, por eso no encontraba textos que estuvieran directamente en las celdas.
Ahora deber√≠a encontrar todos los literales. Pru√©balo y me dices. üéØ













$ErrorActionPreference = "Stop"
Add-Type -AssemblyName System.IO.Compression.FileSystem

# === CONFIGURA AQU√ç ===
$path = "C:\Users\Joquina\OneDrive - Automatic Data Processing Inc\Escritorio\PRUEBA\123_PRUEBE\123\01. Documentaci√≥n Implantaci√≥n\ANALISIS\J18-Blueprint_v6.1_validado_09102025.xlsx"
$literal = "embargo"

# === FUNCIONES ===
function Remove-Diacritics([string]$s) {
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $d = $s.Normalize([Text.NormalizationForm]::FormD)
    ($d.ToCharArray() | Where-Object {
        [Globalization.CharUnicodeInfo]::GetUnicodeCategory($_) -ne [Globalization.UnicodeCategory]::NonSpacingMark
    }) -join ''
}

function Normalize([string]$s) {
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    (Remove-Diacritics $s).ToLowerInvariant().Trim()
}

# === DESCOMPRIMIR ===
$tmpDir = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), [System.IO.Path]::GetRandomFileName())
[System.IO.Compression.ZipFile]::ExtractToDirectory($path, $tmpDir)

$literalNorm = Normalize $literal
$pattern = [regex]::Escape($literalNorm)
$found = 0

Write-Host "üîç Buscando '$literal'..." -ForegroundColor Cyan

# === BUSCAR EN TODO EL CONTENIDO (m√©todo RAW) ===
$archivos = @(
    "$tmpDir\xl\sharedStrings.xml"
) + (Get-ChildItem "$tmpDir\xl\worksheets" -Filter "*.xml" -File -ErrorAction SilentlyContinue)

foreach ($archivo in $archivos) {
    if (-not (Test-Path $archivo)) { continue }
    
    $nombre = Split-Path $archivo -Leaf
    $contenido = Get-Content $archivo -Raw -Encoding UTF8
    
    # Extraer TODO el texto entre tags XML
    $matches = [regex]::Matches($contenido, '>([^<]+)<')
    
    foreach ($m in $matches) {
        $texto = $m.Groups[1].Value
        if ([string]::IsNullOrWhiteSpace($texto)) { continue }
        
        $textoNorm = Normalize $texto
        if ($textoNorm -match $pattern) {
            Write-Host "‚úÖ [$nombre]: $texto" -ForegroundColor Green
            $found++
        }
    }
}

Write-Host "`n========================================" -ForegroundColor DarkCyan
if ($found -gt 0) {
    Write-Host "‚úÖ Encontradas $found coincidencias" -ForegroundColor Green
} else {
    Write-Host "‚ùå No se encontr√≥ '$literal'" -ForegroundColor Red
}
Write-Host "========================================" -ForegroundColor DarkCyan

Remove-Item -Path $tmpDir -Recurse -Force -ErrorAction SilentlyContinue