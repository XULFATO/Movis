option Explicit

' =============================================================================
' VBA Excel Workbook Obfuscator / Deobfuscator - VERSIÓN DEFINITIVA COMPLETA
'
' CARACTERÍSTICAS:
'   1. No ofusca valores de constantes
'   2. No inserta ruido después de líneas con continuación (_)
'   3. Tags aleatorios y variados
'   4. Ofusca nombres de variables declaradas
'   5. Optimizado para 800+ líneas
' =============================================================================

Private Const RUNTIME_MODULE_NAME As String = "z_ofu_runtime"
Private Const NOISE_RATE As Long = 5

' Tags variables (se generan dinámicamente)
Private m_TagKey As String
Private m_TagNoise As String
Private m_TagComment As String

' Diccionario de renombrado de variables
Private m_VarMap As Object

' =============================================================================
' PUNTOS DE ENTRADA
' =============================================================================

Public Sub OFUSCAR_COPIA()
    ProcessWorkbook True
End Sub

Public Sub DESOFUSCAR_COPIA()
    ProcessWorkbook False
End Sub

' =============================================================================
' FLUJO PRINCIPAL
' =============================================================================

Private Sub ProcessWorkbook(ByVal doObfuscate As Boolean)
    Dim srcPath As String, dstPath As String
    Dim wbSrc As Workbook, wbDst As Workbook
    Dim startTime As Double

    srcPath = PickXlsmFile()
    If Len(srcPath) = 0 Then Exit Sub

    If doObfuscate Then
        dstPath = AddSuffixToPath(srcPath, "_OFUSCADO")
    Else
        dstPath = AddSuffixToPath(srcPath, "_DESOFUSCADO")
    End If

    startTime = Timer
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    On Error GoTo ErrorHandler

    Set wbSrc = Workbooks.Open(srcPath, ReadOnly:=True)
    wbSrc.SaveCopyAs dstPath
    wbSrc.Close False

    Set wbDst = Workbooks.Open(dstPath, ReadOnly:=False)

    If doObfuscate Then
        GenerateRandomTags
        Set m_VarMap = CreateObject("Scripting.Dictionary")
        EnsureRuntimeModule wbDst
        ObfuscateProject wbDst
    Else
        DeobfuscateProject wbDst
        RemoveRuntimeModule wbDst
    End If

    wbDst.Save
    wbDst.Close

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox IIf(doObfuscate, "OFUSCADO OK en ", "DESOFUSCADO OK en ") & _
           Format$(Timer - startTime, "0.0") & "s" & vbCrLf & dstPath, vbInformation
    Exit Sub

ErrorHandler:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "Error: " & Err.Description, vbCritical
End Sub

' =============================================================================
' GENERACIÓN DE TAGS ALEATORIOS
' =============================================================================

Private Sub GenerateRandomTags()
    Dim r1 As String, r2 As String, r3 As String
    
    r1 = RandomString(4)
    r2 = RandomString(5)
    r3 = RandomString(6)
    
    m_TagKey = "'_" & r1 & "_K="
    m_TagNoise = "'_" & r2 & "_"
    m_TagComment = "'_" & r3 & ":"
End Sub

Private Function RandomString(ByVal length As Long) As String
    Dim i As Long, chars As String, result As String
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    
    Randomize
    For i = 1 To length
        result = result & Mid$(chars, Int(Rnd * Len(chars)) + 1, 1)
    Next
    
    RandomString = result
End Function

' =============================================================================
' SELECCIÓN DE ARCHIVO
' =============================================================================

Private Function PickXlsmFile() As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = "Selecciona el archivo .XLSM"
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled (*.xlsm)", "*.xlsm"
        If .Show <> -1 Then
            PickXlsmFile = ""
        Else
            PickXlsmFile = .SelectedItems(1)
        End If
    End With
End Function

Private Function AddSuffixToPath(ByVal fullPath As String, ByVal suffix As String) As String
    Dim p As Long
    p = InStrRev(fullPath, ".")
    If p > 0 Then
        AddSuffixToPath = Left$(fullPath, p - 1) & suffix & Mid$(fullPath, p)
    Else
        AddSuffixToPath = fullPath & suffix
    End If
End Function

' =============================================================================
' GESTIÓN DEL MÓDULO RUNTIME
' =============================================================================

Private Sub EnsureRuntimeModule(ByVal wb As Workbook)
    Dim c As Object
    On Error Resume Next
    Set c = wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0

    If c Is Nothing Then
        Set c = wb.VBProject.VBComponents.Add(1)
        c.Name = RUNTIME_MODULE_NAME
    End If

    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        .AddFromString RuntimeCode()
    End With
End Sub

Private Sub RemoveRuntimeModule(ByVal wb As Workbook)
    On Error Resume Next
    wb.VBProject.VBComponents.Remove wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0
End Sub

Private Function RuntimeCode() As String
    RuntimeCode = _
        "Option Explicit" & vbCrLf & _
        vbCrLf & _
        "Public Function dDecode(ByVal hex4 As String, ByVal k As Long) As String" & vbCrLf & _
        "    Dim i As Long, v As Long, r As String" & vbCrLf & _
        "    For i = 1 To Len(hex4) Step 4" & vbCrLf & _
        "        v = CLng(""&H"" & Mid$(hex4, i, 4))" & vbCrLf & _
        "        r = r & ChrW$(v Xor k)" & vbCrLf & _
        "    Next i" & vbCrLf & _
        "    dDecode = r" & vbCrLf & _
        "End Function"
End Function

' =============================================================================
' PROCESAMIENTO DEL PROYECTO
' =============================================================================

Private Sub ObfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        If c.Name <> RUNTIME_MODULE_NAME Then
            code = GetCode(c)
            If Len(code) > 0 Then
                key = MakeKey()
                
                ' 1. Construir mapa de variables para este módulo
                BuildVariableMap code
                
                ' 2. Inyectar variable dummy
                code = InjectDummyDeclarationOnce(code)
                
                ' 3. Renombrar variables
                code = RenameVariables(code)
                
                ' 4. Ofuscar strings y comentarios
                code = ObfuscateCodeSmart(code, key)
                
                SetCode c, m_TagKey & key & vbCrLf & code
            End If
        End If
    Next
End Sub

Private Sub DeobfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        code = GetCode(c)
        key = ExtractKey(code)
        If key > 0 Then
            code = DeobfuscateCodeSmart(code, key)
            SetCode c, code
        End If
    Next
End Sub

' =============================================================================
' LECTURA Y ESCRITURA
' =============================================================================

Private Function GetCode(ByVal c As Object) As String
    With c.CodeModule
        If .CountOfLines = 0 Then
            GetCode = ""
        Else
            GetCode = .Lines(1, .CountOfLines)
        End If
    End With
End Function

Private Sub SetCode(ByVal c As Object, ByVal txt As String)
    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        If Len(txt) > 0 Then .AddFromString txt
    End With
End Sub

' =============================================================================
' MAPEO Y RENOMBRADO DE VARIABLES
' =============================================================================

Private Sub BuildVariableMap(ByVal code As String)
    Dim lines() As String, i As Long
    Dim ln As String, trimmed As String
    Dim varName As String
    
    m_VarMap.RemoveAll
    lines = Split(code, vbCrLf)
    
    For i = LBound(lines) To UBound(lines)
        ln = lines(i)
        trimmed = Trim$(ln)
        
        ' Detectar declaraciones Dim/Private/Public (excepto ofuDummy)
        If trimmed Like "Dim *" Or trimmed Like "Private *" Or trimmed Like "Public *" Then
            ' No procesar constantes
            If InStr(1, trimmed, "Const", vbTextCompare) > 0 Then GoTo NextVar
            
            ' Extraer nombre de variable
            varName = ExtractVariableName(trimmed)
            
            If Len(varName) > 0 And varName <> "ofuDummy" Then
                If Not m_VarMap.exists(varName) Then
                    ' Generar nombre ofuscado: v seguido de número/letra aleatoria
                    m_VarMap(varName) = "v" & RandomString(8)
                End If
            End If
        End If
NextVar:
    Next
End Sub

Private Function ExtractVariableName(ByVal declaration As String) As String
    Dim parts() As String
    Dim varPart As String, p As Long
    
    ' Eliminar Dim/Private/Public
    declaration = Trim$(declaration)
    If Left$(declaration, 3) = "Dim" Then
        declaration = Trim$(Mid$(declaration, 4))
    ElseIf Left$(declaration, 7) = "Private" Then
        declaration = Trim$(Mid$(declaration, 8))
    ElseIf Left$(declaration, 6) = "Public" Then
        declaration = Trim$(Mid$(declaration, 7))
    End If
    
    ' Tomar hasta "As" o paréntesis
    p = InStr(declaration, " As ")
    If p > 0 Then
        varPart = Trim$(Left$(declaration, p - 1))
    Else
        varPart = declaration
    End If
    
    ' Remover paréntesis de arrays
    p = InStr(varPart, "(")
    If p > 0 Then
        varPart = Trim$(Left$(varPart, p - 1))
    End If
    
    ExtractVariableName = varPart
End Function

Private Function RenameVariables(ByVal code As String) As String
    Dim result As String
    Dim varName As Variant
    Dim obfName As String
    
    result = code
    
    ' Reemplazar cada variable por su versión ofuscada
    For Each varName In m_VarMap.Keys
        obfName = m_VarMap(varName)
        result = ReplaceWholeWord(result, CStr(varName), obfName)
    Next
    
    RenameVariables = result
End Function

' Reemplaza palabra completa (no dentro de otras palabras)
Private Function ReplaceWholeWord(ByVal text As String, ByVal oldWord As String, ByVal newWord As String) As String
    Dim result As String
    Dim i As Long, wordStart As Long
    Dim ch As String, inString As Boolean, inComment As Boolean
    
    result = ""
    i = 1
    inString = False
    inComment = False
    
    Do While i <= Len(text)
        ch = Mid$(text, i, 1)
        
        ' Control de contexto
        If ch = """" And Not inComment Then
            inString = Not inString
            result = result & ch
            i = i + 1
        ElseIf ch = "'" And Not inString Then
            inComment = True
            result = result & Mid$(text, i)
            Exit Do
        ElseIf Not inString And Not inComment Then
            ' Buscar palabra
            If IsWordChar(ch) Then
                wordStart = i
                Do While i <= Len(text) And IsWordChar(Mid$(text, i, 1))
                    i = i + 1
                Loop
                
                Dim word As String
                word = Mid$(text, wordStart, i - wordStart)
                
                If StrComp(word, oldWord, vbTextCompare) = 0 Then
                    result = result & newWord
                Else
                    result = result & word
                End If
            Else
                result = result & ch
                i = i + 1
            End If
        Else
            result = result & ch
            i = i + 1
        End If
    Loop
    
    ReplaceWholeWord = result
End Function

Private Function IsWordChar(ByVal ch As String) As Boolean
    Dim code As Long
    code = Asc(ch)
    IsWordChar = (code >= 65 And code <= 90) Or _
                 (code >= 97 And code <= 122) Or _
                 (code >= 48 And code <= 57) Or _
                 ch = "_"
End Function

' =============================================================================
' INYECCIÓN DE VARIABLE DUMMY
' =============================================================================

Private Function InjectDummyDeclarationOnce(ByVal code As String) As String
    Dim lines() As String, i As Long
    Dim result() As String
    Dim injected As Boolean, count As Long
    
    lines = Split(code, vbCrLf)
    ReDim result(UBound(lines) + 1)
    
    injected = False
    count = 0

    For i = LBound(lines) To UBound(lines)
        result(count) = lines(i)
        count = count + 1
        
        If Not injected Then
            Dim trimLine As String
            trimLine = LCase$(Trim$(lines(i)))
            
            If trimLine Like "sub *" Or trimLine Like "public sub *" Or _
               trimLine Like "private sub *" Or trimLine Like "function *" Or _
               trimLine Like "public function *" Or trimLine Like "private function *" Then
                result(count) = "    Dim ofuDummy As Long"
                count = count + 1
                injected = True
            End If
        End If
    Next i
    
    ReDim Preserve result(count - 1)
    InjectDummyDeclarationOnce = Join(result, vbCrLf)
End Function

' =============================================================================
' OFUSCACIÓN INTELIGENTE
' =============================================================================

Private Function ObfuscateCodeSmart(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String
    Dim count As Long
    Dim noiseVariant As Long
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines) * 2)
    
    count = 0
    noiseVariant = 0

    For i = LBound(lines) To UBound(lines)
        result(count) = ObfuscateLineSmart(lines(i), key)
        count = count + 1
        
        ' Insertar ruido SOLO si la línea NO termina con _
        If NOISE_RATE > 0 And i Mod NOISE_RATE = 0 And i > LBound(lines) Then
            If Not LineEndsWithContinuation(lines(i)) Then
                noiseVariant = (noiseVariant + 1) Mod 3
                Select Case noiseVariant
                    Case 0
                        result(count) = m_TagNoise: count = count + 1
                        result(count) = "If False Then": count = count + 1
                        result(count) = "    ofuDummy = 0": count = count + 1
                        result(count) = "End If": count = count + 1
                    Case 1
                        result(count) = m_TagNoise: count = count + 1
                        result(count) = "On Error Resume Next": count = count + 1
                        result(count) = "ofuDummy = ofuDummy + 0": count = count + 1
                        result(count) = "On Error GoTo 0": count = count + 1
                    Case 2
                        result(count) = m_TagNoise: count = count + 1
                        result(count) = "Do While False": count = count + 1
                        result(count) = "    ofuDummy = 1": count = count + 1
                        result(count) = "Loop": count = count + 1
                End Select
            End If
        End If
    Next

    ReDim Preserve result(count - 1)
    ObfuscateCodeSmart = Join(result, vbCrLf)
End Function

' Detecta si línea termina con continuación _
Private Function LineEndsWithContinuation(ByVal ln As String) As Boolean
    Dim trimmed As String, lastChar As String
    Dim commentPos As Long
    
    ' Remover espacios al final
    trimmed = RTrim$(ln)
    
    If Len(trimmed) = 0 Then
        LineEndsWithContinuation = False
        Exit Function
    End If
    
    ' Verificar si hay comentario
    commentPos = InStr(trimmed, "'")
    If commentPos > 0 Then
        ' Verificar si _ está antes del comentario
        trimmed = RTrim$(Left$(trimmed, commentPos - 1))
    End If
    
    If Len(trimmed) = 0 Then
        LineEndsWithContinuation = False
        Exit Function
    End If
    
    lastChar = Right$(trimmed, 1)
    LineEndsWithContinuation = (lastChar = "_")
End Function

' =============================================================================
' OFUSCACIÓN DE LÍNEA INTELIGENTE
' =============================================================================

Private Function ObfuscateLineSmart(ByVal ln As String, ByVal key As Long) As String
    Dim i As Long, ch As String
    Dim result As String
    Dim inString As Boolean, commentStart As Long
    
    ' 1. NO OFUSCAR líneas con Const
    If IsConstDeclaration(ln) Then
        ObfuscateLineSmart = ln
        Exit Function
    End If
    
    ' 2. Buscar comentario (fuera de strings)
    inString = False
    commentStart = 0
    
    For i = 1 To Len(ln)
        ch = Mid$(ln, i, 1)
        If ch = """" Then
            inString = Not inString
        ElseIf ch = "'" And Not inString Then
            commentStart = i
            Exit For
        End If
    Next
    
    ' 3. Separar código y comentario
    Dim codePart As String, commentPart As String
    
    If commentStart > 0 Then
        codePart = Left$(ln, commentStart - 1)
        commentPart = Mid$(ln, commentStart + 1)
    Else
        codePart = ln
        commentPart = ""
    End If
    
    ' 4. Ofuscar strings en código
    result = ObfuscateStringsInCode(codePart, key)
    
    ' 5. Agregar comentario ofuscado
    If Len(commentPart) > 0 Then
        result = result & m_TagComment & ToHex4(commentPart, key)
    End If
    
    ObfuscateLineSmart = result
End Function

Private Function IsConstDeclaration(ByVal ln As String) As Boolean
    Dim trimmed As String
    trimmed = LCase$(Trim$(ln))
    
    IsConstDeclaration = (trimmed Like "const *") Or _
                         (trimmed Like "private const *") Or _
                         (trimmed Like "public const *")
End Function

Private Function ObfuscateStringsInCode(ByVal code As String, ByVal key As Long) As String
    Dim result As String, i As Long
    Dim ch As String, inString As Boolean
    Dim currentString As String, beforeString As String
    
    result = ""
    inString = False
    currentString = ""
    beforeString = ""
    
    For i = 1 To Len(code)
        ch = Mid$(code, i, 1)
        
        If ch = """" Then
            If inString Then
                result = result & beforeString
                If Len(currentString) > 0 Then
                    result = result & "dDecode(""" & ToHex4(currentString, key) & """," & key & ")"
                Else
                    result = result & """"""
                End If
                beforeString = ""
                currentString = ""
                inString = False
            Else
                result = result & beforeString
                beforeString = ""
                inString = True
            End If
        Else
            If inString Then
                currentString = currentString & ch
            Else
                beforeString = beforeString & ch
            End If
        End If
    Next
    
    result = result & beforeString
    ObfuscateStringsInCode = result
End Function

' =============================================================================
' DESOFUSCACIÓN INTELIGENTE
' =============================================================================

Private Function DeobfuscateCodeSmart(ByVal src As String, ByVal key As Long) As String
    Dim 









' =============================================================================
' OFUSCACIÓN DE LÍNEA INTELIGENTE
' =============================================================================

Private Function ObfuscateLineSmart(ByVal ln As String, ByVal key As Long) As String
    Dim i As Long, ch As String
    Dim result As String
    Dim inString As Boolean, commentStart As Long
    
    ' 1. NO OFUSCAR líneas con Const
    If IsConstDeclaration(ln) Then
        ObfuscateLineSmart = ln
        Exit Function
    End If
    
    ' 2. Buscar comentario (fuera de strings)
    inString = False
    commentStart = 0
    
    For i = 1 To Len(ln)
        ch = Mid$(ln, i, 1)
        If ch = """" Then
            inString = Not inString
        ElseIf ch = "'" And Not inString Then
            commentStart = i
            Exit For
        End If
    Next
    
    ' 3. Separar código y comentario
    Dim codePart As String, commentPart As String
    
    If commentStart > 0 Then
        codePart = Left$(ln, commentStart - 1)
        commentPart = Mid$(ln, commentStart + 1)
    Else
        codePart = ln
        commentPart = ""
    End If
    
    ' 4. Ofuscar strings en código
    result = ObfuscateStringsInCode(codePart, key)
    
    ' 5. Agregar comentario ofuscado
    If Len(commentPart) > 0 Then
        result = result & m_TagComment & ToHex4(commentPart, key)
    End If
    
    ObfuscateLineSmart = result
End Function

Private Function IsConstDeclaration(ByVal ln As String) As Boolean
    Dim trimmed As String
    trimmed = LCase$(Trim$(ln))
    
    IsConstDeclaration = (trimmed Like "const *") Or _
                         (trimmed Like "private const *") Or _
                         (trimmed Like "public const *")
End Function

Private Function ObfuscateStringsInCode(ByVal code As String, ByVal key As Long) As String
    Dim result As String, i As Long
    Dim ch As String, inString As Boolean
    Dim currentString As String, beforeString As String
    
    result = ""
    inString = False
    currentString = ""
    beforeString = ""
    
    For i = 1 To Len(code)
        ch = Mid$(code, i, 1)
        
        If ch = """" Then
            If inString Then
                result = result & beforeString
                If Len(currentString) > 0 Then
                    result = result & "dDecode(""" & ToHex4(currentString, key) & """," & key & ")"
                Else
                    result = result & """"""
                End If
                beforeString = ""
                currentString = ""
                inString = False
            Else
                result = result & beforeString
                beforeString = ""
                inString = True
            End If
        Else
            If inString Then
                currentString = currentString & ch
            Else
                beforeString = beforeString & ch
            End If
        End If
    Next
    
    result = result & beforeString
    ObfuscateStringsInCode = result
End Function

' =============================================================================
' DESOFUSCACIÓN INTELIGENTE
' =============================================================================

Private Function DeobfuscateCodeSmart(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String
    Dim count As Long, skipNext As Long
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines))
    
    count = 0
    skipNext = 0

    For i = LBound(lines) To UBound(lines)
        If skipNext > 0 Then
            skipNext = skipNext - 1
            GoTo NextLine
        End If
        
        Dim ln As String, trimLine As String
        ln = lines(i)
        trimLine = Trim$(ln)
        
        ' Detectar tags
        If Left$(ln, 2) = "'_" Then
            If InStr(ln, "_K=") > 0 Then
                GoTo NextLine
            Else
                ' Tag de ruido
                If i + 1 <= UBound(lines) Then
                    Dim nextLine As String
                    nextLine = Trim$(lines(i + 1))
                    
                    If nextLine = "If False Then" Then
                        skipNext = 2
                    ElseIf nextLine = "On Error Resume Next" Then
                        skipNext = 2
                    ElseIf nextLine = "Do While False" Then
                        skipNext = 2
                    End If
                End If
                GoTo NextLine
            End If
        End If
        
        ' Filtrar ruido
        If trimLine = "If False Then" Or trimLine = "End If" Then GoTo NextLine
        If trimLine = "Do While False" Or trimLine = "Loop" Then GoTo NextLine
        If InStr(trimLine, "Dim ofuDummy") > 0 Then GoTo NextLine
        If trimLine = "ofuDummy = ofuDummy + 0" Or trimLine = "ofuDummy = 0" Or trimLine = "ofuDummy = 1" Then GoTo NextLine
        
        ' Restaurar
        result(count) = RestoreLineSmart(ln, key)
        count = count + 1
        
NextLine:
    Next

    ReDim Preserve result(count - 1)
    DeobfuscateCodeSmart = Join(result, vbCrLf)
End Function

Private Function RestoreLineSmart(ByVal ln As String, ByVal key As Long) As String
    Dim p As Long, result As String
    
    result = ln
    
    ' Restaurar comentario
    p = InStr(result, "'_")
    If p > 0 Then
        Dim colonPos As Long
        colonPos = InStr(p, result, ":")
        If colonPos > 0 Then
            Dim hexStr As String
            hexStr = Mid$(result, colonPos + 1)
            result = Left$(result, p - 1) & "'" & FromHex4Fast(hexStr, key)
            RestoreLineSmart = result
            Exit Function
        End If
    End If
    
    ' Restaurar strings
    Dim maxIterations As Long
    maxIterations = 0
    
    Do While InStr(result, "dDecode(""") > 0 And maxIterations < 100
        maxIterations = maxIterations + 1
        
        p = InStr(result, "dDecode(""")
        Dim p2 As Long, pEnd As Long
        
        p2 = InStr(p + 10, result, """")
        If p2 = 0 Then Exit Do
        
        pEnd = InStr(p2 + 1, result, ")")
        If pEnd = 0 Then Exit Do
        
        hexStr = Mid$(result, p + 9, p2 - p - 9)
        Dim decoded As String
        decoded = FromHex4Fast(hexStr, key)
        
        result = Left$(result, p - 1) & """" & decoded & """" & Mid$(result, pEnd + 1)
    Loop
    
    RestoreLineSmart = result
End Function

' =============================================================================
' CODIFICACIÓN / DECODIFICACIÓN HEX4
' =============================================================================

Private Function ToHex4(ByVal s As String, ByVal k As Long) As String
    Dim i As Long, charCode As Long
    Dim result As String, hexChunk As String
    
    result = Space$(Len(s) * 4)
    
    For i = 1 To Len(s)
        charCode = AscW(Mid$(s, i, 1)) Xor k
        hexChunk = Right$("0000" & Hex$(charCode), 4)
        Mid$(result, (i - 1) * 4 + 1, 4) = hexChunk
    Next
    
    ToHex4 = result
End Function

Private Function FromHex4Fast(ByVal hex4 As String, ByVal k As Long) As String
    Dim i As Long, v As Long, length As Long
    Dim result As String
    
    length = Len(hex4)
    If length Mod 4 <> 0 Then
        FromHex4Fast = ""
        Exit Function
    End If
    
    result = Space$(length \ 4)
    
    On Error Resume Next
    For i = 1 To length Step 4
        v = CLng("&H" & Mid$(hex4, i, 4))
        If Err.Number = 0 Then
            Mid$(result, (i \ 4) + 1, 1) = ChrW$(v Xor k)
        End If
    Next
    On Error GoTo 0
    
    FromHex4Fast = result
End Function

' =============================================================================
' UTILIDADES
' =============================================================================

Private Function MakeKey() As Long
    Randomize
    MakeKey = CLng(Rnd * 65534) + 1
End Function

Private Function ExtractKey(ByVal src As String) As Long
    Dim lines() As String, i As Long, ln As String
    
    lines = Split(src, vbCrLf)
    
    For i = LBound(lines) To UBound(lines)
        ln = lines(i)
        If InStr(ln, "_K=") > 0 Then
            Dim p As Long, s As String
            p = InStr(ln, "=")
            If p > 0 Then
                s = Trim$(Mid$(ln, p + 1))
                If IsNumeric(s) Then
                    ExtractKey = CLng(s)
                    Exit Function
                End If
            End If
        End If
    Next
    
    ExtractKey = 0
End Function
