Option Explicit

' ============================
' BlackBox (one-way) VBA Obfuscator
' Inspirado en el enfoque de VBad/VBASH pero viable en PC capado:
' - Sin herramientas externas
' - Sin DLL
' - Sin desofuscar (no reversible)
' - Seguro para botones: NO renombra Public Sub
' ============================

Private Const SUFFIX_OUT As String = "_BLACKBOX"
Private Const MIN_NAME_LEN As Long = 10

' ============================
' ENTRYPOINT
' ============================
Public Sub BLACKBOX_ONEWAY_COPIA()
    Dim srcPath As String, dstPath As String
    Dim wb As Workbook
    Dim fso As Object

    srcPath = PickXlsmFile()
    If Len(srcPath) = 0 Then Exit Sub

    ' Si el usuario selecciona una URL (SharePoint web), no se puede copiar con FSO
    If LCase$(Left$(srcPath, 4)) = "http" Then
        MsgBox "Has seleccionado una URL (http/https). " & vbCrLf & _
               "Para PC capado, usa la ruta local (SharePoint sincronizado/OneDrive) " & _
               "o guarda el archivo en una carpeta local y vuelve a intentarlo.", vbExclamation
        Exit Sub
    End If

    dstPath = AddSuffixToPath(srcPath, SUFFIX_OUT)

    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    On Error GoTo EH

    ' Copia física (evita Error 5 y bloqueos de SaveCopyAs)
    Set fso = CreateObject("Scripting.FileSystemObject")
    fso.CopyFile srcPath, dstPath, True

    ' Abrir copia y ofuscar
    Set wb = Workbooks.Open(dstPath, ReadOnly:=False)

    BlackBoxProject wb

    wb.Save
    wb.Close False

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox "OK. Caja negra creada:" & vbCrLf & dstPath, vbInformation
    Exit Sub

EH:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "ERROR: " & Err.Number & " - " & Err.Description, vbCritical
End Sub

' ============================
' PROJECT PROCESS
' ============================
Private Sub BlackBoxProject(ByVal wb As Workbook)
    Dim comps As Object, c As Object

    Set comps = wb.VBProject.VBComponents  ' Requiere "Trust access to VBA project object model"

    For Each c In comps
        ' Tipos: 1=StdModule, 2=ClassModule, 3=MSForm, 100=Document (ThisWorkbook/Sheets)
        If c.Type = 1 Or c.Type = 2 Or c.Type = 100 Or c.Type = 3 Then
            BlackBoxComponent c
        End If
    Next c
End Sub

Private Sub BlackBoxComponent(ByVal c As Object)
    Dim code As String
    code = GetCode(c)
    If Len(code) = 0 Then Exit Sub

    ' 1) Quitar comentarios (sin romper strings)
    code = RemoveCommentsSmart(code)

    ' 2) Renombrado seguro (VBAD-like mínimo):
    '    - Private Sub/Function (no eventos)
    '    - Dim/Static SOLO dentro de procedimientos (variables locales)
    Dim mapPriv As Object, mapLocals As Object
    Set mapPriv = CreateObject("Scripting.Dictionary")
    Set mapLocals = CreateObject("Scripting.Dictionary")

    BuildMapsSafe code, mapPriv, mapLocals

    ' Aplicar primero privados (pueden ser llamados desde todo el módulo)
    code = ApplyRenameMapSafe(code, mapPriv)

    ' Aplicar luego variables locales (dentro de procedimientos)
    code = ApplyRenameMapSafe(code, mapLocals)

    ' 3) Compactar líneas vacías (reduce legibilidad)
    code = CompactBlankLines(code)

    SetCode c, code
End Sub

' ============================
' CODE READ/WRITE
' ============================
Private Function GetCode(ByVal c As Object) As String
    With c.CodeModule
        If .CountOfLines = 0 Then
            GetCode = ""
        Else
            GetCode = .Lines(1, .CountOfLines)
        End If
    End With
End Function

Private Sub SetCode(ByVal c As Object, ByVal txt As String)
    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        If Len(txt) > 0 Then .AddFromString txt
    End With
End Sub

' ============================
' COMMENT REMOVAL (SAFE)
' ============================
Private Function RemoveCommentsSmart(ByVal src As String) As String
    Dim lines() As String, out() As String
    Dim i As Long, n As Long

    lines = Split(src, vbCrLf)
    ReDim out(UBound(lines))

    For i = LBound(lines) To UBound(lines)
        Dim ln As String
        ln = lines(i)

        ' Quitar línea completa si empieza por comentario
        If Left$(Trim$(ln), 1) = "'" Then
            ' skip
        Else
            out(n) = StripTrailingComment(ln)
            n = n + 1
        End If
    Next i

    If n = 0 Then
        RemoveCommentsSmart = ""
    Else
        ReDim Preserve out(n - 1)
        RemoveCommentsSmart = Join(out, vbCrLf)
    End If
End Function

Private Function StripTrailingComment(ByVal ln As String) As String
    Dim i As Long, ch As String
    Dim inStrLit As Boolean

    inStrLit = False
    For i = 1 To Len(ln)
        ch = Mid$(ln, i, 1)

        If ch = """" Then
            inStrLit = Not inStrLit
        ElseIf (Not inStrLit) And ch = "'" Then
            StripTrailingComment = RTrim$(Left$(ln, i - 1))
            Exit Function
        End If
    Next i

    StripTrailingComment = ln
End Function

' ============================
' MAP BUILDING (SAFE)
' ============================
Private Sub BuildMapsSafe(ByVal code As String, ByVal mapPriv As Object, ByVal mapLocals As Object)
    Dim lines() As String, i As Long
    Dim insideProc As Boolean

    lines = Split(code, vbCrLf)
    insideProc = False

    For i = LBound(lines) To UBound(lines)
        Dim t As String, tl As String
        t = Trim$(lines(i))
        tl = LCase$(t)

        ' Detect start of procedure
        If IsProcHeader(tl) Then insideProc = True

        ' Map private proc names (never rename public, never rename events)
        If Left$(tl, 8) = "private " Then
            Dim nm As String
            nm = ExtractProcNameFromHeader(t)
            If Len(nm) > 0 Then
                If Not IsProtectedProcName(nm) Then
                    If Not mapPriv.exists(nm) Then mapPriv(nm) = "p" & RandomName(MIN_NAME_LEN)
                End If
            End If
        End If

        ' Map local vars only inside procedures
        If insideProc Then
            If Left$(tl, 4) = "dim " Or Left$(tl, 7) = "static " Then
                AddLocalVarRenamesFromDeclaration t, mapLocals
            End If
        End If

        ' Detect end of procedure
        If tl = "end sub" Or tl = "end function" Or tl = "end property" Then insideProc = False
    Next i
End Sub

Private Function IsProcHeader(ByVal tl As String) As Boolean
    IsProcHeader = _
        (Left$(tl, 4) = "sub ") Or (Left$(tl, 9) = "public sub") Or (Left$(tl, 10) = "private sub") Or _
        (Left$(tl, 9) = "function ") Or (Left$(tl, 14) = "public function") Or (Left$(tl, 15) = "private function") Or _
        (Left$(tl, 9) = "property ") Or (Left$(tl, 14) = "public property") Or (Left$(tl, 15) = "private property")
End Function

' Eventos y auto-macros: no tocar
Private Function IsProtectedProcName(ByVal procName As String) As Boolean
    Dim n As String
    n = LCase$(procName)

    IsProtectedProcName = _
        (Left$(n, 9) = "workbook_") Or _
        (Left$(n, 10) = "worksheet_") Or _
        (Left$(n, 8) = "userform") Or _
        (n = "auto_open") Or (n = "auto_close") Or (n = "autoexec") Or (n = "autoclose")
End Function

Private Function ExtractProcNameFromHeader(ByVal headerLine As String) As String
    Dim s As String
    s = Trim$(headerLine)

    ' Find keyword Sub/Function/Property
    Dim p As Long, k As String

    p = InStr(1, s, "Sub ", vbTextCompare)
    If p > 0 Then
        k = "Sub "
        ExtractProcNameFromHeader = TakeWord(Mid$(s, p + Len(k)))
        Exit Function
    End If

    p = InStr(1, s, "Function ", vbTextCompare)
    If p > 0 Then
        k = "Function "
        ExtractProcNameFromHeader = TakeWord(Mid$(s, p + Len(k)))
        Exit Function
    End If

    p = InStr(1, s, "Property ", vbTextCompare)
    If p > 0 Then
        k = "Property "
        ExtractProcNameFromHeader = TakeWord(Mid$(s, p + Len(k)))
        Exit Function
    End If
End Function

Private Sub AddLocalVarRenamesFromDeclaration(ByVal decl As String, ByVal mapLocals As Object)
    ' Soporta: Dim a As Long, b As String
    ' Conservador a propósito (PC capado / estabilidad)
    Dim s As String
    s = Trim$(decl)

    If LCase$(Left$(s, 4)) = "dim " Then s = Trim$(Mid$(s, 5))
    If LCase$(Left$(s, 7)) = "static " Then s = Trim$(Mid$(s, 8))

    Dim parts() As String, i As Long
    parts = Split(s, ",")

    For i = LBound(parts) To UBound(parts)
        Dim item As String, varName As String
        item = Trim$(parts(i))
        If Len(item) = 0 Then GoTo NextItem

        ' cortar "As"
        Dim p As Long
        p = InStr(1, item, " As ", vbTextCompare)
        If p > 0 Then
            varName = Trim$(Left$(item, p - 1))
        Else
            varName = TakeWord(item)
        End If

        ' quitar () arrays
        p = InStr(varName, "(")
        If p > 0 Then varName = Trim$(Left$(varName, p - 1))

        If Len(varName) = 0 Then GoTo NextItem
        If Not mapLocals.exists(varName) Then mapLocals(varName) = "v" & RandomName(MIN_NAME_LEN)

NextItem:
    Next i
End Sub

' ============================
' APPLY RENAMES (SAFE WHOLE WORD, IGNORE STRINGS)
' ============================
Private Function ApplyRenameMapSafe(ByVal code As String, ByVal map As Object) As String
    Dim k As Variant
    Dim result As String
    result = code

    For Each k In map.Keys
        result = ReplaceWholeWordSafe(result, CStr(k), CStr(map(k)))
    Next k

    ApplyRenameMapSafe = result
End Function

Private Function ReplaceWholeWordSafe(ByVal text As String, ByVal oldWord As String, ByVal newWord As String) As String
    Dim res As String, i As Long, ch As String
    Dim inStrLit As Boolean

    res = ""
    i = 1
    inStrLit = False

    Do While i <= Len(text)
        ch = Mid$(text, i, 1)

        If ch = """" Then
            inStrLit = Not inStrLit
            res = res & ch
            i = i + 1

        ElseIf Not inStrLit And IsWordChar(ch) Then
            Dim startPos As Long
            startPos = i

            Do While i <= Len(text) And IsWordChar(Mid$(text, i, 1))
                i = i + 1
            Loop

            Dim w As String
            w = Mid$(text, startPos, i - startPos)

            If StrComp(w, oldWord, vbTextCompare) = 0 Then
                res = res & newWord
            Else
                res = res & w
            End If

        Else
            res = res & ch
            i = i + 1
        End If
    Loop

    ReplaceWholeWordSafe = res
End Function

Private Function IsWordChar(ByVal ch As String) As Boolean
    Dim a As Long
    a = Asc(ch)
    IsWordChar = (a >= 48 And a <= 57) Or (a >= 65 And a <= 90) Or _
                 (a >= 97 And a <= 122) Or (ch = "_")
End Function

' ============================
' COMPACT BLANK LINES
' ============================
Private Function CompactBlankLines(ByVal src As String) As String
    Dim lines() As String, out() As String
    Dim i As Long, n As Long
    Dim lastBlank As Boolean

    lines = Split(src, vbCrLf)
    ReDim out(UBound(lines))

    n = 0
    lastBlank = False

    For i = LBound(lines) To UBound(lines)
        If Len(Trim$(lines(i))) = 0 Then
            If Not lastBlank Then
                out(n) = ""
                n = n + 1
                lastBlank = True
            End If
        Else
            out(n) = lines(i)
            n = n + 1
            lastBlank = False
        End If
    Next i

    If n = 0 Then
        CompactBlankLines = ""
    Else
        ReDim Preserve out(n - 1)
        CompactBlankLines = Join(out, vbCrLf)
    End If
End Function

' ============================
' FILE PICK + PATH
' ============================
Private Function PickXlsmFile() As String
    With Application.FileDialog(msoFileDialogFilePicker)
        .Title = "Selecciona el archivo .XLSM (origen)"
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled (*.xlsm)", "*.xlsm"
        If .Show <> -1 Then
            PickXlsmFile = ""
        Else
            PickXlsmFile = .SelectedItems(1)
        End If
    End With
End Function

Private Function AddSuffixToPath(ByVal fullPath As String, ByVal suffix As String) As String
    Dim p As Long
    p = InStrRev(fullPath, ".")
    If p > 0 Then
        AddSuffixToPath = Left$(fullPath, p - 1) & suffix & Mid$(fullPath, p)
    Else
        AddSuffixToPath = fullPath & suffix
    End If
End Function

Private Function RandomName(ByVal n As Long) As String
    Dim chars As String, i As Long
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    Randomize
    For i = 1 To n
        RandomName = RandomName & Mid$(chars, Int(Rnd * Len(chars)) + 1, 1)
    Next i
End Function

Private Function TakeWord(ByVal s As String) As String
    Dim i As Long, ch As String
    s = Trim$(s)

    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)
        If Not IsWordChar(ch) Then
            TakeWord = Left$(s, i - 1)
            Exit Function
        End If
    Next i

    TakeWord = s
End Function









99999999999999999999999999999999




Option Explicit

' =============================================================================
' VBA Excel Workbook Obfuscator / Deobfuscator - VERSIÓN FINAL FUNCIONAL
'
' CORRECCIONES CRÍTICAS:
'   1. NO ofusca strings en contextos que requieren valores inmediatos:
'      - Worksheets("nombre"), Sheets("nombre")
'      - Range("A1"), Cells(), etc.
'      - Cualquier índice de colección de Excel
'   2. Comentarios totalmente ofuscados
'   3. Desofuscador completamente funcional
' =============================================================================

Private Const RUNTIME_MODULE_NAME As String = "z_ofu_runtime"
Private Const NOISE_RATE As Long = 5

Private m_TagKey As String
Private m_TagNoise As String
Private m_TagComment As String
Private m_TagVarMap As String

Private m_VarMap As Object

' =============================================================================
' PUNTOS DE ENTRADA
' =============================================================================

Public Sub OFUSCAR_COPIA()
    ProcessWorkbook True
End Sub

Public Sub DESOFUSCAR_COPIA()
    ProcessWorkbook False
End Sub

' =============================================================================
' FLUJO PRINCIPAL
' =============================================================================

Private Sub ProcessWorkbook(ByVal doObfuscate As Boolean)
    Dim srcPath As String, dstPath As String
    Dim wbSrc As Workbook, wbDst As Workbook
    Dim startTime As Double

    srcPath = PickXlsmFile()
    If Len(srcPath) = 0 Then Exit Sub

    If doObfuscate Then
        dstPath = AddSuffixToPath(srcPath, "_OFUSCADO")
    Else
        dstPath = AddSuffixToPath(srcPath, "_DESOFUSCADO")
    End If

    startTime = Timer
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    On Error GoTo ErrorHandler

    Set wbSrc = Workbooks.Open(srcPath, ReadOnly:=True)
    wbSrc.SaveCopyAs dstPath
    wbSrc.Close False

    Set wbDst = Workbooks.Open(dstPath, ReadOnly:=False)

    If doObfuscate Then
        GenerateRandomTags
        Set m_VarMap = CreateObject("Scripting.Dictionary")
        EnsureRuntimeModule wbDst
        ObfuscateProject wbDst
    Else
        DeobfuscateProject wbDst
        RemoveRuntimeModule wbDst
    End If

    wbDst.Save
    wbDst.Close

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox IIf(doObfuscate, "OFUSCADO OK en ", "DESOFUSCADO OK en ") & _
           Format$(Timer - startTime, "0.0") & "s" & vbCrLf & dstPath, vbInformation
    Exit Sub

ErrorHandler:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "Error: " & Err.Description, vbCritical
End Sub

' =============================================================================
' TAGS ALEATORIOS
' =============================================================================

Private Sub GenerateRandomTags()
    m_TagKey = "'_" & RandomString(4) & "_K="
    m_TagNoise = "'_" & RandomString(5) & "_"
    m_TagComment = "'_" & RandomString(6) & "_C:"
    m_TagVarMap = "'_" & RandomString(5) & "_V:"
End Sub

Private Function RandomString(ByVal length As Long) As String
    Dim i As Long, chars As String, result As String
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    
    Randomize
    For i = 1 To length
        result = result & Mid$(chars, Int(Rnd * Len(chars)) + 1, 1)
    Next
    
    RandomString = result
End Function

' =============================================================================
' SELECCIÓN DE ARCHIVO
' =============================================================================

Private Function PickXlsmFile() As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = "Selecciona el archivo .XLSM"
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled (*.xlsm)", "*.xlsm"
        If .Show <> -1 Then
            PickXlsmFile = ""
        Else
            PickXlsmFile = .SelectedItems(1)
        End If
    End With
End Function

Private Function AddSuffixToPath(ByVal fullPath As String, ByVal suffix As String) As String
    Dim p As Long
    p = InStrRev(fullPath, ".")
    If p > 0 Then
        AddSuffixToPath = Left$(fullPath, p - 1) & suffix & Mid$(fullPath, p)
    Else
        AddSuffixToPath = fullPath & suffix
    End If
End Function

' =============================================================================
' RUNTIME MODULE
' =============================================================================

Private Sub EnsureRuntimeModule(ByVal wb As Workbook)
    Dim c As Object
    On Error Resume Next
    Set c = wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0

    If c Is Nothing Then
        Set c = wb.VBProject.VBComponents.Add(1)
        c.Name = RUNTIME_MODULE_NAME
    End If

    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        .AddFromString RuntimeCode()
    End With
End Sub

Private Sub RemoveRuntimeModule(ByVal wb As Workbook)
    On Error Resume Next
    wb.VBProject.VBComponents.Remove wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0
End Sub

Private Function RuntimeCode() As String
    RuntimeCode = _
        "Option Explicit" & vbCrLf & _
        vbCrLf & _
        "Public Function dDecode(ByVal hex4 As String, ByVal k As Long) As String" & vbCrLf & _
        "    Dim i As Long, v As Long, r As String" & vbCrLf & _
        "    For i = 1 To Len(hex4) Step 4" & vbCrLf & _
        "        v = CLng(""&H"" & Mid$(hex4, i, 4))" & vbCrLf & _
        "        r = r & ChrW$(v Xor k)" & vbCrLf & _
        "    Next i" & vbCrLf & _
        "    dDecode = r" & vbCrLf & _
        "End Function"
End Function

' =============================================================================
' PROCESAMIENTO
' =============================================================================

Private Sub ObfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        If c.Name <> RUNTIME_MODULE_NAME Then
            code = GetCode(c)
            If Len(code) > 0 Then
                key = MakeKey()
                
                m_VarMap.RemoveAll
                BuildVariableMap code
                
                code = RenameVariables(code)
                code = InjectDummyDeclarationOnce(code)
                code = ObfuscateCodeSmart(code, key)
                
                SetCode c, m_TagKey & key & vbCrLf & _
                          SerializeVarMap() & _
                          code
            End If
        End If
    Next
End Sub

Private Sub DeobfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        code = GetCode(c)
        key = ExtractKey(code)
        If key > 0 Then
            ExtractVarMap code
            code = DeobfuscateCodeSmart(code, key)
            code = RestoreVariableNames(code)
            SetCode c, code
        End If
    Next
End Sub

Private Function GetCode(ByVal c As Object) As String
    With c.CodeModule
        If .CountOfLines = 0 Then
            GetCode = ""
        Else
            GetCode = .Lines(1, .CountOfLines)
        End If
    End With
End Function

Private Sub SetCode(ByVal c As Object, ByVal txt As String)
    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        If Len(txt) > 0 Then .AddFromString txt
    End With
End Sub

' =============================================================================
' VARIABLES
' =============================================================================

Private Sub BuildVariableMap(ByVal code As String)
    Dim lines() As String, i As Long, ln As String, trimmed As String, varName As String
    
    lines = Split(code, vbCrLf)
    
    For i = LBound(lines) To UBound(lines)
        ln = lines(i)
        trimmed = Trim$(ln)
        
        If trimmed Like "Dim *" Or trimmed Like "Private *" Or trimmed Like "Public *" Then
            If InStr(1, trimmed, "Const", vbTextCompare) > 0 Then GoTo NextVar
            
            varName = ExtractVariableName(trimmed)
            
            If Len(varName) > 0 And varName <> "ofuDummy" Then
                If Not m_VarMap.exists(varName) Then
                    m_VarMap(varName) = "v" & RandomString(8)
                End If
            End If
        End If
NextVar:
    Next
End Sub

Private Function ExtractVariableName(ByVal declaration As String) As String
    Dim varPart As String, p As Long
    
    declaration = Trim$(declaration)
    If LCase$(Left$(declaration, 4)) = "dim " Then
        declaration = Trim$(Mid$(declaration, 5))
    ElseIf LCase$(Left$(declaration, 8)) = "private " Then
        declaration = Trim$(Mid$(declaration, 9))
    ElseIf LCase$(Left$(declaration, 7)) = "public " Then
        declaration = Trim$(Mid$(declaration, 8))
    End If
    
    p = InStr(1, declaration, " As ", vbTextCompare)
    If p > 0 Then
        varPart = Trim$(Left$(declaration, p - 1))
    Else
        varPart = declaration
    End If
    
    p = InStr(varPart, "(")
    If p > 0 Then varPart = Trim$(Left$(varPart, p - 1))
    
    ExtractVariableName = varPart
End Function

Private Function SerializeVarMap() As String
    Dim result As String, k As Variant
    
    If m_VarMap.count = 0 Then Exit Function
    
    For Each k In m_VarMap.Keys
        result = result & CStr(k) & "=" & m_VarMap(k) & "|"
    Next
    
    If Len(result) > 0 Then
        result = Left$(result, Len(result) - 1)
        SerializeVarMap = m_TagVarMap & result & vbCrLf
    End If
End Function

Private Sub ExtractVarMap(ByVal src As String)
    Dim lines() As String, i As Long, ln As String, p As Long, mapData As String
    Dim pairs() As String, pair As String, parts() As String, j As Long
    
    Set m_VarMap = CreateObject("Scripting.Dictionary")
    lines = Split(src, vbCrLf)
    
    For i = LBound(lines) To UBound(lines)
        ln = lines(i)
        
        p = InStr(ln, "_V:")
        If p > 0 Then
            mapData = Mid$(ln, p + 3)
            
            If Len(mapData) > 0 Then
                pairs = Split(mapData, "|")
                
                For j = LBound(pairs) To UBound(pairs)
                    pair = pairs(j)
                    If InStr(pair, "=") > 0 Then
                        parts = Split(pair, "=")
                        If UBound(parts) >= 1 Then
                            m_VarMap(parts(1)) = parts(0)
                        End If
                    End If
                Next
            End If
            Exit For
        End If
    Next
End Sub

Private Function RenameVariables(ByVal code As String) As String
    Dim result As String, k As Variant
    
    result = code
    
    For Each k In m_VarMap.Keys
        result = ReplaceWholeWord(result, CStr(k), m_VarMap(k))
    Next
    
    RenameVariables = result
End Function

Private Function RestoreVariableNames(ByVal code As String) As String
    Dim result As String, k As Variant
    
    result = code
    
    For Each k In m_VarMap.Keys
        result = ReplaceWholeWord(result, CStr(k), m_VarMap(k))
    Next
    
    RestoreVariableNames = result
End Function

Private Function ReplaceWholeWord(ByVal text As String, ByVal oldWord As String, ByVal newWord As String) As String
    Dim result As String, i As Long, wordStart As Long
    Dim ch As String, inString As Boolean, inComment As Boolean
    
    result = ""
    i = 1
    inString = False
    inComment = False
    
    Do While i <= Len(text)
        ch = Mid$(text, i, 1)
        
        If ch = """" And Not inComment Then
            inString = Not inString
            result = result & ch
            i = i + 1
        ElseIf ch = "'" And Not inString Then
            inComment = True
            result = result & Mid$(text, i)
            Exit Do
        ElseIf Not inString And Not inComment Then
            If IsWordChar(ch) Then
                wordStart = i
                Do While i <= Len(text) And IsWordChar(Mid$(text, i, 1))
                    i = i + 1
                Loop
                
                Dim word As String
                word = Mid$(text, wordStart, i - wordStart)
                
                If StrComp(word, oldWord, vbTextCompare) = 0 Then
                    result = result & newWord
                Else
                    result = result & word
                End If
            Else
                result = result & ch
                i = i + 1
            End If
        Else
            result = result & ch
            i = i + 1
        End If
    Loop
    
    ReplaceWholeWord = result
End Function

Private Function IsWordChar(ByVal ch As String) As Boolean
    Dim code As Long
    code = Asc(ch)
    IsWordChar = (code >= 65 And code <= 90) Or _
                 (code >= 97 And code <= 122) Or _
                 (code >= 48 And code <= 57) Or _
                 ch = "_"
End Function

' =============================================================================
' INYECCIÓN DUMMY
' =============================================================================

Private Function InjectDummyDeclarationOnce(ByVal code As String) As String
    Dim lines() As String, i As Long
    Dim result() As String, injected As Boolean, count As Long
    
    lines = Split(code, vbCrLf)
    ReDim result(UBound(lines) + 1)
    
    injected = False
    count = 0

    For i = LBound(lines) To UBound(lines)
        result(count) = lines(i)
        count = count + 1
        
        If Not injected Then
            Dim trimLine As String
            trimLine = LCase$(Trim$(lines(i)))
            
            If trimLine Like "sub *" Or trimLine Like "public sub *" Or _
               trimLine Like "private sub *" Or trimLine Like "function *" Or _
               trimLine Like "public function *" Or trimLine Like "private function *" Then
                result(count) = "    Dim ofuDummy As Long"
                count = count + 1
                injected = True
            End If
        End If
    Next i
    
    ReDim Preserve result(count - 1)
    InjectDummyDeclarationOnce = Join(result, vbCrLf)
End Function

' =============================================================================
' OFUSCACIÓN PRINCIPAL
' =============================================================================

Private Function ObfuscateCodeSmart(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String, count As Long, noiseVariant As Long
    Dim insideProcedure As Boolean
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines) * 2)
    
    count = 0
    noiseVariant = 0
    insideProcedure = False

    For i = LBound(lines) To UBound(lines)
        Dim trimLine As String
        trimLine = LCase$(Trim$(lines(i)))
        
        If trimLine Like "sub *" Or trimLine Like "public sub *" Or _
           trimLine Like "private sub *" Or trimLine Like "function *" Or _
           trimLine Like "public function *" Or trimLine Like "private function *" Then
            insideProcedure = True
        End If
        
        If trimLine = "end sub" Or trimLine = "end function" Then
            insideProcedure = False
        End If
        
        result(count) = ObfuscateLineSmart(lines(i), key)
        count = count + 1
        
        If NOISE_RATE > 0 And i Mod NOISE_RATE = 0 And i > LBound(lines) Then
            If insideProcedure And Not LineEndsWithContinuation(lines(i)) Then
                If Not (trimLine Like "sub *" Or trimLine Like "function *" Or _
                        trimLine Like "public sub *" Or trimLine Like "public function *" Or _
                        trimLine Like "private sub *" Or trimLine Like "private function *") Then
                    
                    noiseVariant = (noiseVariant + 1) Mod 3
                    Select Case noiseVariant
                        Case 0
                            result(count) = m_TagNoise: count = count + 1
                            result(count) = "If False Then": count = count + 1
                            result(count) = "    ofuDummy = 0": count = count + 1
                            result(count) = "End If": count = count + 1
                        Case 1
                            result(count) = m_TagNoise: count = count + 1
                            result(count) = "On Error Resume Next": count = count + 1
                            result(count) = "ofuDummy = ofuDummy + 0": count = count + 1
                            result(count) = "On Error GoTo 0": count = count + 1
                        Case 2
                            result(count) = m_TagNoise: count = count + 1
                            result(count) = "Do While False": count = count + 1
                            result(count) = "    ofuDummy = 1": count = count + 1
                            result(count) = "Loop": count = count + 1
                    End Select
                End If
            End If
        End If
    Next

    ReDim Preserve result(count - 1)
    ObfuscateCodeSmart = Join(result, vbCrLf)
End Function

Private Function LineEndsWithContinuation(ByVal ln As String) As Boolean
    Dim trimmed As String, commentPos As Long
    
    trimmed = RTrim$(ln)
    If Len(trimmed) = 0 Then
        LineEndsWithContinuation = False
        Exit Function
    End If
    
    commentPos = InStr(trimmed, "'")
    If commentPos > 0 Then
        trimmed = RTrim$(Left$(trimmed, commentPos - 1))
    End If
    
    If Len(trimmed) = 0 Then
        LineEndsWithContinuation = False
    Else
        LineEndsWithContinuation = (Right$(trimmed, 1) = "_")
    End If
End Function

' =============================================================================
' OFUSCACIÓN DE LÍNEA - CON DETECCIÓN DE CONTEXTO EXCEL
' =============================================================================

Private Function ObfuscateLineSmart(ByVal ln As String, ByVal key As Long) As String
    Dim i As Long, ch As String, result As String
    Dim inString As Boolean, commentStart As Long
    
    If IsConstDeclaration(ln) Then
        ObfuscateLineSmart = ln
        Exit Function
    End If
    
    inString = False
    commentStart = 0
    
    For i = 1 To Len(ln)
        ch = Mid$(ln, i, 1)
        If ch = """" Then
            inString = Not inString
        ElseIf ch = "'" And Not inString Then
            commentStart = i
            Exit For
        End If
    Next
    
    Dim codePart As String, commentPart As String
    
    If commentStart > 0 Then
        codePart = Left$(ln, commentStart - 1)
        commentPart = Mid$(ln, commentStart + 1)
    Else
        codePart = ln
        commentPart = ""
    End If
    
    ' CRÍTICO: Ofuscar strings con contexto
    result = ObfuscateStringsWithContext(codePart, key)
    
    If Len(commentPart) > 0 Then
        result = result & m_TagComment & ToHex4(commentPart, key)
    End If
    
    ObfuscateLineSmart = result
End Function

Private Function IsConstDeclaration(ByVal ln As String) As Boolean
    Dim trimmed As String
    trimmed = LCase$(Trim$(ln))
    
    IsConstDeclaration = (trimmed Like "const *") Or _
                         (trimmed Like "private const *") Or _
                         (trimmed Like "public const *")
End Function

' =============================================================================
' OFUSCACIÓN INTELIGENTE CON CONTEXTO
' =============================================================================

Private Function ObfuscateStringsWithContext(ByVal code As String, ByVal key As Long) As String
    Dim result As String, i As Long, ch As String
    Dim inString As Boolean, currentString As String, beforeString As String
    Dim stringStart As Long
    
    result = ""
    inString = False
    currentString = ""
    beforeString = ""
    stringStart = 0
    
    For i = 1 To Len(code)
        ch = Mid$(code, i, 1)
        
        If ch = """" Then
            If inString Then
                ' Fin de string - verificar contexto ANTES de ofuscar
                Dim shouldObfuscate As Boolean
                shouldObfuscate = Not IsExcelCollectionContext(beforeString)
                
                result = result & beforeString
                
                If Len(currentString) > 0 And shouldObfuscate Then
                    result = result & "dDecode(""" & ToHex4(currentString, key) & """," & key & ")"
                ElseIf Len(currentString) > 0 Then
                    result = result & """" & currentString & """"
                Else
                    result = result & """"""
                End If
                
                beforeString = ""
                currentString = ""
                inString = False
            Else
                result = result & beforeString
                beforeString = ""
                stringStart = Len(result)
                inString = True
            End If
        Else
            If inString Then
                currentString = currentString & ch
            Else
                beforeString = beforeString & ch
            End If
        End If
    Next
    
    result = result & beforeString
    ObfuscateStringsWithContext = result
End Function

' Detecta si el string está en un contexto de colección de Excel
Private Function IsExcelCollectionContext(ByVal precedingCode As String) As Boolean
    Dim trimmed As String, lastWord As String
    Dim i As Long, wordStart As Long
    
    trimmed = RTrim$(precedingCode)
    
    ' Buscar última palabra antes del string
    i = Len(trimmed)
    Do While i > 0
        If Mid$(trimmed, i, 1) = "(" Or Mid$(trimmed, i, 1) = "." Then
            wordStart = i - 1
            Do While wordStart > 0 And IsWordChar(Mid$(trimmed, wordStart, 1))
                wordStart = wordStart - 1
            Loop
            
            lastWord = LCase$(Mid$(trimmed, wordStart + 1, i - wordStart - 1))
            
            ' Lista de métodos/propiedades de Excel que NO se pueden ofuscar
            Select Case lastWord
                Case "worksheets", "sheets", "workbooks"
                    IsExcelCollectionContext = True
                    Exit Function
                Case "range", "cells", "offset", "resize"
                    IsExcelCollectionContext = True
                    Exit Function
                Case "names", "add", "item"
                    IsExcelCollectionContext = True
                    Exit Function
            End Select
            
            Exit Do
        End If
        i = i - 1
    Loop
    
    IsExcelCollectionContext = False
End Function

' =============================================================================
' DESOFUSCACIÓN
' =============================================================================

Private Function DeobfuscateCodeSmart(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String, count As Long, skipNext As Long
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines))
    
    count = 0
    skipNext = 0

    For i = LBound(lines) To UBound(lines)
        If skipNext > 0 Then
            skipNext = skipNext - 1
            GoTo NextLine
        End If
        
        Dim ln As String, trimLine As String
        ln = lines(i)
        trimLine = Trim$(ln)
        
        ' Saltar tags
        If Left$(ln, 2) = "'_" Then
            If InStr(ln, "_K=") > 0 Or InStr(ln, "_V:") > 0 Then
                GoTo NextLine
            Else
                If i + 1 <= UBound(lines) Then
                    Dim nextLine As String
                    nextLine = Trim$(lines(i + 1))
                    
                    If nextLine = "If False Then" Or nextLine = "On Error Resume Next" Or nextLine = "Do While False" Then
                        skipNext = 2
                    End If
                End If
                GoTo NextLine
            End If
        End If
        
        ' Filtrar ruido
        If trimLine = "If False Then" Or trimLine = "End If" Or _
           trimLine = "Do While False" Or trimLine = "Loop" Or _
           InStr(trimLine, "Dim ofuDummy") > 0 Or _
           trimLine = "ofuDummy = ofuDummy + 0" Or trimLine = "ofuDummy = 0" Or trimLine = "ofuDummy = 1" Then
            GoTo NextLine
        End If
        
        result(count) = RestoreLineSmart(ln, key)
        count = count + 1
        
NextLine:
    Next

    ReDim Preserve result(count - 1)
    DeobfuscateCodeSmart = Join(result, vbCrLf)
End Function

Private Function RestoreLineSmart(ByVal ln As String, ByVal key As Long) As String
    Dim p As Long, result As String, hexStr As String
    
    result = ln
    
    ' Restaurar comentario
    p = InStr(result, "_C:")
    If p > 0 Then
        hexStr = Mid$(result, p + 3)
        result = Left$(result, p - 2) & "'" & FromHex4Fast(hexStr, key)
        RestoreLineSmart = result
        Exit Function
    End If
    
    ' Restaurar strings
    Dim maxIterations As Long, p2 As Long, pEnd As Long, decoded As String
    maxIterations = 0
    
    Do While InStr(result, "dDecode(""") > 0 And maxIterations < 100
        maxIterations = maxIterations + 1
        
        p = InStr(result, "dDecode(""")
        
        p2 = InStr(p + 10, result, """")
        If p2 = 0 Then Exit Do
        
        pEnd = InStr(p2 + 1, result, ")")
        If pEnd = 0 Then Exit Do
        
        hexStr = Mid$(result, p + 9, p2 - p - 9)
        decoded = FromHex4Fast(hexStr, key)
        
        result = Left$(result, p - 1) & """" & decoded & """" & Mid$(result, pEnd + 1)
    Loop
    
    RestoreLineSmart = result
End Function

' =============================================================================
' HEX4
' =============================================================================

Private Function ToHex4(ByVal s As String, ByVal k As Long) As String
    Dim i As Long, charCode As Long, result As String, hexChunk As String
    
    result = Space$(Len(s) * 4)
    
    For i = 1 To Len(s)
        charCode = AscW(Mid$(s, i, 1)) Xor k
        hexChunk = Right$("0000" & Hex$(charCode), 4)
        Mid$(result, (i - 1) * 4 + 1, 4) = hexChunk
    Next
    
    ToHex4 = result
End Function

Private Function FromHex4Fast(ByVal hex4 As String, ByVal k As Long) As String
    Dim i As Long, v As Long, length As Long, result As String
    
    length = Len(hex4)
    If length Mod 4 <> 0 Then
        FromHex4Fast = ""
        Exit Function
    End If
    
    result = Space$(length \ 4)
    
    On Error Resume Next
    For i = 1 To length Step 4
        v = CLng("&H" & Mid$(hex4, i, 4))
        If Err.Number = 0 Then
            Mid$(result, (i \ 4) + 1, 1) = ChrW$(v Xor k)
        End If
    Next
    On Error GoTo 0
    
    FromHex4Fast = result
End Function

' =============================================================================
' UTILIDADES
' =============================================================================

Private Function MakeKey() As Long
    Randomize
    MakeKey = CLng(Rnd * 65534) + 1
End Function

Private Function ExtractKey(ByVal src As String) As Long
    Dim lines() As String, i As Long, ln As String, p As Long, s As String
    
    lines = Split(src, vbCrLf)
    
    For i = LBound(lines) To UBound(lines)
        ln = lines(i)
        If InStr(ln, "_K=") > 0 Then
            p = InStr(ln, "=")
            If p > 0 Then
                s = Trim$(Mid$(ln, p + 1))
                If IsNumeric(s) Then
                    ExtractKey = CLng(s)
                    Exit Function
                End If
            End If
        End If
    Next
    
    ExtractKey = 0
End Function



