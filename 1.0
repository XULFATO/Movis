Option Explicit

'==========================================================================================
' VBA Code Obfuscator - VERSIÓN CORREGIDA (NO OFUSCA STRINGS CRÍTICOS)
'
' NO OFUSCA:
'  - MsgBox, InputBox (mensajes al usuario)
'  - Worksheets("nombre"), Sheets("nombre")
'  - Range("A1"), Cells(), Names()
'  - Workbooks("archivo.xlsx")
'
' SÍ OFUSCA:
'  - Variables locales (Dim/Private)
'  - Argumentos de procedimientos
'  - Comentarios (los elimina)
'==========================================================================================

Private Const OBSFUCATED_PREFIX As String = "v"
Private Const OBSFUCATED_LEN As Long = 12

Private Type TMapItem
    originalName As String
    obfuscatedName As String
End Type

Private mMap() As TMapItem
Private mMapCount As Long

'==========================================================================================
' ENTRADA PRINCIPAL
'==========================================================================================
Public Sub ObfuscateWorkbook_Interactive()
    Dim srcPath As Variant, dstPath As Variant
    Dim wbSrc As Workbook, wbDst As Workbook

    On Error Resume Next
    Dim testProj As Object
    Set testProj = ThisWorkbook.VBProject
    If Err.Number <> 0 Then
        On Error GoTo 0
        MsgBox "ERROR: No hay acceso al modelo VBProject." & vbCrLf & vbCrLf & _
               "Solución:" & vbCrLf & _
               "1. Archivo → Opciones → Centro de confianza" & vbCrLf & _
               "2. Configuración del Centro de confianza" & vbCrLf & _
               "3. Configuración de macros" & vbCrLf & _
               "4. Marcar: 'Confiar en el acceso al modelo de objetos de proyectos de VBA'", _
               vbCritical, "VBA Obfuscator"
        Exit Sub
    End If
    On Error GoTo 0

    srcPath = Application.GetOpenFilename( _
                FileFilter:="Excel macro-enabled (*.xlsm;*.xlam),*.xlsm;*.xlam", _
                Title:="Selecciona el archivo ORIGEN")
    If srcPath = False Then Exit Sub

    dstPath = Application.GetSaveAsFilename( _
                InitialFileName:=BuildDefaultDestPath(CStr(srcPath)), _
                FileFilter:="Excel Macro-Enabled Workbook (*.xlsm), *.xlsm", _
                Title:="Guardar archivo OFUSCADO")
    If dstPath = False Then Exit Sub
    If LCase$(Right$(CStr(dstPath), 5)) <> ".xlsm" Then dstPath = CStr(dstPath) & ".xlsm"

    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    On Error GoTo ErrorHandler

    Set wbSrc = Workbooks.Open(Filename:=CStr(srcPath), ReadOnly:=True, UpdateLinks:=0)
    wbSrc.SaveCopyAs CStr(dstPath)
    wbSrc.Close SaveChanges:=False

    Application.Wait Now + TimeValue("00:00:01")

    Set wbDst = Workbooks.Open(Filename:=CStr(dstPath), ReadOnly:=False, UpdateLinks:=0)

    MapInit
    CollectIdentifiers wbDst
    ApplyObfuscation wbDst

    wbDst.Save
    wbDst.Close SaveChanges:=True

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox "Ofuscación completada correctamente:" & vbCrLf & vbCrLf & CStr(dstPath), _
           vbInformation, "VBA Obfuscator"
    Exit Sub

ErrorHandler:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    
    On Error Resume Next
    If Not wbSrc Is Nothing Then wbSrc.Close SaveChanges:=False
    If Not wbDst Is Nothing Then wbDst.Close SaveChanges:=False
    On Error GoTo 0
    
    MsgBox "ERROR: " & Err.Description & vbCrLf & "Número: " & Err.Number, vbCritical
End Sub

'==========================================================================================
' FASE 1: RECOGER IDENTIFICADORES
'==========================================================================================
Private Sub CollectIdentifiers(ByVal wb As Workbook)
    Dim vbProj As Object, comp As Object, cm As Object
    Dim codeText As String, i As Long, compCount As Long

    On Error Resume Next
    Set vbProj = wb.VBProject
    If Err.Number <> 0 Then
        Err.Clear
        MsgBox "No se puede acceder al VBProject.", vbCritical
        Exit Sub
    End If
    
    compCount = vbProj.VBComponents.Count
    On Error GoTo ErrorHandler

    For i = 1 To compCount
        Set comp = vbProj.VBComponents.Item(i)
        Set cm = comp.CodeModule

        If cm.CountOfLines > 0 Then
            codeText = cm.Lines(1, cm.CountOfLines)
            CollectVariablesFromText codeText
            CollectArgumentsFromText codeText, comp.Type
            CollectPrivateProceduresFromText codeText, comp.Type
        End If
    Next i

    Exit Sub

ErrorHandler:
    MsgBox "Error en CollectIdentifiers: " & Err.Description, vbCritical
End Sub

Private Sub CollectVariablesFromText(ByVal codeText As String)
    Dim lines() As String, i As Long, s As String, trimmed As String
    Dim declType As String, decl As String

    lines = Split(codeText, vbCrLf)

    For i = LBound(lines) To UBound(lines)
        s = lines(i)
        trimmed = Trim$(s)

        If trimmed = "" Then GoTo NextLine
        If Left$(trimmed, 1) = "'" Then GoTo NextLine
        If LCase$(Left$(trimmed, 10)) = "attribute " Then GoTo NextLine

        If StartsWithWord(trimmed, "Dim") Or StartsWithWord(trimmed, "Private") Then
            If InStr(1, trimmed, "Const", vbTextCompare) > 0 Then GoTo NextLine

            declType = FirstWord(trimmed)
            decl = Trim$(Mid$(trimmed, Len(declType) + 1))

            CollectNamesFromDeclarationList decl
        End If

NextLine:
    Next i
End Sub

Private Sub CollectPrivateProceduresFromText(ByVal codeText As String, ByVal compType As Long)
    Dim re As Object, matches As Object, match As Object, procName As String

    On Error Resume Next
    Set re = CreateObject("VBScript.RegExp")
    If Err.Number <> 0 Then Exit Sub
    On Error GoTo 0

    re.Global = True
    re.IgnoreCase = False
    re.Pattern = "^\s*Private\s+(Sub|Function)\s+([A-Za-z_][A-Za-z0-9_]*)\b"

    Set matches = re.Execute(codeText)

    For Each match In matches
        procName = CStr(match.SubMatches(1))
        If Not IsProtectedProcName(procName, compType) Then
            MapAdd procName, MakeObfuscated(procName)
        End If
    Next match
End Sub

Private Sub CollectArgumentsFromText(ByVal codeText As String, ByVal compType As Long)
    Dim re As Object, matches As Object, match As Object
    Dim procName As String, argsBlock As String

    On Error Resume Next
    Set re = CreateObject("VBScript.RegExp")
    If Err.Number <> 0 Then Exit Sub
    On Error GoTo 0

    re.Global = True
    re.IgnoreCase = False
    re.Pattern = "^\s*(Public|Private)?\s*(Sub|Function)\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^)]*)\)"

    Set matches = re.Execute(codeText)

    For Each match In matches
        procName = CStr(match.SubMatches(2))
        argsBlock = CStr(match.SubMatches(3))
        If Not IsProtectedProcName(procName, compType) Then
            CollectNamesFromArgumentList argsBlock
        End If
    Next match
End Sub

'==========================================================================================
' FASE 2: APLICAR OFUSCACIÓN
'==========================================================================================
Private Sub ApplyObfuscation(ByVal wb As Workbook)
    Dim vbProj As Object, comp As Object, cm As Object
    Dim originalText As String, newText As String
    Dim i As Long, compCount As Long

    On Error Resume Next
    Set vbProj = wb.VBProject
    If Err.Number <> 0 Then
        MsgBox "No se puede acceder al VBProject.", vbCritical
        Exit Sub
    End If
    
    compCount = vbProj.VBComponents.Count
    On Error GoTo ErrorHandler

    For i = 1 To compCount
        Set comp = vbProj.VBComponents.Item(i)
        Set cm = comp.CodeModule

        If cm.CountOfLines > 0 Then
            originalText = cm.Lines(1, cm.CountOfLines)

            ' SOLO eliminar comentarios y renombrar variables
            ' NO ofuscar strings
            newText = RemoveComments(originalText)
            newText = ReplaceWithMap(newText, comp.Type)

            If newText <> originalText Then
                cm.DeleteLines 1, cm.CountOfLines
                If Len(newText) > 0 Then
                    cm.InsertLines 1, newText
                End If
            End If
        End If
    Next i

    Exit Sub

ErrorHandler:
    MsgBox "Error en ApplyObfuscation: " & Err.Description, vbCritical
End Sub

'==========================================================================================
' ELIMINACIÓN DE COMENTARIOS
'==========================================================================================
Private Function RemoveComments(ByVal codeText As String) As String
    Dim lines() As String, i As Long, s As String
    Dim outLines() As String
    Dim inString As Boolean, j As Long, ch As String, cleaned As String

    lines = Split(codeText, vbCrLf)
    ReDim outLines(LBound(lines) To UBound(lines))

    For i = LBound(lines) To UBound(lines)
        s = lines(i)

        ' Comentario completo
        If Trim$(s) <> "" And Left$(Trim$(s), 1) = "'" Then
            outLines(i) = ""
            GoTo NextLine
        End If

        ' Comentarios inline (respetando strings)
        inString = False
        cleaned = ""

        For j = 1 To Len(s)
            ch = Mid$(s, j, 1)

            If ch = """" Then
                inString = Not inString
                cleaned = cleaned & ch
            ElseIf ch = "'" And Not inString Then
                Exit For
            Else
                cleaned = cleaned & ch
            End If
        Next j

        outLines(i) = cleaned

NextLine:
    Next i

    RemoveComments = Join(outLines, vbCrLf)
End Function

'==========================================================================================
' REEMPLAZO CON MAPA (SIN TOCAR STRINGS)
'==========================================================================================
Private Function ReplaceWithMap(ByVal codeText As String, ByVal compType As Long) As String
    Dim lines() As String, i As Long, s As String
    Dim outLines() As String

    lines = Split(codeText, vbCrLf)
    ReDim outLines(LBound(lines) To UBound(lines))

    For i = LBound(lines) To UBound(lines)
        s = lines(i)

        If Trim$(s) = "" Then
            outLines(i) = s
        ElseIf LCase$(Left$(Trim$(s), 10)) = "attribute " Then
            outLines(i) = s
        Else
            outLines(i) = ReplaceOutsideQuotes(s)
        End If
    Next i

    ReplaceWithMap = Join(outLines, vbCrLf)
End Function

Private Function ReplaceOutsideQuotes(ByVal lineText As String) As String
    Dim parts() As String, i As Long, result As String

    ' Divide por comillas: pares fuera de string, impares dentro
    parts = Split(lineText, """")

    For i = LBound(parts) To UBound(parts)
        If (i Mod 2) = 0 Then
            ' Fuera de string: reemplazar identificadores
            parts(i) = ReplaceTokens(parts(i))
        End If
        ' Dentro de string: NO tocar
    Next i

    result = Join(parts, """")
    ReplaceOutsideQuotes = result
End Function

Private Function ReplaceTokens(ByVal textPart As String) As String
    Dim i As Long, re As Object

    On Error Resume Next

    For i = 0 To mMapCount - 1
        If mMap(i).originalName <> "" Then
            Set re = CreateObject("VBScript.RegExp")
            If Err.Number = 0 Then
                re.Global = True
                re.IgnoreCase = False
                re.Pattern = "\b" & RegexEscape(mMap(i).originalName) & "\b"
                textPart = re.Replace(textPart, mMap(i).obfuscatedName)
            End If
            Err.Clear
        End If
    Next i

    On Error GoTo 0
    ReplaceTokens = textPart
End Function

'==========================================================================================
' MAPA
'==========================================================================================
Private Sub MapInit()
    ReDim mMap(0 To 0)
    mMapCount = 0
End Sub

Private Sub MapAdd(ByVal originalName As String, ByVal obfuscatedName As String)
    originalName = Trim$(originalName)
    If originalName = "" Then Exit Sub
    If Not IsValidIdentifier(originalName) Then Exit Sub
    If IsReservedWord(originalName) Then Exit Sub
    If MapGet(originalName) <> "" Then Exit Sub

    ReDim Preserve mMap(0 To mMapCount)
    mMap(mMapCount).originalName = originalName
    mMap(mMapCount).obfuscatedName = obfuscatedName
    mMapCount = mMapCount + 1
End Sub

Private Function MapGet(ByVal originalName As String) As String
    Dim i As Long
    For i = 0 To mMapCount - 1
        If StrComp(mMap(i).originalName, originalName, vbBinaryCompare) = 0 Then
            MapGet = mMap(i).obfuscatedName
            Exit Function
        End If
    Next i
    MapGet = ""
End Function

Private Function MakeObfuscated(ByVal seed As String) As String
    Dim s As String, i As Long, n As Long, chars As String

    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    s = OBSFUCATED_PREFIX

    Randomize Timer + Len(seed)

    For i = 1 To OBSFUCATED_LEN
        n = Int(Rnd * Len(chars)) + 1
        s = s & Mid$(chars, n, 1)
    Next i

    MakeObfuscated = s
End Function

'==========================================================================================
' PARSERS
'==========================================================================================
Private Sub CollectNamesFromDeclarationList(ByVal decl As String)
    Dim parts() As String, i As Long, one As String, name As String

    parts = Split(decl, ",")

    For i = LBound(parts) To UBound(parts)
        one = Trim$(parts(i))
        If one = "" Then GoTo NextOne

        one = StripTokens(one, Array("ByVal", "ByRef", "Optional", "ParamArray"))
        name = ExtractIdentifierLeft(one)

        If name <> "" Then MapAdd name, MakeObfuscated(name)

NextOne:
    Next i
End Sub

Private Sub CollectNamesFromArgumentList(ByVal argsBlock As String)
    Dim parts() As String, i As Long, one As String, name As String

    argsBlock = Trim$(argsBlock)
    If argsBlock = "" Then Exit Sub

    parts = Split(argsBlock, ",")

    For i = LBound(parts) To UBound(parts)
        one = Trim$(parts(i))
        If one = "" Then GoTo NextArg

        one = StripTokens(one, Array("ByVal", "ByRef", "Optional", "ParamArray"))
        name = ExtractIdentifierLeft(one)

        If name <> "" Then MapAdd name, MakeObfuscated(name)

NextArg:
    Next i
End Sub

Private Function ExtractIdentifierLeft(ByVal fragment As String) As String
    fragment = Trim$(fragment)
    If fragment = "" Then Exit Function

    fragment = CutBeforeToken(fragment, " As ")
    fragment = CutBeforeChar(fragment, "=")
    fragment = CutBeforeChar(fragment, "(")
    fragment = Trim$(fragment)
    fragment = Replace(fragment, "()", vbNullString)

    If IsValidIdentifier(fragment) Then
        ExtractIdentifierLeft = fragment
    Else
        ExtractIdentifierLeft = ""
    End If
End Function

Private Function CutBeforeToken(ByVal s As String, ByVal token As String) As String
    Dim p As Long
    p = InStr(1, s, token, vbTextCompare)
    If p > 0 Then
        CutBeforeToken = Left$(s, p - 1)
    Else
        CutBeforeToken = s
    End If
End Function

Private Function CutBeforeChar(ByVal s As String, ByVal ch As String) As String
    Dim p As Long
    p = InStr(1, s, ch, vbBinaryCompare)
    If p > 0 Then
        CutBeforeChar = Left$(s, p - 1)
    Else
        CutBeforeChar = s
    End If
End Function

Private Function StripTokens(ByVal s As String, ByVal tokens As Variant) As String
    Dim i As Long
    For i = LBound(tokens) To UBound(tokens)
        s = Replace(s, CStr(tokens(i)) & " ", "", 1, -1, vbTextCompare)
    Next i
    StripTokens = Trim$(s)
End Function

Private Function IsProtectedProcName(ByVal procName As String, ByVal compType As Long) As Boolean
    If InStr(1, procName, "Workbook_", vbTextCompare) = 1 Then IsProtectedProcName = True: Exit Function
    If InStr(1, procName, "Worksheet_", vbTextCompare) = 1 Then IsProtectedProcName = True: Exit Function
    If InStr(1, procName, "Auto_", vbTextCompare) = 1 Then IsProtectedProcName = True: Exit Function
    If StrComp(procName, "AutoOpen", vbTextCompare) = 0 Then IsProtectedProcName = True: Exit Function
    If StrComp(procName, "AutoClose", vbTextCompare) = 0 Then IsProtectedProcName = True: Exit Function

    If compType = 100 Then ' vbext_ct_Document
        If InStr(1, procName, "_", vbBinaryCompare) > 0 Then
            IsProtectedProcName = True
            Exit Function
        End If
    End If

    IsProtectedProcName = False
End Function

'==========================================================================================
' UTILIDADES
'==========================================================================================
Private Function BuildDefaultDestPath(ByVal srcPath As String) As String
    Dim p As Long, base As String
    p = InStrRev(srcPath, ".")
    If p > 0 Then
        base = Left$(srcPath, p - 1)
    Else
        base = srcPath
    End If
    BuildDefaultDestPath = base & "_OFUSCADO.xlsm"
End Function

Private Function RegexEscape(ByVal s As String) As String
    Dim specials As Variant, i As Long
    specials = Array("\", "^", "$", ".", "|", "?", "*", "+", "(", ")", "[", "]", "{", "}")
    For i = LBound(specials) To UBound(specials)
        s = Replace(s, CStr(specials(i)), "\" & CStr(specials(i)))
    Next i
    RegexEscape = s
End Function

Private Function IsValidIdentifier(ByVal s As String) As Boolean
    Dim re As Object
    On Error Resume Next
    Set re = CreateObject("VBScript.RegExp")
    If Err.Number <> 0 Then
        IsValidIdentifier = False
        Exit Function
    End If
    On Error GoTo 0
    
    re.Global = False
    re.IgnoreCase = False
    re.Pattern = "^[A-Za-z_][A-Za-z0-9_]*$"
    IsValidIdentifier = re.Test(s)
End Function

Private Function IsReservedWord(ByVal s As String) As Boolean
    Dim w As String
    w = LCase$(s)

    Select Case w
        Case "sub", "function", "end", "if", "then", "else", "elseif", "for", "next", "do", "loop", _
             "while", "wend", "select", "case", "with", "goto", "return", "exit", "dim", "private", _
             "public", "as", "set", "new", "not", "and", "or", "xor", "byval", "byref", "optional", _
             "paramarray", "true", "false", "nothing", "me", "thisworkbook", "on", "error", "resume", _
             "each", "in", "to", "step", "until"
            IsReservedWord = True
        Case Else
            IsReservedWord = False
    End Select
End Function

Private Function StartsWithWord(ByVal s As String, ByVal w As String) As Boolean
    Dim t As String
    t = Trim$(s)
    StartsWithWord = (StrComp(Left$(t, Len(w)), w, vbTextCompare) = 0) And _
                     (Len(t) = Len(w) Or Mid$(t, Len(w) + 1, 1) = " ")
End Function

Private Function FirstWord(ByVal s As String) As String
    Dim p As Long, t As String
    t = Trim$(s)
    p = InStr(1, t, " ", vbBinaryCompare)
    If p > 0 Then
        FirstWord = Left$(t, p - 1)
    Else
        FirstWord = t
    End If
End Function
