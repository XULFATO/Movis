Option Explicit

' =============================================================================
' VBA Excel Workbook Obfuscator / Deobfuscator - VERSIÓN DEFINITIVA
'
' CORRECCIONES:
'   1. No ofusca valores de constantes (Const X = "valor")
'   2. No inserta ruido después de líneas con continuación (_)
'   3. Tags aleatorios y variados para dificultar seguimiento
' =============================================================================

Private Const RUNTIME_MODULE_NAME As String = "z_ofu_runtime"
Private Const NOISE_RATE As Long = 5

' Tags variables (se generan dinámicamente)
Private m_TagKey As String
Private m_TagNoise As String
Private m_TagComment As String

' =============================================================================
' PUNTOS DE ENTRADA
' =============================================================================

Public Sub OFUSCAR_COPIA()
    ProcessWorkbook True
End Sub

Public Sub DESOFUSCAR_COPIA()
    ProcessWorkbook False
End Sub

' =============================================================================
' FLUJO PRINCIPAL
' =============================================================================

Private Sub ProcessWorkbook(ByVal doObfuscate As Boolean)
    Dim srcPath As String, dstPath As String
    Dim wbSrc As Workbook, wbDst As Workbook
    Dim startTime As Double

    srcPath = PickXlsmFile()
    If Len(srcPath) = 0 Then Exit Sub

    If doObfuscate Then
        dstPath = AddSuffixToPath(srcPath, "_OFUSCADO")
    Else
        dstPath = AddSuffixToPath(srcPath, "_DESOFUSCADO")
    End If

    startTime = Timer
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    On Error GoTo ErrorHandler

    Set wbSrc = Workbooks.Open(srcPath, ReadOnly:=True)
    wbSrc.SaveCopyAs dstPath
    wbSrc.Close False

    Set wbDst = Workbooks.Open(dstPath, ReadOnly:=False)

    If doObfuscate Then
        GenerateRandomTags
        EnsureRuntimeModule wbDst
        ObfuscateProject wbDst
    Else
        DeobfuscateProject wbDst
        RemoveRuntimeModule wbDst
    End If

    wbDst.Save
    wbDst.Close

    Application.DisplayAlerts = True
    Application.ScreenUpdating = True

    MsgBox IIf(doObfuscate, "OFUSCADO OK en ", "DESOFUSCADO OK en ") & _
           Format$(Timer - startTime, "0.0") & "s" & vbCrLf & dstPath, vbInformation
    Exit Sub

ErrorHandler:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "Error: " & Err.Description, vbCritical
End Sub

' =============================================================================
' GENERACIÓN DE TAGS ALEATORIOS
' =============================================================================

Private Sub GenerateRandomTags()
    ' Tags aleatorios para dificultar el análisis
    Dim r1 As String, r2 As String, r3 As String
    
    r1 = RandomString(4)
    r2 = RandomString(5)
    r3 = RandomString(6)
    
    m_TagKey = "'_" & r1 & "_K="
    m_TagNoise = "'_" & r2 & "_"
    m_TagComment = "'_" & r3 & ":"
End Sub

Private Function RandomString(ByVal length As Long) As String
    Dim i As Long, chars As String, result As String
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    
    Randomize
    For i = 1 To length
        result = result & Mid$(chars, Int(Rnd * Len(chars)) + 1, 1)
    Next
    
    RandomString = result
End Function

' =============================================================================
' SELECCIÓN DE ARCHIVO
' =============================================================================

Private Function PickXlsmFile() As String
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Title = "Selecciona el archivo .XLSM"
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled (*.xlsm)", "*.xlsm"
        If .Show <> -1 Then
            PickXlsmFile = ""
        Else
            PickXlsmFile = .SelectedItems(1)
        End If
    End With
End Function

Private Function AddSuffixToPath(ByVal fullPath As String, ByVal suffix As String) As String
    Dim p As Long
    p = InStrRev(fullPath, ".")
    If p > 0 Then
        AddSuffixToPath = Left$(fullPath, p - 1) & suffix & Mid$(fullPath, p)
    Else
        AddSuffixToPath = fullPath & suffix
    End If
End Function

' =============================================================================
' GESTIÓN DEL MÓDULO RUNTIME
' =============================================================================

Private Sub EnsureRuntimeModule(ByVal wb As Workbook)
    Dim c As Object
    On Error Resume Next
    Set c = wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0

    If c Is Nothing Then
        Set c = wb.VBProject.VBComponents.Add(1)
        c.Name = RUNTIME_MODULE_NAME
    End If

    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        .AddFromString RuntimeCode()
    End With
End Sub

Private Sub RemoveRuntimeModule(ByVal wb As Workbook)
    On Error Resume Next
    wb.VBProject.VBComponents.Remove wb.VBProject.VBComponents(RUNTIME_MODULE_NAME)
    On Error GoTo 0
End Sub

Private Function RuntimeCode() As String
    RuntimeCode = _
        "Option Explicit" & vbCrLf & _
        vbCrLf & _
        "Public Function dDecode(ByVal hex4 As String, ByVal k As Long) As String" & vbCrLf & _
        "    Dim i As Long, v As Long, r As String" & vbCrLf & _
        "    For i = 1 To Len(hex4) Step 4" & vbCrLf & _
        "        v = CLng(""&H"" & Mid$(hex4, i, 4))" & vbCrLf & _
        "        r = r & ChrW$(v Xor k)" & vbCrLf & _
        "    Next i" & vbCrLf & _
        "    dDecode = r" & vbCrLf & _
        "End Function"
End Function

' =============================================================================
' PROCESAMIENTO DEL PROYECTO
' =============================================================================

Private Sub ObfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        If c.Name <> RUNTIME_MODULE_NAME Then
            code = GetCode(c)
            If Len(code) > 0 Then
                key = MakeKey()
                code = InjectDummyDeclarationOnce(code)
                code = ObfuscateCodeSmart(code, key)
                SetCode c, m_TagKey & key & vbCrLf & code
            End If
        End If
    Next
End Sub

Private Sub DeobfuscateProject(ByVal wb As Workbook)
    Dim c As Object, code As String, key As Long
    
    For Each c In wb.VBProject.VBComponents
        code = GetCode(c)
        key = ExtractKey(code)
        If key > 0 Then
            code = DeobfuscateCodeSmart(code, key)
            SetCode c, code
        End If
    Next
End Sub

' =============================================================================
' LECTURA Y ESCRITURA
' =============================================================================

Private Function GetCode(ByVal c As Object) As String
    With c.CodeModule
        If .CountOfLines = 0 Then
            GetCode = ""
        Else
            GetCode = .Lines(1, .CountOfLines)
        End If
    End With
End Function

Private Sub SetCode(ByVal c As Object, ByVal txt As String)
    With c.CodeModule
        If .CountOfLines > 0 Then .DeleteLines 1, .CountOfLines
        If Len(txt) > 0 Then .AddFromString txt
    End With
End Sub

' =============================================================================
' INYECCIÓN DE VARIABLE DUMMY
' =============================================================================

Private Function InjectDummyDeclarationOnce(ByVal code As String) As String
    Dim lines() As String, i As Long
    Dim result() As String
    Dim injected As Boolean, count As Long
    
    lines = Split(code, vbCrLf)
    ReDim result(UBound(lines) + 1)
    
    injected = False
    count = 0

    For i = LBound(lines) To UBound(lines)
        result(count) = lines(i)
        count = count + 1
        
        If Not injected Then
            Dim trimLine As String
            trimLine = LCase$(Trim$(lines(i)))
            
            If trimLine Like "sub *" Or trimLine Like "public sub *" Or _
               trimLine Like "private sub *" Or trimLine Like "function *" Or _
               trimLine Like "public function *" Or trimLine Like "private function *" Then
                result(count) = "    Dim ofuDummy As Long"
                count = count + 1
                injected = True
            End If
        End If
    Next i
    
    ReDim Preserve result(count - 1)
    InjectDummyDeclarationOnce = Join(result, vbCrLf)
End Function

' =============================================================================
' OFUSCACIÓN INTELIGENTE
' =============================================================================

Private Function ObfuscateCodeSmart(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String
    Dim count As Long
    Dim noiseVariant As Long
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines) * 2)
    
    count = 0
    noiseVariant = 0

    For i = LBound(lines) To UBound(lines)
        result(count) = ObfuscateLineSmart(lines(i), key)
        count = count + 1
        
        ' Insertar ruido SOLO si la línea NO termina con _
        If NOISE_RATE > 0 And i Mod NOISE_RATE = 0 And i > LBound(lines) Then
            If Not LineEndsWithContinuation(lines(i)) Then
                ' Variar el tipo de ruido
                noiseVariant = (noiseVariant + 1) Mod 3
                Select Case noiseVariant
                    Case 0
                        result(count) = m_TagNoise: count = count + 1
                        result(count) = "If False Then": count = count + 1
                        result(count) = "    ofuDummy = 0": count = count + 1
                        result(count) = "End If": count = count + 1
                    Case 1
                        result(count) = m_TagNoise: count = count + 1
                        result(count) = "On Error Resume Next": count = count + 1
                        result(count) = "ofuDummy = ofuDummy + 0": count = count + 1
                        result(count) = "On Error GoTo 0": count = count + 1
                    Case 2
                        result(count) = m_TagNoise: count = count + 1
                        result(count) = "Do While False": count = count + 1
                        result(count) = "    ofuDummy = 1": count = count + 1
                        result(count) = "Loop": count = count + 1
                End Select
            End If
        End If
    Next

    ReDim Preserve result(count - 1)
    ObfuscateCodeSmart = Join(result, vbCrLf)
End Function

' Detecta si una línea termina con continuación _
Private Function LineEndsWithContinuation(ByVal ln As String) As Boolean
    Dim trimmed As String
    trimmed = RTrim$(ln)
    
    ' Verificar si termina con _ (fuera de comentarios y strings)
    If Len(trimmed) > 0 Then
        If Right$(trimmed, 1) = "_" Then
            ' Verificar que no esté dentro de un comentario
            Dim commentPos As Long
            commentPos = InStr(trimmed, "'")
            If commentPos = 0 Or commentPos > Len(trimmed) - 1 Then
                LineEndsWithContinuation = True
                Exit Function
            End If
        End If
    End If
    
    LineEndsWithContinuation = False
End Function

' =============================================================================
' OFUSCACIÓN DE LÍNEA INTELIGENTE
' =============================================================================

Private Function ObfuscateLineSmart(ByVal ln As String, ByVal key As Long) As String
    Dim i As Long, ch As String
    Dim result As String
    Dim inString As Boolean, commentStart As Long
    
    ' 1. NO OFUSCAR líneas con Const
    If IsConstDeclaration(ln) Then
        ObfuscateLineSmart = ln
        Exit Function
    End If
    
    ' 2. Buscar comentario (fuera de strings)
    inString = False
    commentStart = 0
    
    For i = 1 To Len(ln)
        ch = Mid$(ln, i, 1)
        If ch = """" Then
            inString = Not inString
        ElseIf ch = "'" And Not inString Then
            commentStart = i
            Exit For
        End If
    Next
    
    ' 3. Separar código y comentario
    Dim codePart As String, commentPart As String
    
    If commentStart > 0 Then
        codePart = Left$(ln, commentStart - 1)
        commentPart = Mid$(ln, commentStart + 1)
    Else
        codePart = ln
        commentPart = ""
    End If
    
    ' 4. Ofuscar strings en código
    result = ObfuscateStringsInCode(codePart, key)
    
    ' 5. Agregar comentario ofuscado con tag aleatorio
    If Len(commentPart) > 0 Then
        result = result & m_TagComment & ToHex4(commentPart, key)
    End If
    
    ObfuscateLineSmart = result
End Function

' Detecta si es una declaración de constante
Private Function IsConstDeclaration(ByVal ln As String) As Boolean
    Dim trimmed As String, firstWord As String
    Dim p As Long
    
    trimmed = LCase$(Trim$(ln))
    
    ' Buscar "Const" al inicio (puede tener Private/Public antes)
    If trimmed Like "const *" Then
        IsConstDeclaration = True
    ElseIf trimmed Like "private const *" Then
        IsConstDeclaration = True
    ElseIf trimmed Like "public const *" Then
        IsConstDeclaration = True
    Else
        IsConstDeclaration = False
    End If
End Function

' Ofusca strings en código
Private Function ObfuscateStringsInCode(ByVal code As String, ByVal key As Long) As String
    Dim result As String, i As Long
    Dim ch As String, inString As Boolean
    Dim currentString As String, beforeString As String
    
    result = ""
    inString = False
    currentString = ""
    beforeString = ""
    
    For i = 1 To Len(code)
        ch = Mid$(code, i, 1)
        
        If ch = """" Then
            If inString Then
                result = result & beforeString
                If Len(currentString) > 0 Then
                    result = result & "dDecode(""" & ToHex4(currentString, key) & """," & key & ")"
                Else
                    result = result & """"""
                End If
                beforeString = ""
                currentString = ""
                inString = False
            Else
                result = result & beforeString
                beforeString = ""
                inString = True
            End If
        Else
            If inString Then
                currentString = currentString & ch
            Else
                beforeString = beforeString & ch
            End If
        End If
    Next
    
    result = result & beforeString
    ObfuscateStringsInCode = result
End Function

' =============================================================================
' DESOFUSCACIÓN INTELIGENTE
' =============================================================================

Private Function DeobfuscateCodeSmart(ByVal src As String, ByVal key As Long) As String
    Dim lines() As String, i As Long
    Dim result() As String
    Dim count As Long, skipNext As Long
    
    lines = Split(src, vbCrLf)
    ReDim result(UBound(lines))
    
    count = 0
    skipNext = 0

    For i = LBound(lines) To UBound(lines)
        If skipNext > 0 Then
            skipNext = skipNext - 1
            GoTo NextLine
        End If
        
        Dim ln As String, trimLine As String
        ln = lines(i)
        trimLine = Trim$(ln)
        
        ' Detectar tags de ruido (cualquier tag que empiece con '_)
        If Left$(ln, 2) = "'_" Then
            ' Es un tag - determinar qué tipo de ruido viene
            If InStr(ln, "_K=") > 0 Then
                ' Es la clave - saltar
                GoTo NextLine
            Else
                ' Es tag de ruido - detectar cuántas líneas saltar
                If i + 1 <= UBound(lines) Then
                    Dim nextLine As String
                    nextLine = Trim$(lines(i + 1))
                    
                    If nextLine = "If False Then" Then
                        skipNext = 2
                    ElseIf nextLine = "On Error Resume Next" Then
                        skipNext = 2
                    ElseIf nextLine = "Do While False" Then
                        skipNext = 2
                    End If
                End If
                GoTo NextLine
            End If
        End If
        
        ' Filtrar líneas de ruido conocidas
        If trimLine = "If False Then" Or trimLine = "End If" Then GoTo NextLine
        If trimLine = "On Error Resume Next" Or trimLine = "On Error GoTo 0" Then
            ' Solo saltar si es ruido (verificar contexto)
            If i > 0 And Left$(Trim$(lines(i - 1)), 2) = "'_" Then GoTo NextLine
        End If
        If trimLine = "Do While False" Or trimLine = "Loop" Then
            If i > 0 And Left$(Trim$(lines(i - 1)), 2) = "'_" Then GoTo NextLine
        End If
        If InStr(trimLine, "Dim ofuDummy") > 0 Then GoTo NextLine
        If trimLine = "ofuDummy = ofuDummy + 0" Or trimLine = "ofuDummy = 0" Or trimLine = "ofuDummy = 1" Then GoTo NextLine
        
        ' Restaurar línea
        result(count) = RestoreLineSmart(ln, key)
        count = count + 1
        
NextLine:
    Next

    ReDim Preserve result(count - 1)
    DeobfuscateCodeSmart = Join(result, vbCrLf)
End Function

' =============================================================================
' RESTAURACIÓN INTELIGENTE
' =============================================================================

Private Function RestoreLineSmart(ByVal ln As String, ByVal key As Long) As String
    Dim p As Long, result As String
    
    result = ln
    
    ' 1. Restaurar comentario (buscar cualquier tag que empiece con '_' y tenga ':')
    p = InStr(result, "'_")
    If p > 0 Then
        Dim colonPos As Long
        colonPos = InStr(p, result, ":")
        If colonPos > 0 Then
            ' Es un comentario ofuscado
            Dim hexStr As String
            hexStr = Mid$(result, colonPos + 1)
            result = Left$(result, p - 1) & "'" & FromHex4Fast(hexStr, key)
            RestoreLineSmart = result
            Exit Function
        End If
    End If
    
    ' 2. Restaurar strings
    Dim maxIterations As Long
    maxIterations = 0
    
    Do While InStr(result, "dDecode(""") > 0 And maxIterations < 100
        maxIterations = maxIterations + 1
        
        p = InStr(result, "dDecode(""")
        Dim p2 As Long, pEnd As Long
        
        p2 = InStr(p + 10, result, """")
        If p2 = 0 Then Exit Do
        
        pEnd = InStr(p2 + 1, result, ")")
        If pEnd = 0 Then Exit Do
        
        hexStr = Mid$(result, p + 9, p2 - p - 9)
        Dim decoded As String
        decoded = FromHex4Fast(hexStr, key)
        
        result = Left$(result, p - 1) & """" & decoded & """" & Mid$(result, pEnd + 1)
    Loop
    
    RestoreLineSmart = result
End Function

' =============================================================================
' CODIFICACIÓN / DECODIFICACIÓN HEX4
' =============================================================================

Private Function ToHex4(ByVal s As String, ByVal k As Long) As String
    Dim i As Long, charCode As Long
    Dim result As String
    Dim hexChunk As String
    
    result = Space$(Len(s) * 4)
    
    For i = 1 To Len(s)
        charCode = AscW(Mid$(s, i, 1)) Xor k
        hexChunk = Right$("0000" & Hex$(charCode), 4)
        Mid$(result, (i - 1) * 4 + 1, 4) = hexChunk
    Next
    
    ToHex4 = result
End Function

Private Function FromHex4Fast(ByVal hex4 As String, ByVal k As Long) As String
    Dim i As Long, v As Long
    Dim length As Long
    Dim result As String
    
    length = Len(hex4)
    If length Mod 4 <> 0 Then
        FromHex4Fast = ""
        Exit Function
    End If
    
    result = Space$(length \ 4)
    
    On Error Resume Next
    For i = 1 To length Step 4
        v = CLng("&H" & Mid$(hex4, i, 4))
        If Err.Number = 0 Then
            Mid$(result, (i \ 4) + 1, 1) = ChrW$(v Xor k)
        End If
    Next
    On Error GoTo 0
    
    FromHex4Fast = result
End Function

' =============================================================================
' UTILIDADES
' =============================================================================

Private Function MakeKey() As Long
    Randomize
    MakeKey = CLng(Rnd * 65534) + 1
End Function

Private Function ExtractKey(ByVal src As String) As Long
    Dim lines() As String, i As Long
    Dim ln As String
    
    lines = Split(src, vbCrLf)
    
    ' Buscar línea que contenga '_K='
    For i = LBound(lines) To UBound(lines)
        ln = lines(i)
        If InStr(ln, "_K=") > 0 Then
            Dim p As Long, s As String
            p = InStr(ln, "=")
            If p > 0 Then
                s = Trim$(Mid$(ln, p + 1))
                If IsNumeric(s) Then
                    ExtractKey = CLng(s)
                    Exit Function
                End If
            End If
        End If
    Next
    
    ExtractKey = 0
End Function
