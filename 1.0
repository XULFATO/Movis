Option Explicit

' Módulo: modObfuscator
' Rol: Ofuscador unidireccional local, sin dependencias, estilo VBAD interno
' Cumple: sin DLL, sin EXE, sin PowerShell, one-way, mantiene funcionalidad

Private Type TCodeUnit
    Name As String
    Code As String
    IsClass As Boolean
    IsPublic As Boolean
End Type

Public Sub OfuscarProyecto()
    Dim f As String, copyPath As String
    Dim app As Excel.Application
    Dim wbSrc As Workbook, wbCopy As Workbook
    Dim vbp As VBIDE.VBProject, cmp As VBIDE.VBComponent
    Dim cu As TCodeUnit, modified As String
    Dim ok As VbMsgBoxResult
    
    On Error GoTo ErrHandler
    
    f = GetFilePath()
    If Len(f) = 0 Then Exit Sub
    
    copyPath = Left(f, InStrRev(f, ".")) & "_BLACKBOX.xlsm"
    FileCopy f, copyPath
    MsgBox "Procesando copia: " & vbCrLf & copyPath, vbInformation
    
    Set app = New Excel.Application
    app.Visible = False
    app.EnableEvents = False
    app.DisplayAlerts = False
    app.AutomationSecurity = msoAutomationSecurityForceDisable
    
    Set wbCopy = app.Workbooks.Open(copyPath)
    Set vbp = wbCopy.VBProject
    
    For Each cmp In vbp.VBComponents
        If IsCodeComponent(cmp) Then
            cu.Name = cmp.Name
            cu.Code = cmp.CodeModule.Lines(1, cmp.CodeModule.CountOfLines)
            cu.IsClass = (cmp.Type = vbext_ct_ClassModule)
            cu.IsPublic = IsPublicComponent(cu.Code)
            
            modified = ProcessCode(cu.Code)
            
            With cmp.CodeModule
                .DeleteLines 1, .CountOfLines
                .InsertLines 1, modified
            End With
        End If
    Next cmp
    
    wbCopy.Save
    wbCopy.Close False
    app.Quit
    
    MsgBox "Ofuscado completado ✓" & vbCrLf & copyPath, vbInformation
    
CleanExit:
    On Error Resume Next
    Set cmp = Nothing: Set vbp = Nothing
    If Not wbCopy Is Nothing Then wbCopy.Close False
    If Not app Is Nothing Then app.Quit
    Set app = Nothing
    Exit Sub
ErrHandler:
    MsgBox "Error: " & Err.Description, vbCritical
    Resume CleanExit
End Sub

Private Function GetFilePath() As String
    With Application.FileDialog(msoFileDialogFilePicker)
        .Title = "Selecciona el archivo Excel a ofuscar"
        .Filters.Clear
        .Filters.Add "Excel Macro-Enabled", "*.xlsm;*.xlsb"
        If .Show = -1 Then GetFilePath = .SelectedItems(1)
    End With
End Function

Private Function IsCodeComponent(cmp As VBIDE.VBComponent) As Boolean
    Select Case cmp.Type
        Case vbext_ct_StdModule, vbext_ct_ClassModule, vbext_ct_Document
            IsCodeComponent = True
    End Select
End Function

Private Function IsPublicComponent(code As String) As Boolean
    Dim firstPub As Long
    firstPub = InStr(1, code, "Public Sub", vbTextCompare)
    If firstPub > 0 Then IsPublicComponent = True
End Function

Private Function ProcessCode(src As String) As String
    Dim txt As String
    txt = src
    txt = RemoveComments(txt)
    txt = CompactCode(txt)
    txt = RenamePrivates(txt)
    txt = RenameLocals(txt)
    ProcessCode = txt
End Function

Private Function RemoveComments(txt As String) As String
    Dim lines() As String, i As Long, out As String
    lines = Split(txt, vbCrLf)
    For i = LBound(lines) To UBound(lines)
        If InStr(lines(i), "'") > 0 Then
            lines(i) = RemoveLineComment(lines(i))
        End If
        If Trim(lines(i)) <> "" Then out = out & lines(i) & vbCrLf
    Next i
    RemoveComments = out
End Function

Private Function RemoveLineComment(lineText As String) As String
    Dim i As Long, c As String, inStr As Boolean, out As String
    For i = 1 To Len(lineText)
        c = Mid(lineText, i, 1)
        Select Case c
            Case """": inStr = Not inStr
            Case "'": If Not inStr Then Exit For
        End Select
        out = out & c
    Next i
    RemoveLineComment = RTrim(out)
End Function

Private Function CompactCode(txt As String) As String
    Dim s As String
    s = Replace(txt, vbTab, "")
    s = Replace(s, "    ", "")
    s = Replace(s, vbCrLf & vbCrLf, vbCrLf)
    CompactCode = s
End Function

Private Function RenamePrivates(txt As String) As String
    Dim re As Object, mc As Object, m As Object
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    Dim i As Long, newName As String
    Set re = CreateObject("VBScript.RegExp")
    re.IgnoreCase = True
    re.Global = True
    re.Pattern = "\bPrivate\s+(Sub|Function)\s+([A-Za-z0-9_]+)"
    Set mc = re.Execute(txt)
    For Each m In mc
        If Not dict.Exists(m.SubMatches(1)) Then
            newName = "P" & Hex(CRC32(m.SubMatches(1) & Timer))
            dict.Add m.SubMatches(1), newName
        End If
    Next m
    For Each m In dict.Keys
        txt = Replace(txt, m, dict(m))
    Next
    RenamePrivates = txt
End Function

Private Function RenameLocals(txt As String) As String
    Dim re As Object, mc As Object, m As Object
    Dim dict As Object: Set dict = CreateObject("Scripting.Dictionary")
    Dim vName As String, repl As String
    Set re = CreateObject("VBScript.RegExp")
    re.Pattern = "\bDim\s+([A-Za-z_][A-Za-z0-9_]*)"
    re.Global = True
    Set mc = re.Execute(txt)
    For Each m In mc
        vName = m.SubMatches(0)
        If Not dict.Exists(vName) Then
            repl = "v" & Hex(CRC32(vName & Timer))
            dict.Add vName, repl
        End If
    Next m
    For Each vName In dict.Keys
        txt = Replace(txt, vName, dict(vName))
    Next
    RenameLocals = txt
End Function

Private Function CRC32(text As String) As Long
    Dim crc As Long, i As Long, j As Long, c As Byte
    crc = &HFFFFFFFF
    For i = 1 To Len(text)
        c = Asc(Mid$(text, i, 1))
        crc = crc Xor c
        For j = 0 To 7
            If (crc And 1) Then
                crc = &HEDB88320 Xor ((crc And &HFFFFFFFE) \ 2)
            Else
                crc = (crc And &HFFFFFFFE) \ 2
            End If
        Next j
    Next i
    CRC32 = crc Xor &HFFFFFFFF
End Function
